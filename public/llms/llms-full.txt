# Field Nation Integrations — Full Text

## Table of Contents

### Documentation
- Getting Started (5)
- REST API (6)
- Webhooks (21)
- Connectors (34)
- Resources (5)

### API References
- REST API (145)
- Webhooks (12)

## Documentation

## Getting Started (5)

### undefined
URL: /docs/getting-started/choosing-your-approach

# Getting Started: undefined
URL: /docs/getting-started/choosing-your-approach
Source: content/docs/getting-started/choosing-your-approach.mdx

---
title: Choosing Your Approach
description: Decide between code-based integration (REST API + Webhooks) and no-code connectors
icon: GitBranch
---

## Quick Comparison

  
    ### Code-Based Integration
    
    **Best for:** Custom integrations, unique workflows, maximum control
    
    **What you build:**
    - REST API calls to create/manage work orders (inbound)
    - Webhook listeners to receive events (outbound)
    - Custom business logic and transformations
    
    **Requirements:**
    - Developer resources
    - Programming knowledge (any language)
    - OAuth 2.0 implementation
    - HTTPS webhook endpoint
    
    **Time to deploy:** Days to weeks (depending on complexity)
    
    **Flexibility:** ⭐⭐⭐⭐⭐ Complete control
  
  
  
    ### No-Code Integration
    
    **Best for:** Standard workflows, ERP/CRM/PSA platforms, quick deployment
    
    **What you get:**
    - Out-of-the-box integration
    - Pre-configured field mappings
    - Managed authentication
    - Built-in error handling
    
    **Requirements:**
    - Supported platform (Salesforce, ServiceNow, etc.)
    - Platform admin access
    - Field Nation integration contract
    
    **Time to deploy:** Hours to days
    
    **Flexibility:** ⭐⭐⭐ Configurable within connector capabilities
  

---

## Integration Architecture

Understanding how data flows through Field Nation helps you choose the right approach:

  
  

### How the Architecture Works

The diagram illustrates three integration paths to Field Nation's core platform:

**Code-Based Integration (Bottom Layer):**
- **Client API** - Direct REST API calls from your system to create/manage work orders
- **Webhooks** - Event notifications from Field Nation to your system
- **Your Responsibility:** Authentication, data transformation, error handling, retry logic

**Connector Integration (Top Layer):**
- **OOB Connectors** - Pre-built integrations for Salesforce, ServiceNow, Autotask, etc.
- **REST Connector** - Generic connector for systems with OpenAPI specifications
- **Broker Layer** - Field Nation middleware that handles authentication, mapping, queuing, and retries
- **Managed Service:** Field Nation handles complexity

**Core Platform:**
- **FN-CORE** - Where all work orders, providers, schedules, and data reside
- All integration paths ultimately communicate with FN-CORE
- Client API serves as the gateway layer

---

## Detailed Comparison

| Factor | REST API + Webhooks | Pre-built Connectors |
|--------|---------------------|---------------------|
| **Setup Complexity** | Moderate to High | Low |
| **Developer Required** | Yes | No |
| **Customization** | Unlimited | Limited to connector features |
| **Maintenance** | Your responsibility | Managed by Field Nation |
| **Supported Platforms** | Any system | 9 platforms + REST Connector |
| **Cost** | Development time | Integration contract |
| **API Endpoints** | 150+ endpoints | Connector-specific |
| **Webhook Events** | 33 events | Automatic event mapping |
| **Best Use Case** | Custom apps, unique workflows | Standard ERP/CRM/PSA workflows |

---

## Code-Based Integration

The combination of **REST API + Webhooks** provides powerful and flexible integration capabilities.

### How It Works

  
    ### Inbound: REST API
    
    Use the REST API to **push data to Field Nation**:
    - Create work orders from your system
    - Update work order details
    - Manage provider assignments
    - Handle tasks and deliverables
    
    **Example:** When a ticket is created in your system, call the REST API to create a corresponding Field Nation work order.
  
  
  
    ### Outbound: Webhooks
    
    Configure webhooks to **receive events from Field Nation**:
    - Work order status changes
    - Provider assignments
    - Task completions
    - Deliverable uploads
    
    **Example:** When a provider completes work, Field Nation sends a webhook to your endpoint, triggering ticket closure in your system.
  

### Current Webhook Events

We currently support **33 events** across work order lifecycle, assignments, tasks, and status changes. This covers essential integration scenarios:

- Work order creation, updates, deletions
- Status transitions (assigned, work done, approved, paid)
- Provider actions (checked in, checked out, uploads)
- Task completions
- Schedule updates
- Custom field changes

> [INFO] While 33 events cover core workflows, we're continuously expanding event coverage. Check the [Webhooks Events Catalog](/docs/webhooks/concepts/events) for the complete list.

### When to Choose REST API + Webhooks

✅ **Choose this approach if:**

- You're building a custom application
- Your system isn't a supported connector platform
- You need unique workflow logic
- You want full control over integration behavior
- You have developer resources available
- You need to integrate with multiple Field Nation features

### Getting Started with Code-Based

1. Review [Prerequisites](/docs/getting-started/prerequisites)
2. Follow [REST API Quickstart](/docs/rest-api/quickstart)
3. Set up [Webhooks](/docs/webhooks/quickstart)
4. Explore [REST API Introduction](/docs/rest-api/introduction) for all capabilities

---

## No-Code Integration (Connectors)

Pre-built connectors provide **turnkey integrations** with leading platforms, requiring minimal to no coding.

### Supported Platforms

  
  
  
  
  
  
  
  

### Special: REST Connector

The **REST Connector** is a unique offering that can connect to **almost any system** with an OpenAPI specification.

**How it works:**
1. You provide your system's OpenAPI spec
2. Field Nation uses it to configure field mappings
3. Authentication is set up using your system's credentials
4. The connector manages bidirectional synchronization

**Limitations:**
- Some advanced features may not be available
- Requires your system to have an OpenAPI spec
- Field mapping is based on spec definitions

> The REST Connector requires Field Nation configuration. [Submit a support case](https://app.fieldnation.com/support-cases) to discuss your specific system and requirements.

### When to Choose Connectors

✅ **Choose connectors if:**

- You use a supported platform (Salesforce, ServiceNow, etc.)
- You want quick deployment (hours, not weeks)
- You prefer no-code/low-code solutions
- You have standard field service workflows
- You want Field Nation to manage integration maintenance

### Getting Started with Connectors

1. Review [Connector Overview](/docs/connectors/introduction)
2. Find your platform in [Supported Platforms](/docs/connectors/introduction)
3. Follow platform-specific setup guides
4. For REST Connector: [Contact Support](https://app.fieldnation.com/support-cases)

---

## Can I Use Both?

**Yes!** Many customers combine approaches:

- **Connectors for standard workflows** (e.g., Salesforce ticket → Field Nation work order)
- **REST API for custom features** (e.g., advanced reporting, custom dashboards)
- **Webhooks for real-time notifications** (e.g., mobile app notifications)

This hybrid approach gives you the speed of connectors with the flexibility of custom code where needed.

---

## Decision Tree

Use this flowchart to determine your approach:

```mermaid
graph TD
    A[Need Field Nation Integration?] --> B{Using Salesforce, ServiceNow,<br/>Autotask, or other<br/>supported platform?}
    B -->|Yes| C{Standard workflow<br/>sufficient?}
    B -->|No| D{Have OpenAPI spec<br/>for your system?}
    
    C -->|Yes| E[Use Pre-built Connector]
    C -->|No| F[Use Connector + REST API]
    
    D -->|Yes| G[Consider REST Connector]
    D -->|No| H[Use REST API + Webhooks]
    
    G --> I[Contact Support]
    
    E --> J[Quick deployment<br/>Hours to days]
    F --> K[Hybrid approach<br/>Days to weeks]
    H --> L[Full custom<br/>Days to weeks]
    I --> M[Support evaluates<br/>feasibility]
```

---

## Getting Help

### For Code-Based Integration

- **Documentation:** [REST API](/docs/rest-api/introduction) and [Webhooks](/docs/webhooks/introduction)
- **Support Portal:** [Submit a case](https://app.fieldnation.com/support-cases) for technical questions
- **Sales Team:** Contact your Field Nation representative

### For Connector Integration

- **Connector Docs:** [Browse platforms](/docs/connectors/introduction)
- **Support Portal:** [Submit a case](https://app.fieldnation.com/support-cases) to request connector access
- **Integration Team:** Dedicated support during setup

### General Resources

- **Marketing Site:** Learn about [Field Nation Integrations](https://fieldnation.com/field-nation-integrations?cta=main_nav)
- **Support Portal:** [Submit technical questions](https://app.fieldnation.com/support-cases)
- **Sales:** Contact your Field Nation representative

> [INFO] If you already have a Field Nation account, visit the [Support Portal](https://app.fieldnation.com/support-cases) to submit a case for integration access, technical questions, or connector setup assistance.

---

---

### undefined
URL: /docs/getting-started/introduction

# Getting Started: undefined
URL: /docs/getting-started/introduction
Source: content/docs/getting-started/introduction.mdx

---
title: Introduction
description: Discover how Field Nation Integration connects your systems to the world's most active field service marketplace
icon: Sparkles
---

Welcome to the **Field Nation Integration** Developer Portal. This documentation provides everything you need to integrate your systems with Field Nation's platform.

## What is Field Nation?

Field Nation is the world's most active field service marketplace and software solution that connects companies with service professionals to get work done. With Field Nation Integration, you can:

- **Automate work order creation** from your existing systems
- **Track real-time updates** as technicians complete jobs
- **Manage provider assignments** programmatically
- **Sync deliverables and notes** back to your systems
- **Scale field service operations** without additional overhead

## Quick Links

  
    Programmatic access to Field Nation platform via REST API
  
  
    Real-time event notifications via Platform Event Streams
  
  
    Pre-built integrations for popular ERP and CRM platforms
  
  
    Reference materials, support, and additional resources
  

## Integration Approaches

Field Nation Integration offers multiple ways to connect your systems:

### REST API + Webhooks
**Code-based solution** for maximum flexibility and control. Use the REST API for inbound operations (creating work orders, managing providers) and Webhooks for real-time outbound event notifications.

- **97 REST API endpoints** for comprehensive platform access
- **33 webhook events** for real-time notifications
- Full control over data mapping and business logic
- Best for custom integrations and unique requirements

### Pre-built Connectors
**No-code solution** for popular ERP and CRM platforms. Connect your existing systems without writing code.

- **9 supported platforms**: Salesforce, ServiceNow, Autotask, ConnectWise, Freshdesk, NetSuite, Quickbase, Smartsheet, and REST Connector
- Visual field mapping interface
- Automatic synchronization
- Best for standard integrations with supported platforms

## Common Use Cases

### Automated Dispatch

Create Field Nation work orders automatically when tickets or cases reach specific statuses in your service management system. No manual work order entry required.

### Real-time Status Sync

Keep your internal systems updated as technicians check in, complete tasks, and upload deliverables. Maintain a single source of truth across platforms.

### Provider Management

Programmatically route work orders to preferred providers, manage talent pools, and track provider performance metrics through your existing dashboards.

### Deliverable Collection

Automatically sync photos, documentation, and completion notes from Field Nation back to your ticketing or CRM system for record-keeping and invoicing.

## Key Features

  
    Manage every aspect of work orders—creation, scheduling, pay, assignments, tasks, messages, and more—through our REST API with 150+ endpoints.
  
  
  
    Subscribe to 45+ work order events and status changes via webhooks. Get notified instantly when something happens, not after the fact.
  
  
  
    Pre-built integrations with leading platforms mean you can connect in hours, not weeks. No custom development required for standard workflows.
  
  
  
    Test your integration safely in our sandbox environment before going live. Full parity with production for confident deployments.
  
  
  
    OAuth 2.0 authentication, HMAC-SHA256 webhook signatures, IP whitelisting, and AES-256 credential encryption keep your data secure.
  

## Developer Experience

We've designed Field Nation Integration with developers in mind:

- **Clear, comprehensive documentation** with examples for every endpoint
- **OpenAPI specifications** for automatic client generation
- **Interactive API explorer** to test calls before writing code
- **Sandbox environment** with test data for safe experimentation
- **Webhook delivery logs** with 2-week retention for debugging
- **Support portal** with fast response times

## Need Help?

- **Support Portal**: [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases)
- **Phone Support**: +1 877-573-4353 (24/7, full capacity Mon-Fri, limited on weekends/holidays)
- **Status Page**: [status.fieldnation.com](https://status.fieldnation.com)

---

### undefined
URL: /docs/getting-started/key-concepts

# Getting Started: undefined
URL: /docs/getting-started/key-concepts
Source: content/docs/getting-started/key-concepts.mdx

---
title: Key Concepts
description: Essential terminology and concepts for Field Nation Integration
icon: BookOpen
---

## Work Orders

### Work Order
A job or task that needs to be completed at a physical location. Every integration revolves around creating, managing, or responding to work orders.

**Key Properties:**
- Unique ID for tracking
- Title and description
- Service window (schedule)
- Physical location
- Pay structure
- Status (draft, published, assigned, etc.)

### Work Order Status
Indicates the current stage of a work order in its lifecycle. Status changes trigger webhooks and determine available actions.

**Common Statuses:**
- `draft` - Not yet visible to providers
- `published` - Visible on marketplace
- `routed` - Sent to specific providers
- `assigned` - Provider committed
- `work_done` - Completed by provider
- `approved` - Accepted by buyer
- `paid` - Payment processed

### Service Window
The date and time range during which work can be performed. Service windows respect time zones and can be hours, days, or date ranges.

**Modes:**
- `hours` - Specific start and end times
- `between` - Date range flexibility
- `exact` - Precise appointment time

---

## Providers & Assignments

### Provider
An independent contractor who completes field service work. Providers have skills, certifications, ratings, and availability.

**Provider Properties:**
- User ID
- Name and contact info
- Rating (1-5 stars)
- Completed jobs count
- Skills and certifications

### Assignment
The relationship between a work order and a provider. When a provider is assigned, they're committed to completing the work.

**Assignment Process:**
1. Work order published or routed
2. Provider requests or accepts
3. Buyer confirms assignment
4. Provider completes work

### Routing
Sending a work order directly to specific providers. Routed providers receive notifications and can accept or decline.

**Routing Strategies:**
- **Manual Routing** - Select specific providers
- **Talent Pool Routing** - Route to provider groups
- **Mass Routing** - Invite multiple providers

### Talent Pool
A group of preferred providers organized by skills, geography, or performance. Simplifies routing to trusted technicians.

**Benefits:**
- Pre-vetted providers
- Faster assignment
- Consistent quality
- Tiered structures (A, B, C teams)

---

## Schedule & Time

### UTC vs Local Time
Field Nation stores all timestamps in UTC but also provides local times based on work order location.

**Best Practices:**
- Store UTC in your database
- Display local time to users
- Include timezone in API requests
- Handle daylight saving changes

### ETA (Estimated Time of Arrival)
Provider's estimated arrival time, updated in real-time as they travel to the job site.

### Check-In / Check-Out
Timestamps when providers arrive at and leave the job site. Often includes GPS coordinates for verification.

**Use Cases:**
- Time tracking
- Billing validation
- Provider accountability
- Job duration analytics

---

## Tasks & Deliverables

### Task
A specific action or requirement within a work order. Tasks form a checklist that providers must complete.

**Task Types:**
- Check-in
- Check-out
- Photos
- Signatures
- Custom requirements

**Task Status:**
- `incomplete` - Not yet done
- `complete` - Provider finished
- `not_required` - Skipped

### Deliverable
Files or data providers upload as proof of completion—photos, documents, signatures, or notes.

**Common Deliverables:**
- Before/after photos
- Network diagrams
- Signature captures
- Completion forms
- Serial number documentation

---

## Financial Concepts

### Pay Structure
How providers are compensated. Field Nation supports multiple payment models.

**Pay Types:**
- **Fixed** - Flat rate for the job
- **Hourly** - Rate per hour worked
- **Blended** - Combination of fixed and hourly
- **Device** - Per-device pricing

### Base Pay
The primary compensation amount before any additional costs, bonuses, or expenses.

### Expense
Reimbursable costs providers incur while completing work—travel, materials, parking, etc.

**Expense Categories:**
- Travel
- Mileage
- Parking
- Materials
- Other

### Bonus
Additional payment offered to incentivize work acceptance or quality performance.

**Bonus Scenarios:**
- Rush jobs
- After-hours work
- Difficult locations
- High-priority work

### Penalty
Deduction from pay due to performance issues—late arrival, incomplete work, policy violations.

---

## Integration Architecture

### REST API
Representational State Transfer API using HTTP methods (GET, POST, PUT, DELETE) to manage resources.

**Characteristics:**
- Stateless requests
- JSON request/response
- OAuth 2.0 authentication
- RESTful resource URLs

### Webhook
HTTP callback that delivers real-time notifications when events occur on Field Nation.

**Webhook Flow:**
1. Event happens (e.g., work order assigned)
2. Field Nation sends POST to your endpoint
3. Your system processes the event
4. You respond with 200 OK

### Event
Something that happens on the platform—work order created, provider assigned, task completed, etc.

**Event Properties:**
- Event name (e.g., `workorder.status.assigned`)
- Timestamp
- Triggering user
- Full work order data

### OAuth 2.0
Industry-standard authentication protocol. Field Nation uses client credentials grant for machine-to-machine auth.

**Auth Flow:**
1. Exchange client ID + secret for access token
2. Include token in API request headers
3. Token expires after 1 hour
4. Refresh with new authentication request

---

## Templates & Configuration

### Template
Pre-configured work order settings that streamline creation. Templates define standard tasks, custom fields, and requirements.

**Template Benefits:**
- Consistency across work orders
- Reduced API payload size
- Faster creation
- Fewer errors

### Project
Organizational container for related work orders. Projects group similar work and apply consistent settings.

**Project Uses:**
- Multi-site rollouts
- Ongoing maintenance programs
- Customer-specific work
- Budget tracking

### Custom Field
User-defined field that extends the work order data model with organization-specific information.

**Custom Field Types:**
- Text (single line)
- Text area (multi-line)
- Number
- Date
- Dropdown (picklist)
- Checkbox

---

## Data & Transformation

### Field Mapping
Configuration that defines how data flows between your system and Field Nation. Maps your field names to Field Nation's schema.

**Mapping Actions:**
- **Sync** - Direct field-to-field copy
- **Static** - Fixed value
- **Array Map** - Lookup table (e.g., status codes)
- **Custom** - Transformation logic

### JSONNET
Data templating language used in connectors for complex field transformations.

**Use Cases:**
- Conditional logic
- Data aggregation
- Format conversion
- Calculated fields

### Broker / Middleware
Field Nation's integration layer that handles authentication, mapping, queuing, and retry logic for pre-built connectors.

**Broker Functions:**
- Manages API credentials
- Transforms data between systems
- Handles retry on failure
- Logs all operations

---

## Error Handling

### HTTP Status Codes
Standard codes indicating request success or failure:

- **200 OK** - Success
- **201 Created** - Resource created
- **400 Bad Request** - Invalid input
- **401 Unauthorized** - Auth failure
- **403 Forbidden** - Insufficient permissions
- **404 Not Found** - Resource doesn't exist
- **429 Too Many Requests** - Rate limit exceeded
- **500 Internal Server Error** - Server error

### Retry Logic
Automated attempt to resend failed requests. Uses exponential backoff to avoid overwhelming systems.

**Retry Pattern:**
- Initial delay: 10 seconds
- Double delay each attempt
- Maximum 7 attempts
- Give up after final attempt

### Dead Letter Queue
Storage for messages that failed all retry attempts. Allows manual review and recovery.

---

## Security

### Access Token
Short-lived credential (1 hour) that authorizes API requests. Obtained via OAuth 2.0.

### Client ID & Secret
Long-lived credentials that identify your application. Used to obtain access tokens.

**Security:**
- Never expose client secret in client-side code
- Store securely (environment variables, key vault)
- Rotate periodically
- Don't commit to version control

### Webhook Signature
HMAC-SHA256 hash in the `x-fn-signature` header that verifies webhook authenticity.

**Verification Process:**
1. Extract signature from header
2. Compute HMAC of request body using your secret
3. Compare signatures with timing-safe comparison
4. Reject if signatures don't match

### IP Whitelisting
Restricting webhook endpoint access to known Field Nation IP addresses.

**Field Nation IPs:**
- **Sandbox**: 44.225.211.232, 44.237.253.26
- **Production**: 3.226.5.230, 34.198.172.230

---

## Monitoring & Observability

### Delivery Log
Record of webhook delivery attempts—successes, failures, retries, and payloads.

**Log Retention:** 2 weeks

### Rate Limit
Maximum number of API requests allowed within a time window (typically 60/minute).

**Rate Limit Headers:**
- `X-Rate-Limit-Limit` - Total allowed
- `X-Rate-Limit-Remaining` - Requests left
- `X-Rate-Limit-Reset` - When limit resets

### Idempotency
Property where repeating an operation produces the same result. Important for safe retries.

**Idempotent Operations:**
- GET requests (reads)
- PUT requests (full updates)
- DELETE requests (deletions)

**Non-Idempotent:**
- POST requests (creates new resources)

---

## Glossary Quick Reference

| Term | Definition |
|------|------------|
| **API** | Application Programming Interface - programmatic access to Field Nation |
| **Buyer** | Company that posts work orders to Field Nation |
| **Provider** | Technician who completes field service work |
| **Work Order** | Job to be completed at a physical location |
| **Assignment** | Provider committed to completing a work order |
| **Routing** | Inviting specific providers to accept work |
| **Service Window** | Date/time range when work can be performed |
| **Deliverable** | File or data uploaded by provider as proof of completion |
| **Template** | Pre-configured work order settings |
| **Webhook** | Real-time event notification sent to your endpoint |
| **OAuth** | Authentication protocol for API access |
| **Sandbox** | Test environment for integration development |

---

## Visual Learning

Understanding how concepts relate helps build better integrations:

```mermaid
graph TD
    A[Work Order Created] --> B[Work Order Published]
    B --> C[Provider Routed]
    C --> D[Provider Assigned]
    D --> E[Provider Checks In]
    E --> F[Tasks Completed]
    F --> G[Provider Checks Out]
    G --> H[Work Done]
    H --> I[Buyer Approves]
    I --> J[Provider Paid]
```

---

---

### undefined
URL: /docs/getting-started/platform-overview

# Getting Started: undefined
URL: /docs/getting-started/platform-overview
Source: content/docs/getting-started/platform-overview.mdx

---
title: Platform Overview
description: Understanding Field Nation's work order lifecycle and platform capabilities
icon: LayoutDashboard
---

## The Work Order Lifecycle

Every work order on Field Nation progresses through a well-defined lifecycle. Your integration will interact with work orders at various stages, so understanding this flow is essential.

![Work Order Lifecycle](/docs/get-started/wo_lifecycle.png)

### Lifecycle Stages Explained

  
    ### Draft
    
    Work orders begin in draft status. You can edit all details—title, description, schedule, location, pay, tasks—before publishing.
    
    **Integration Actions:**
    - Create work orders via API
    - Update any field
    - Add attachments, tasks, custom fields
    - Delete if no longer needed
  
  
  
    ### Published
    
    Publishing makes work orders visible on the marketplace. Providers can request to be assigned or you can route to specific providers.
    
    **Integration Actions:**
    - Publish work orders
    - Monitor for provider requests
    - Route to preferred providers
    - Respond to provider questions via messages
  
  
  
    ### Routed
    
    Work orders in routed status have been sent to one or more providers. Providers can accept or decline routing invitations.
    
    **Integration Actions:**
    - Track which providers received routing
    - Monitor acceptance/decline responses
    - Route to additional providers if needed
    - Cancel routing if circumstances change
  
  
  
    ### Assigned
    
    An assigned work order has a committed provider. The provider has accepted responsibility for completing the work.
    
    **Integration Actions:**
    - Sync provider details to your system
    - Monitor schedule confirmations
    - Track "on my way" status
    - Receive check-in notifications
  
  
  
    ### Work Done
    
    The provider marks work complete and uploads deliverables (photos, notes, signatures). Buyers review before approval.
    
    **Integration Actions:**
    - Download deliverables
    - Review completion notes
    - Sync task completion status
    - Flag issues if work is incomplete
  
  
  
    ### Approved
    
    Buyers approve completed work, confirming quality and deliverables meet requirements. This triggers payment processing.
    
    **Integration Actions:**
    - Sync approval status
    - Record completion time
    - Close associated tickets
    - Update billing systems
  
  
  
    ### Paid
    
    Field Nation processes payment to the provider. The work order lifecycle is complete.
    
    **Integration Actions:**
    - Final status sync
    - Archive work order data
    - Generate completion reports
    - Update financial records
  

> [INFO] Work orders can also be **Cancelled** at any stage or **Postponed** if work needs to be rescheduled indefinitely.

---

## Core Platform Concepts

### Work Orders

Work orders are the foundation of Field Nation. Each work order represents a specific job that needs to be completed at a physical location.

**Key Components:**
- **Title & Description** - What work needs to be done
- **Schedule** - Service window (date/time range)
- **Location** - Physical address where work occurs
- **Pay** - Compensation structure (fixed, hourly, blended)
- **Tasks** - Checklist items (check-in, photos, etc.)
- **Custom Fields** - Your organization's specific data needs

### Providers

Providers are independent contractors who complete work orders. Field Nation has a marketplace of thousands of skilled technicians across various specialties.

**Provider Management:**
- **Talent Pools** - Groups of preferred providers
- **Rating System** - Performance tracking
- **Qualifications** - Skills and certifications
- **Availability** - Real-time scheduling

### Buyers

Buyers post work orders to the marketplace. As a buyer, you can:

- Create and manage work orders
- Route to specific providers
- Approve completed work
- Manage payments
- Access analytics and reporting

### Templates & Projects

**Templates** streamline work order creation by pre-configuring:
- Standard tasks
- Custom fields
- Payment structures
- Attachment requirements
- Contact information

**Projects** organize related work orders:
- Group similar work
- Apply consistent settings
- Track progress across multiple orders
- Manage provider teams

> [INFO] Use templates and projects to reduce the data your integration needs to send. Reference a template ID instead of defining every task and custom field in each API call.

---

## Integration Architecture

Field Nation offers three integration approaches, each suited for different use cases:

  ![Field Nation Integration Architecture (light)](/docs/architecture-light.svg)

  ![Field Nation Integration Architecture (dark)](/docs/architecture-dark.svg)

The architecture diagram shows how external systems connect to Field Nation through different layers. Code-based integrations communicate directly with the Client API and Webhooks, while connector-based integrations flow through the Field Service Broker middleware.

### REST API

Full programmatic control over the platform. Create, read, update, and delete work orders, manage assignments, handle messages, and more.

**Best For:**
- Custom integrations
- Complex workflows
- Bi-directional synchronization
- Automated operations

**Capabilities:**
- 150+ endpoints
- Complete CRUD operations
- Bulk operations
- Advanced filtering

[Explore REST API →](/docs/rest-api/introduction)

### Webhooks

Real-time event notifications delivered to your endpoint when things happen on Field Nation.

**Best For:**
- Event-driven architectures
- Real-time updates
- Status synchronization
- Deliverable notifications

**Features:**
- 45+ event types
- Configurable subscriptions
- Signature verification
- Retry logic with exponential backoff

[Explore Webhooks →](/docs/webhooks/introduction)

### Pre-built Connectors

Out-of-the-box integrations with leading platforms require minimal code.

**Best For:**
- Standard workflows
- Quick deployment
- No-code/low-code scenarios
- Proven integrations

**Supported Platforms:**
- Salesforce
- ServiceNow
- Autotask
- ConnectWise
- And 5 more platforms

[Explore Connectors →](/docs/connectors/introduction)

---

## Environments

Field Nation provides two environments for integration development and production use:

  
    ### Sandbox Environment
    
    A safe testing environment with full API parity to production.
    
    **Base URL:** `https://api-sandbox.fndev.net`
    
    **Features:**
    - Separate from production data
    - Test work orders and providers
    - Full API functionality
    - Webhook testing
    - No real money transactions
    
    **Access:**
    - Available after integration contract
    - Provided during onboarding
    - Separate credentials from production
    
    **Best Practices:**
    - Test all workflows before production
    - Use for UAT with stakeholders
    - Validate error handling
    - Test webhook signatures
  
  
  
    ### Production Environment
    
    Live environment with real work orders, providers, and transactions.
    
    **Base URL:** `https://api.fieldnation.com`
    
    **Features:**
    - Real marketplace access
    - Actual provider assignments
    - Live payments
    - Production support SLAs
    
    **Access:**
    - Requires completed UAT
    - Production credentials issued after approval
    - Subject to rate limits
    
    **Best Practices:**
    - Deploy only after thorough sandbox testing
    - Implement monitoring and alerting
    - Have rollback procedures ready
    - Monitor error rates closely
  

---

## Platform Capabilities

### Work Order Management

- **Create & Publish** - API-driven work order creation
- **Bulk Operations** - Create multiple orders efficiently
- **Templates** - Reuse configurations
- **Custom Fields** - Extend data model
- **Attachments** - Upload specs and requirements

### Provider Management

- **Routing** - Direct assignment to specific providers
- **Talent Pools** - Manage preferred provider groups
- **Qualifications** - Set skill requirements
- **Performance Tracking** - Monitor provider metrics
- **Communication** - Message providers directly

### Schedule & Location

- **Service Windows** - Define acceptable work times
- **Time Zones** - Automatic timezone handling
- **ETAs** - Provider estimated arrival
- **On My Way** - Real-time provider tracking
- **Check-in/Out** - Time logging with GPS

### Tasks & Deliverables

- **Task Lists** - Define required actions
- **Photo Requirements** - Specify documentation needs
- **Signatures** - Capture approvals
- **Notes** - Provider completion summaries
- **File Uploads** - Receive deliverables

### Financial Management

- **Pay Structures** - Fixed, hourly, or blended
- **Expenses** - Track reimbursable costs
- **Bonuses** - Incentive payments
- **Penalties** - Performance-based deductions
- **Invoicing** - Automated billing

---

## Rate Limits & Performance

Field Nation implements rate limiting to ensure platform stability:

- **Default Limit:** 60 requests per minute per company
- **Burst Allowance:** Short bursts up to 100 requests
- **Headers:** Rate limit info in response headers
- **429 Status:** Returned when limits exceeded

> Implement exponential backoff when you receive 429 responses. The `Retry-After` header indicates when to retry.

**Best Practices:**
- Cache frequently accessed data
- Use bulk endpoints when available
- Implement request queuing
- Monitor rate limit headers

---

## Security & Compliance

### Authentication
- OAuth 2.0 Bearer tokens
- Token expiration (1 hour)
- Secure credential storage

### Data Protection
- HTTPS encryption (TLS 1.2+)
- AES-256 credential encryption
- Audit logging
- IP whitelisting (webhooks)

### Compliance
- SOC 2 Type II certified
- GDPR compliant
- PCI DSS compliant (for payments)
- Regular security audits

---

## Support & Resources

### Getting Help

- **Documentation:** Comprehensive guides and API reference
- **Support Portal:** [support.fieldnation.com](https://support.fieldnation.com/s/)
- **Developer Community:** Connect with other integrators
- **Program Management:** Dedicated support during onboarding

### Monitoring & Observability

- **Webhook Logs:** 2-week retention
- **API Response Codes:** Detailed error messages
- **Status Page:** Platform health monitoring
- **Email Alerts:** Webhook failure notifications

---

---

### undefined
URL: /docs/getting-started/prerequisites

# Getting Started: undefined
URL: /docs/getting-started/prerequisites
Source: content/docs/getting-started/prerequisites.mdx

---
title: Prerequisites
description: Everything you need before building your Field Nation integration
icon: CircleCheck
---

## Field Nation Requirements

### Active Buyer Account

You must have an active Buyer account on the Field Nation platform. Buyer accounts enable you to:

- Post work orders to the marketplace
- Route and assign work to providers
- Access API credentials
- Configure webhooks and integrations

> [INFO] Don't have a Buyer account? [Sign up for Field Nation](https://www.fieldnation.com/signup) to get started.

### Integration Contract

Field Nation requires an integration contract before provisioning API access. This contract establishes:

- **Scope of integration** - Which systems you're connecting
- **Data access levels** - What information you can read/write
- **Support commitment** - Program management assistance
- **Sandbox access** - Development environment provisioning

  
    ### Contact Sales
    
    Reach out to your Field Nation sales representative or account manager to discuss your integration needs. If you don't have a contact, submit a request through the [Support Portal](https://support.fieldnation.com/s/).
  
  
  
    ### Kick-off Call
    
    Once your contract is in place, our integration program management team will schedule a kick-off call to understand your requirements and technical architecture.
  
  
  
    ### Sandbox Provisioning
    
    After the kick-off call, you'll receive:
    - Sandbox environment credentials
    - API client ID and secret
    - Webhook access
    - Documentation access
  

## Technical Requirements

### Development Environment

Ensure your development environment includes:

- **Programming language** - Any language with HTTP/REST support (Node.js, Python, Java, C#, PHP, Ruby, Go)
- **HTTPS capability** - For secure webhook endpoints
- **OAuth 2.0 support** - For API authentication
- **JSON parsing** - For request/response handling

### System Requirements

Your systems should be able to:

- Make outbound HTTPS requests to Field Nation APIs
- Receive inbound HTTPS requests (for webhooks)
- Store API credentials securely
- Handle JSON payloads up to 5MB
- Process asynchronous operations

### Network Requirements

  
    **Outbound Access Required:**
    
    - **Sandbox**: `https://api-sandbox.fndev.net`
    - **Production**: `https://api.fieldnation.com`
    
    **Ports**: 443 (HTTPS)
    
    **IP Whitelisting**: Not required for outbound API calls
  
  
  
    **Inbound Access Required:**
    
    Your webhook endpoint must be accessible from Field Nation's IP addresses:
    
    **Sandbox IPs:**
    ```
    44.225.211.232
    44.237.253.26
    ```
    
    **Production IPs:**
    ```
    3.226.5.230
    34.198.172.230
    ```
    
    If your firewall requires IP whitelisting, add these addresses to your allowlist.
  

## Knowledge Requirements

### Recommended Familiarity

While we provide comprehensive documentation, having familiarity with these concepts will accelerate your integration development:

- **REST API principles** - HTTP methods, status codes, headers
- **OAuth 2.0 authentication** - Client credentials grant flow
- **Webhook architecture** - Event-driven systems, HMAC signatures
- **JSON data structures** - Parsing, serialization, nested objects
- **Asynchronous programming** - Callbacks, promises, async/await

### Field Service Domain Knowledge

Understanding field service operations helps design better integrations:

- **Work order lifecycle** - Draft, published, routed, assigned, completed, approved
- **Provider management** - Routing, assignments, talent pools
- **Service windows** - Scheduling, time zones, ETAs
- **Task management** - Check-ins, check-outs, deliverables
- **Pay structures** - Base pay, expenses, bonuses, penalties

> **New to field service?** Review our [Platform Overview](/docs/getting-started/platform-overview) to understand the work order lifecycle before building your integration.

## Optional But Recommended

### Testing Tools

These tools make integration development easier:

- **[Postman](https://www.postman.com/)** or **[Insomnia](https://insomnia.rest/)** - API testing and collection management
- **[ngrok](https://ngrok.com/)** or **[localtunnel](https://localtunnel.me/)** - Expose local webhooks for testing
- **[Webhook.site](https://webhook.site/)** - Inspect webhook payloads
- **[JSON Formatter](https://jsonformatter.org/)** - Validate and format JSON

### Version Control

Use Git or another version control system to:

- Track changes to integration code
- Collaborate with team members
- Roll back to previous versions if needed
- Document deployment history

### Monitoring Tools

Consider setting up monitoring for:

- **API call volumes** - Track request rates and identify spikes
- **Error rates** - Alert on authentication or validation failures
- **Webhook delivery success** - Monitor notification reliability
- **Response times** - Ensure performance meets SLAs

## Company ID Location

You'll need your Field Nation Company ID for API requests and support cases. Here's how to find it:

  
    Log in to the [Field Nation Platform](https://app.fieldnation.com)
  
  
  
    Click your user icon in the top right corner, then select **Company Settings**
    
    ![Company Settings](/docs/get-started/settings_company.png)
  
  
  
    Click **Company Profile**. Your company ID appears in the URL:
    
    ```
    https://app.fieldnation.com/company/profile/12345
                                                    ^^^^^
                                              Your Company ID
    ```
    
    ![Company Profile](/docs/get-started/company_profile.png)
  

> Keep your Company ID handy—you'll need it when requesting sandbox access, submitting support cases, and configuring certain integrations.

## Ready to Build?

Once you have:

- ✅ An active Buyer account
- ✅ Integration contract in place
- ✅ Sandbox credentials received
- ✅ Development environment set up
- ✅ Company ID documented

You're ready to proceed to [Choosing Your Approach](/docs/getting-started/choosing-your-approach) and build your first integration!

## Need Help?

If you're missing any prerequisites or have questions:

- **Sales**: Contact your account manager for contract questions
- **Technical**: Visit the [Support Portal](https://support.fieldnation.com/s/) or [submit a support case](https://app.fieldnation.com/support-cases)

---

## REST API (6)

### undefined
URL: /docs/rest-api/api-playground

# REST API: undefined
URL: /docs/rest-api/api-playground
Source: content/docs/rest-api/api-playground.mdx

---
title: API Playground
description: Jump to the REST API v2 playground to explore requests and responses.
icon: SatelliteDish
---

Visit the REST API v2 playground to try requests, view examples, and inspect responses:

  Open REST API Playground

---

### undefined
URL: /docs/rest-api/authentication

# REST API: undefined
URL: /docs/rest-api/authentication
Source: content/docs/rest-api/authentication.mdx

---
title: Authentication
description: OAuth 2.0 authentication for secure access to the Field Nation REST API.
icon: Lock
---

The Field Nation REST API uses OAuth 2.0 for authentication. All API requests require a valid access token.

## Authentication Flow

```mermaid
sequenceDiagram
    participant App as Your Application
    participant Auth as Auth Server
    participant API as REST API
    
    App->>Auth: POST /oauth/token<br/>(client credentials)
    Auth-->>App: access_token
    App->>API: API Request<br/>?access_token=...
    API-->>App: Response
```

---

## Obtaining an Access Token

### Endpoint

```
POST /authentication/api/oauth/token
```

**Base URL:**
- Sandbox: `https://api-sandbox.fndev.net`
- Production: `https://api.fieldnation.com`

---

### Request

**Headers:**
```
Content-Type: application/json
```

**Body:**
```json
{
  "grant_type": "client_credentials",
  "client_id": "YOUR_CLIENT_ID",
  "client_secret": "YOUR_CLIENT_SECRET",
  "scope": "api"
}
```

**Parameters:**

---

### Response

**Success (200 OK):**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

**Error (400/401):**
```json
{
  "error": "invalid_client",
  "error_description": "Client authentication failed"
}
```

---

## Using the Access Token

Include the access token in all API requests as a **query parameter**:

```
GET /api/rest/v2/workorders?access_token=YOUR_ACCESS_TOKEN
```

### Example Requests

  
```bash
curl "https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=eyJhbGci..."
```
  
  
  
```javascript
const response = await fetch(
  `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${accessToken}`
);

const workOrders = await response.json();
```
  
  
  
```python
response = requests.get(
    f'https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token={access_token}'
)

work_orders = response.json()
```
  

> **Security**: Keep your `client_secret` and `access_token` secure. Never expose them in client-side code or public repositories.

---

## Token Expiration & Refresh

### Token Lifetime

Access tokens expire after **1 hour** (3600 seconds).

### Detecting Expiration

**401 Unauthorized Response:**
```json
{
  "error": "invalid_token",
  "error_description": "The access token expired"
}
```

### Refresh Strategy

When a token expires, request a new one:

```javascript
let accessToken = null;
let tokenExpiry = null;

async function getAccessToken() {
  // Check if token exists and is not expired
  if (accessToken && tokenExpiry && Date.now() < tokenExpiry) {
    return accessToken;
  }
  
  // Request new token
  const response = await fetch(
    'https://api-sandbox.fndev.net/authentication/api/oauth/token',
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        grant_type: 'client_credentials',
        client_id: process.env.CLIENT_ID,
        client_secret: process.env.CLIENT_SECRET,
        scope: 'api'
      })
    }
  );
  
  const data = await response.json();
  accessToken = data.access_token;
  tokenExpiry = Date.now() + (data.expires_in * 1000) - 60000; // Refresh 1 min early
  
  return accessToken;
}

// Use in API calls
async function listWorkOrders() {
  const token = await getAccessToken();
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${token}`
  );
  return response.json();
}
```

---

## Best Practices

### Security

✅ **Store credentials securely**
- Use environment variables
- Never commit to version control
- Use secret management systems (AWS Secrets Manager, HashiCorp Vault)

✅ **Implement token caching**
- Cache tokens until expiry
- Refresh proactively (before expiration)
- Handle concurrent requests gracefully

✅ **Use HTTPS only**
- All API calls must use HTTPS
- Never send tokens over HTTP

---

### Error Handling

Implement robust error handling:

```javascript
async function makeAuthenticatedRequest(url, options = {}) {
  try {
    const token = await getAccessToken();
    const response = await fetch(`${url}?access_token=${token}`, options);
    
    if (response.status === 401) {
      // Token invalid or expired - force refresh
      accessToken = null;
      tokenExpiry = null;
      
      // Retry once with new token
      const newToken = await getAccessToken();
      const retryResponse = await fetch(`${url}?access_token=${newToken}`, options);
      
      if (!retryResponse.ok) {
        throw new Error(`API Error: ${retryResponse.status}`);
      }
      
      return retryResponse.json();
    }
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(`API Error: ${error.error || response.statusText}`);
    }
    
    return response.json();
  } catch (error) {
    console.error('API Request Failed:', error);
    throw error;
  }
}
```

---

### Rate Limiting

Respect rate limits:
- Implement exponential backoff for retries
- Cache responses when appropriate
- Batch requests when possible

```javascript
async function retryWithBackoff(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      // Exponential backoff: 1s, 2s, 4s
      const delay = Math.pow(2, i) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
const workOrders = await retryWithBackoff(() => listWorkOrders());
```

---

## Getting Credentials

### Sandbox Credentials

Contact Field Nation support to request sandbox API credentials:
- **Email**: [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases)
- **Phone**: +1 877-573-4353

Provide:
- Company name
- Use case description
- Expected API usage volume

### Production Credentials

Production API access requires:
1. Active Field Nation buyer contract
2. Completed integration testing in sandbox
3. Approval from Field Nation integration team

Contact support to begin production onboarding process.

---

## Common Authentication Errors

  
    **Cause**: Incorrect `client_id` or `client_secret`
    
    **Solution**:
    - Verify credentials are correct
    - Ensure no extra whitespace
    - Check environment (sandbox vs production)
  
  
  
    **Cause**: Invalid `grant_type` or scope
    
    **Solution**:
    - Use `grant_type: "client_credentials"`
    - Use `scope: "api"`
  
  
  
    **Cause**: Token expired or invalid
    
    **Solution**:
    - Request new access token
    - Check token not corrupted/truncated
  

---

## Testing Authentication

Test your authentication setup:

### Generate Token

Use curl or Postman to request a token

### Verify Token

Check `expires_in` value

### Make Test Request

Call `/api/rest/v2/workorders` with token

### Confirm Success

200 OK response indicates authentication working

---

### undefined
URL: /docs/rest-api/common-patterns

# REST API: undefined
URL: /docs/rest-api/common-patterns
Source: content/docs/rest-api/common-patterns.mdx

---
title: Common Patterns
description: Frequently used workflows and code patterns for the Field Nation REST API.
icon: Workflow
---

Learn common integration patterns and workflows for typical use cases.

## Work Order Lifecycle Management

### Create → Publish → Monitor

Complete workflow for creating and publishing a work order:

```javascript
// 1. Create work order
const createWorkOrder = async () => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${token}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        title: 'Server Rack Installation',
        description: 'Install and configure 42U server rack',
        schedule: {
          service_window: {
            start: '2024-12-20T08:00:00Z',
            end: '2024-12-20T17:00:00Z'
          }
        },
        location: {
          address1: '100 Tech Blvd',
          city: 'Austin',
          state: 'TX',
          zip: '78701',
          country: 'US'
        },
        pay: { base: 300.00 }
      })
    }
  );
  
  const workOrder = await response.json();
  return workOrder.id;
};

// 2. Publish work order
const publishWorkOrder = async (workOrderId) => {
  await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}/publish?access_token=${token}`,
    { method: 'POST' }
  );
};

// 3. Monitor status
const monitorWorkOrder = async (workOrderId) => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}?access_token=${token}`
  );
  
  const workOrder = await response.json();
  console.log(`Status: ${workOrder.status.name}`);
  return workOrder.status.id;
};

// Usage
const workOrderId = await createWorkOrder();
await publishWorkOrder(workOrderId);

// Poll status every 30 seconds
setInterval(() => monitorWorkOrder(workOrderId), 30000);
```

---

## Filtering & Search

### Filter Work Orders by Status

```javascript
// Get all assigned work orders
const getAssignedWorkOrders = async () => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${token}&filter[assignment]=assigned`
  );
  
  return response.json();
};

// Get work orders by date range
const getWorkOrdersByDateRange = async (startDate, endDate) => {
  const params = new URLSearchParams({
    access_token: token,
    'filter[schedule][start]': startDate,
    'filter[schedule][end]': endDate
  });
  
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders?${params}`
  );
  
  return response.json();
};

// Get work orders by location
const getWorkOrdersByZip = async (zipCode, radiusMiles = 25) => {
  const params = new URLSearchParams({
    access_token: token,
    'filter[postal_code]': zipCode,
    'filter[location_radius]': radiusMiles
  });
  
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders?${params}`
  );
  
  return response.json();
};
```

---

### Pagination

Handle large result sets:

```javascript
const getAllWorkOrders = async () => {
  const allWorkOrders = [];
  let page = 1;
  const perPage = 100; // Max items per page
  
  while (true) {
    const response = await fetch(
      `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${token}&page=${page}&per_page=${perPage}`
    );
    
    const data = await response.json();
    
    if (!data.results || data.results.length === 0) {
      break; // No more results
    }
    
    allWorkOrders.push(...data.results);
    
    // Check if there are more pages
    if (data.results.length < perPage) {
      break;
    }
    
    page++;
  }
  
  return allWorkOrders;
};
```

---

## Managing Work Order Components

### Add Messages (Comments)

```javascript
const addMessage = async (workOrderId, message) => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}/messages?access_token=${token}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: message,
        type: 'comment' // or 'instruction'
      })
    }
  );
  
  return response.json();
};

// Usage
await addMessage(12345, 'Please bring ladder and basic tools');
```

---

### Add Custom Fields

```javascript
const updateCustomField = async (workOrderId, customFieldId, value) => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}/custom_fields/${customFieldId}?access_token=${token}`,
    {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ value })
    }
  );
  
  return response.json();
};

// Usage
await updateCustomField(12345, 789, 'Reference Number: ABC-123');
```

---

### Add Tasks (Checklist)

```javascript
const addTask = async (workOrderId, taskData) => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}/tasks?access_token=${token}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        label: taskData.label,
        description: taskData.description,
        required: taskData.required || false
      })
    }
  );
  
  return response.json();
};

// Usage
await addTask(12345, {
  label: 'Power on equipment',
  description: 'Verify all status LEDs are green',
  required: true
});
```

---

### Upload Attachments

```javascript
const uploadAttachment = async (workOrderId, file, folderId = null) => {
  const formData = new FormData();
  formData.append('file', file);
  if (folderId) {
    formData.append('folder_id', folderId);
  }
  
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}/attachments?access_token=${token}`,
    {
      method: 'POST',
      body: formData
    }
  );
  
  return response.json();
};

// Usage (browser)
const fileInput = document.querySelector('input[type="file"]');
const file = fileInput.files[0];
await uploadAttachment(12345, file);
```

---

## Batch Operations

### Create Multiple Work Orders

```javascript
const createBulkWorkOrders = async (workOrders) => {
  const results = [];
  
  // Process in batches to respect rate limits
  const batchSize = 10;
  
  for (let i = 0; i < workOrders.length; i += batchSize) {
    const batch = workOrders.slice(i, i + batchSize);
    
    const promises = batch.map(wo =>
      fetch(
        `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${token}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(wo)
        }
      ).then(r => r.json())
    );
    
    const batchResults = await Promise.all(promises);
    results.push(...batchResults);
    
    // Small delay between batches
    if (i + batchSize < workOrders.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  return results;
};
```

---

## Status Management

### Update Work Order Status

```javascript
const updateWorkOrderStatus = async (workOrderId, action) => {
  // Available actions: publish, approve, complete, etc.
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}/${action}?access_token=${token}`,
    { method: 'POST' }
  );
  
  return response.json();
};

// Usage
await updateWorkOrderStatus(12345, 'publish'); // Draft → Published
await updateWorkOrderStatus(12345, 'approve'); // Work Done → Approved
```

---

### Monitor Multiple Work Orders

```javascript
const monitorWorkOrders = async (workOrderIds) => {
  const statuses = {};
  
  const promises = workOrderIds.map(async (id) => {
    const response = await fetch(
      `https://api-sandbox.fndev.net/api/rest/v2/workorders/${id}?access_token=${token}&columns=status`
    );
    
    const data = await response.json();
    statuses[id] = data.status.name;
  });
  
  await Promise.all(promises);
  return statuses;
};

// Usage
const statuses = await monitorWorkOrders([12345, 12346, 12347]);
console.log(statuses);
// { 12345: 'Assigned', 12346: 'Work Done', 12347: 'Published' }
```

---

## Assignment Management

### Assign to Specific Provider

```javascript
const assignProvider = async (workOrderId, userId) => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}/assignee?access_token=${token}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        user: { id: userId }
      })
    }
  );
  
  return response.json();
};

// Usage
await assignProvider(12345, 67890);
```

---

### Route to Talent Pool

```javascript
const routeToTalentPool = async (workOrderId, talentPoolId) => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}/route?access_token=${token}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        talent_pool_id: talentPoolId
      })
    }
  );
  
  return response.json();
};
```

---

## Using Templates

### Create Work Order from Template

```javascript
const createFromTemplate = async (templateId, overrides = {}) => {
  // First, get template details
  const templateResponse = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/templates/${templateId}?access_token=${token}`
  );
  
  const template = await templateResponse.json();
  
  // Merge template with overrides
  const workOrderData = {
    ...template,
    ...overrides,
    template_id: templateId
  };
  
  // Create work order
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${token}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(workOrderData)
    }
  );
  
  return response.json();
};

// Usage
const workOrder = await createFromTemplate(123, {
  schedule: {
    service_window: {
      start: '2024-12-20T09:00:00Z',
      end: '2024-12-20T17:00:00Z'
    }
  },
  location: {
    address1: '456 Custom St',
    city: 'Dallas',
    state: 'TX',
    zip: '75201'
  }
});
```

---

## Error Handling Patterns

### Retry with Exponential Backoff

```javascript
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      const isLastAttempt = attempt === maxRetries - 1;
      
      // Don't retry on 4xx errors (client errors)
      if (error.status >= 400 && error.status < 500) {
        throw error;
      }
      
      if (isLastAttempt) {
        throw error;
      }
      
      // Exponential backoff: 1s, 2s, 4s, etc.
      const delay = baseDelay * Math.pow(2, attempt);
      console.log(`Retry attempt ${attempt + 1} after ${delay}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
const workOrder = await retryWithBackoff(
  () => fetch(`https://api-sandbox.fndev.net/api/rest/v2/workorders/12345?access_token=${token}`)
    .then(r => r.ok ? r.json() : Promise.reject({ status: r.status }))
);
```

---

## Performance Optimization

### Use Selective Columns

Request only needed fields to reduce payload size:

```javascript
// Get only essential fields
const response = await fetch(
  `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${token}&columns=id,title,status,schedule`
);

// Full work order details only when needed
const fullDetails = await fetch(
  `https://api-sandbox.fndev.net/api/rest/v2/workorders/12345?access_token=${token}`
);
```

---

### Cache Frequently Used Data

```javascript
const cache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

async function getCachedData(key, fetcher) {
  const cached = cache.get(key);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  
  const data = await fetcher();
  cache.set(key, { data, timestamp: Date.now() });
  
  return data;
}

// Usage
const workOrder = await getCachedData(
  `workorder-${workOrderId}`,
  () => fetch(`https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}?access_token=${token}`)
    .then(r => r.json())
);
```

---

### undefined
URL: /docs/rest-api/error-handling

# REST API: undefined
URL: /docs/rest-api/error-handling
Source: content/docs/rest-api/error-handling.mdx

---
title: Error Handling
description: Handle API errors gracefully and implement robust error recovery strategies.
icon: CircleAlert
---

Learn how to handle errors, implement retry logic, and build resilient integrations with the Field Nation REST API.

## HTTP Status Codes

The API uses standard HTTP status codes:

| Code | Meaning | Description |
|------|---------|-------------|
| **2xx** | **Success** | Request succeeded |
| 200 | OK | Request successful, response contains data |
| 201 | Created | Resource created successfully |
| 204 | No Content | Request successful, no response body |
| **4xx** | **Client Errors** | Problem with request |
| 400 | Bad Request | Invalid request parameters or payload |
| 401 | Unauthorized | Invalid or expired access token |
| 403 | Forbidden | Insufficient permissions |
| 404 | Not Found | Resource doesn't exist |
| 422 | Unprocessable Entity | Validation error |
| 429 | Too Many Requests | Rate limit exceeded |
| **5xx** | **Server Errors** | Problem on Field Nation's side |
| 500 | Internal Server Error | Unexpected server error |
| 502 | Bad Gateway | Temporary server issue |
| 503 | Service Unavailable | Server temporarily unavailable |

---

## Error Response Format

All API errors return JSON with consistent structure:

```json
{
  "error": {
    "code": "ValidationError",
    "message": "Missing required field: title",
    "details": {
      "field": "title",
      "constraint": "required"
    }
  }
}
```

---

## Common Error Codes

### Authentication Errors (401)

  
    **Cause**: Access token expired or invalid
    
    **Response:**
    ```json
    {
      "error": "invalid_token",
      "error_description": "The access token expired"
    }
    ```
    
    **Solution:**
    - Request new access token
    - Implement automatic token refresh
  
  
  
    **Cause**: Invalid client credentials
    
    **Response:**
    ```json
    {
      "error": "invalid_client",
      "error_description": "Client authentication failed"
    }
    ```
    
    **Solution:**
    - Verify `client_id` and `client_secret` are correct
    - Check environment (sandbox vs production)
  

---

### Validation Errors (400/422)

  
    **Response:**
    ```json
    {
      "error": {
        "code": "ValidationError",
        "message": "Missing required field: schedule.service_window.start",
        "field": "schedule.service_window.start"
      }
    }
    ```
    
    **Solution:**
    - Check API documentation for required fields
    - Validate payload before sending
  
  
  
    **Response:**
    ```json
    {
      "error": {
        "code": "ValidationError",
        "message": "Invalid date format for schedule.service_window.start",
        "field": "schedule.service_window.start",
        "expected": "ISO 8601 format (YYYY-MM-DDTHH:mm:ssZ)"
      }
    }
    ```
    
    **Solution:**
    - Use ISO 8601 date format
    - Validate data types match expected values
  

---

### Resource Errors (404)

```json
{
  "error": {
    "code": "NotFound",
    "message": "Work order with ID 99999 not found"
  }
}
```

**Common Causes:**
- Invalid work order ID
- Resource was deleted
- No access to resource (permissions)

---

### Rate Limiting (429)

```json
{
  "error": {
    "code": "RateLimitExceeded",
    "message": "Too many requests. Please retry after 60 seconds.",
    "retry_after": 60
  }
}
```

**Solution:** Implement exponential backoff and respect `Retry-After` header

---

## Error Handling Strategies

### Comprehensive Error Handler

```javascript
class APIError extends Error {
  constructor(status, code, message, details) {
    super(message);
    this.status = status;
    this.code = code;
    this.details = details;
    this.name = 'APIError';
  }
}

async function handleAPIResponse(response) {
  if (response.ok) {
    return response.json();
  }
  
  let error;
  try {
    error = await response.json();
  } catch {
    // Response body not JSON
    error = { message: response.statusText };
  }
  
  throw new APIError(
    response.status,
    error.error?.code || error.error || 'UnknownError',
    error.error?.message || error.error_description || error.message || 'An error occurred',
    error.error?.details
  );
}

// Usage
try {
  const response = await fetch(url, options);
  const data = await handleAPIResponse(response);
  return data;
} catch (error) {
  if (error instanceof APIError) {
    console.error(`API Error [${error.code}]:`, error.message);
    
    // Handle specific error types
    if (error.status === 401) {
      // Refresh token and retry
    } else if (error.status === 429) {
      // Rate limited - back off
    } else if (error.status >= 500) {
      // Server error - retry with backoff
    }
  } else {
    console.error('Network Error:', error);
  }
  
  throw error;
}
```

---

### Retry Logic with Exponential Backoff

```javascript
async function retryWithBackoff(fn, options = {}) {
  const {
    maxRetries = 3,
    baseDelay = 1000,
    maxDelay = 30000,
    retryableStatuses = [408, 429, 500, 502, 503, 504]
  } = options;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      const isLastAttempt = attempt === maxRetries - 1;
      const isRetryable = error instanceof APIError && 
                          retryableStatuses.includes(error.status);
      
      if (isLastAttempt || !isRetryable) {
        throw error;
      }
      
      // Calculate delay with exponential backoff and jitter
      const exponentialDelay = baseDelay * Math.pow(2, attempt);
      const jitter = Math.random() * 1000;
      const delay = Math.min(exponentialDelay + jitter, maxDelay);
      
      // Respect Retry-After header if present
      const retryAfter = error.details?.retry_after;
      const finalDelay = retryAfter ? retryAfter * 1000 : delay;
      
      console.log(`Retry attempt ${attempt + 1}/${maxRetries} after ${finalDelay}ms`);
      await new Promise(resolve => setTimeout(resolve, finalDelay));
    }
  }
}

// Usage
const workOrder = await retryWithBackoff(async () => {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/rest/v2/workorders/12345?access_token=${token}`
  );
  return handleAPIResponse(response);
});
```

---

### Token Refresh on 401

```javascript
let accessToken = null;
let tokenExpiry = null;
let refreshPromise = null;

async function getValidToken() {
  // Check if token is still valid
  if (accessToken && tokenExpiry && Date.now() < tokenExpiry) {
    return accessToken;
  }
  
  // If refresh already in progress, wait for it
  if (refreshPromise) {
    return refreshPromise;
  }
  
  // Start token refresh
  refreshPromise = (async () => {
    try {
      const response = await fetch(
        'https://api-sandbox.fndev.net/authentication/api/oauth/token',
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            grant_type: 'client_credentials',
            client_id: process.env.CLIENT_ID,
            client_secret: process.env.CLIENT_SECRET,
            scope: 'api'
          })
        }
      );
      
      const data = await response.json();
      accessToken = data.access_token;
      tokenExpiry = Date.now() + (data.expires_in * 1000) - 60000; // Refresh 1 min early
      
      return accessToken;
    } finally {
      refreshPromise = null;
    }
  })();
  
  return refreshPromise;
}

async function makeAuthenticatedRequest(url, options = {}) {
  const token = await getValidToken();
  const urlWithToken = `${url}?access_token=${token}`;
  
  try {
    const response = await fetch(urlWithToken, options);
    return await handleAPIResponse(response);
  } catch (error) {
    // If 401, force token refresh and retry once
    if (error instanceof APIError && error.status === 401) {
      accessToken = null;
      tokenExpiry = null;
      
      const newToken = await getValidToken();
      const retryUrl = `${url}?access_token=${newToken}`;
      const retryResponse = await fetch(retryUrl, options);
      return await handleAPIResponse(retryResponse);
    }
    
    throw error;
  }
}
```

---

### Circuit Breaker Pattern

Prevent cascading failures:

```javascript
class CircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.resetTimeout = options.resetTimeout || 60000; // 1 minute
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.nextAttempt = null;
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.resetTimeout;
      console.warn(`Circuit breaker OPEN. Will retry after ${this.resetTimeout}ms`);
    }
  }
}

// Usage
const breaker = new CircuitBreaker({
  failureThreshold: 5,
  resetTimeout: 60000
});

async function getWorkOrder(workOrderId) {
  return breaker.execute(async () => {
    const response = await fetch(
      `https://api-sandbox.fndev.net/api/rest/v2/workorders/${workOrderId}?access_token=${token}`
    );
    return handleAPIResponse(response);
  });
}
```

---

## Validation Before API Calls

Validate data before sending to avoid 400 errors:

```javascript
function validateWorkOrder(workOrder) {
  const errors = [];
  
  // Required fields
  if (!workOrder.title) {
    errors.push('title is required');
  }
  
  if (!workOrder.schedule?.service_window?.start) {
    errors.push('schedule.service_window.start is required');
  }
  
  if (!workOrder.schedule?.service_window?.end) {
    errors.push('schedule.service_window.end is required');
  }
  
  if (!workOrder.location?.address1) {
    errors.push('location.address1 is required');
  }
  
  if (!workOrder.location?.city) {
    errors.push('location.city is required');
  }
  
  // Date validation
  if (workOrder.schedule?.service_window) {
    const start = new Date(workOrder.schedule.service_window.start);
    const end = new Date(workOrder.schedule.service_window.end);
    
    if (start >= end) {
      errors.push('service_window.start must be before service_window.end');
    }
    
    if (start < new Date()) {
      errors.push('service_window.start cannot be in the past');
    }
  }
  
  // Pay validation
  if (workOrder.pay?.base && workOrder.pay.base < 0) {
    errors.push('pay.base must be positive');
  }
  
  if (errors.length > 0) {
    throw new Error(`Validation failed: ${errors.join(', ')}`);
  }
}

// Usage
try {
  validateWorkOrder(workOrderData);
  const response = await createWorkOrder(workOrderData);
} catch (error) {
  console.error('Validation Error:', error.message);
}
```

---

## Logging & Monitoring

Implement comprehensive logging:

```javascript
class APILogger {
  static log(level, message, metadata = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...metadata
    };
    
    // Send to logging service (e.g., CloudWatch, Datadog)
    console.log(JSON.stringify(logEntry));
  }
  
  static request(method, url, options = {}) {
    this.log('info', 'API Request', {
      method,
      url: url.replace(/access_token=[^&]+/, 'access_token=REDACTED'),
      headers: options.headers,
      body: options.body ? JSON.parse(options.body) : null
    });
  }
  
  static response(url, status, data) {
    this.log('info', 'API Response', {
      url: url.replace(/access_token=[^&]+/, 'access_token=REDACTED'),
      status,
      dataSize: JSON.stringify(data).length
    });
  }
  
  static error(error, context = {}) {
    this.log('error', 'API Error', {
      error: error.message,
      code: error.code,
      status: error.status,
      stack: error.stack,
      ...context
    });
  }
}

// Usage
async function apiCall(url, options) {
  APILogger.request(options.method || 'GET', url, options);
  
  try {
    const response = await fetch(url, options);
    const data = await handleAPIResponse(response);
    
    APILogger.response(url, response.status, data);
    return data;
  } catch (error) {
    APILogger.error(error, { url, options });
    throw error;
  }
}
```

---

## Best Practices Summary

### Error Handling Checklist

- ☐ Implement comprehensive error handling for all API calls
- ☐ Use retry logic with exponential backoff for transient errors
- ☐ Implement token refresh on 401 errors
- ☐ Validate data before API calls to prevent 400 errors
- ☐ Log all API requests and errors for debugging
- ☐ Monitor error rates and set up alerts
- ☐ Implement circuit breaker for cascading failure prevention
- ☐ Handle rate limiting (429) gracefully
- ☐ Provide user-friendly error messages
- ☐ Test error scenarios in development

### When to Retry

**✅ Retry these errors:**
- 408 Request Timeout
- 429 Too Many Requests
- 500 Internal Server Error
- 502 Bad Gateway
- 503 Service Unavailable
- 504 Gateway Timeout
- Network errors (ECONNRESET, ETIMEDOUT)

**❌ Don't retry these errors:**
- 400 Bad Request (fix payload)
- 401 Unauthorized (refresh token)
- 403 Forbidden (check permissions)
- 404 Not Found (resource doesn't exist)
- 422 Unprocessable Entity (fix validation)

---

## Production Monitoring

Set up monitoring for:

- **Error Rate**: Track 4xx and 5xx errors
- **Latency**: Monitor API response times
- **Token Refresh**: Track authentication failures
- **Rate Limits**: Monitor 429 responses
- **Circuit Breaker**: Track open/closed state

**Tools**: CloudWatch, Datadog, New Relic, Sentry

---

### undefined
URL: /docs/rest-api/introduction

# REST API: undefined
URL: /docs/rest-api/introduction
Source: content/docs/rest-api/introduction.mdx

---
title: Introduction
description: Overview of the Field Nation REST API v2 for programmatic access to field service management operations.
icon: CodeXml
---

The Field Nation REST API v2 provides comprehensive programmatic access to the Field Nation platform for managing all aspects of field service operations.

## What is the REST API?

The REST API enables you to:
- **Create and manage work orders** programmatically
- **Integrate** Field Nation with your existing systems
- **Automate** field service workflows
- **Access** real-time data about work orders, providers, and operations
- **Build custom applications** on top of Field Nation

---

## API Overview

### Base URLs

  
    ```
    https://api-sandbox.fndev.net
    ```
    
    Use sandbox for testing and development. All features available without affecting production data.
  
  
  
    ```
    https://api.fieldnation.com
    ```
    
    Contact Field Nation support for production API access credentials.
  

---

### API Version

**Current Version:** REST API v2.0

The v2 API provides:
- ✅ Comprehensive resource management
- ✅ Advanced filtering and pagination
- ✅ Rich resource relationships
- ✅ Extensive customization options

---

## Available Resources

The REST API provides access to the following resources:

  
    **Core Operations:**
    - List, create, read, update, delete work orders
    - Publish, approve, route, assign work orders
    - Manage work order lifecycle (draft → published → assigned → completed → paid)
    
    **Related Data:**
    - Schedule, location, pay, status
    - Messages, attachments, signatures
    - Time logs, expenses, bonuses, penalties
    - Tasks, qualifications, contacts, custom fields
  
  
  
    OAuth 2.0 token generation and management for secure API access.
  
  
  
    Reusable work order templates for common job types.
  
  
  
    - Company settings and configuration
    - Tags, expense types, networks
    - Managers, revisit reasons
  
  
  
    - **Talent Pools**: Groups of providers with tiers and attributes
    - **Talent Pool Groups**: Collections of talent pools with associated providers
    - **Preferred Providers** (legacy): Direct provider relationships
  
  
  
    - **Projects**: Project organization and settings
    - **Clients**: Client company management
    - **Locations**: Saved locations and location groups
  
  
  
    - **Types of Work**: Service categories
    - **Custom Fields**: Custom field definitions
    - **Bonuses & Penalties**: Compensation adjustments
  

---

## Core Capabilities

### Work Order Management

The API provides complete work order lifecycle management:

```mermaid
graph LR
    A[Create] --> B[Publish]
    B --> C[Route/Assign]
    C --> D[Execute]
    D --> E[Complete]
    E --> F[Approve & Pay]
```

**Capabilities:**
- Create work orders with schedules, locations, and requirements
- Publish to marketplace or route to specific providers
- Manage assignments and confirmations
- Track progress with time logs and status updates
- Process completion, approval, and payment

---

### Advanced Filtering & Pagination

List endpoints support extensive filtering:

**Work Order Filters:**
- Status, dates (created, published, scheduled, completed)
- Location (city, state, zip, radius, saved locations)
- Pay range, hourly vs. fixed
- Templates, types of work, custom fields
- Assigned providers, networks, managers
- Projects, clients, tags

**Pagination:**
- `page` - Page number (default: 1)
- `per_page` - Items per page (default: 30)
- `columns` - Control which fields are returned
- `sort` & `order` - Sort results

---

### Resource Relationships

The API provides rich relationships between resources:

```
Work Order
├── Location (address, coordinates, timezone)
├── Schedule (service window, ETA)
├── Pay (base, increases, discounts, bonuses, penalties)
├── Assignee (provider information)
├── Messages (communication thread)
├── Attachments (files, photos)
├── Tasks (checklist items with alerts)
├── Time Logs (clock in/out records)
├── Expenses (reimbursable costs)
├── Contacts (on-site contacts)
├── Qualifications (required certifications)
├── Custom Fields (company-specific data)
└── Signatures (completion signatures)
```

---

## Authentication

All API requests require OAuth 2.0 authentication:

1. **Obtain Token**: Call `/authentication/api/oauth/token` with client credentials
2. **Use Token**: Include as query parameter `?access_token=YOUR_TOKEN` in all requests
3. **Refresh**: Token expires after a period - obtain new token as needed

[Authentication guide →](/docs/rest-api/authentication)

---

## Response Format

All API responses are JSON with consistent structure:

**Successful Response:**
```json
{
  "id": 12345,
  "title": "Network Equipment Installation",
  "status": {
    "id": 2,
    "name": "Assigned"
  },
  // ... other fields
}
```

**Error Response:**
```json
{
  "error": {
    "code": "InvalidRequest",
    "message": "Missing required field: title"
  }
}
```

---

## Rate Limits

- **Default**: Reasonable use limits apply
- **Monitoring**: Track your usage to avoid throttling
- **Best Practice**: Implement exponential backoff for retries

Contact Field Nation support for higher rate limits if needed.

---

## Data Formats

### Dates & Times

- **Format**: ISO 8601 (`YYYY-MM-DDTHH:mm:ssZ`)
- **Timezone**: UTC or specific timezone with offset
- **Example**: `2024-12-07T14:30:00Z`

### Money

- **Format**: Decimal number
- **Currency**: USD (unless specified)
- **Example**: `150.00` ($150.00)

### IDs

- **Format**: Integer
- **Example**: `work_order_id: 12345`

---

## Versioning

- **Current**: v2.0
- **Stability**: Production-ready, stable API
- **Breaking Changes**: Major version updates only
- **Deprecation**: Advance notice provided for deprecated features

---

## Getting Help

  
    Create your first work order in 5 minutes
  
  
    OAuth 2.0 setup and token management
  
  
    Frequently used workflows and examples
  
  
    Get help from Field Nation support

---

### undefined
URL: /docs/rest-api/quickstart

# REST API: undefined
URL: /docs/rest-api/quickstart
Source: content/docs/rest-api/quickstart.mdx

---
title: Quickstart
description: Create your first work order using the Field Nation REST API in under 5 minutes.
icon: Rocket
---

This quickstart guide will walk you through creating your first work order using the REST API.

## Prerequisites

Before you begin, ensure you have:

- ☐ Field Nation buyer account (Sandbox or Production)
- ☐ API credentials (Client ID and Client Secret)
- ☐ HTTP client (curl, Postman, or programming language HTTP library)

[Get prerequisites →](/docs/getting-started/prerequisites)

---

## Step 1: Obtain Access Token

First, authenticate to get an access token:

  
```bash
curl -X POST "https://api-sandbox.fndev.net/authentication/api/oauth/token" \
  -H "Content-Type: application/json" \
  -d '{
    "grant_type": "client_credentials",
    "client_id": "YOUR_CLIENT_ID",
    "client_secret": "YOUR_CLIENT_SECRET",
    "scope": "api"
  }'
```
  
  
  
```javascript
const response = await fetch(
  'https://api-sandbox.fndev.net/authentication/api/oauth/token',
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      grant_type: 'client_credentials',
      client_id: 'YOUR_CLIENT_ID',
      client_secret: 'YOUR_CLIENT_SECRET',
      scope: 'api'
    })
  }
);

const { access_token } = await response.json();
console.log('Access Token:', access_token);
```
  
  
  
```python
import requests

response = requests.post(
    'https://api-sandbox.fndev.net/authentication/api/oauth/token',
    json={
        'grant_type': 'client_credentials',
        'client_id': 'YOUR_CLIENT_ID',
        'client_secret': 'YOUR_CLIENT_SECRET',
        'scope': 'api'
    }
)

access_token = response.json()['access_token']
print(f'Access Token: {access_token}')
```
  

**Response:**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

> [INFO] **Save the `access_token`** - You'll use it in subsequent requests. Tokens typically expire after 1 hour.

---

## Step 2: Create a Simple Work Order

Now create a work order with minimal required fields:

  
```bash
curl -X POST "https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Network Equipment Installation",
    "description": "Install and configure network switch at customer site",
    "schedule": {
      "service_window": {
        "start": "2024-12-15T09:00:00Z",
        "end": "2024-12-15T17:00:00Z"
      }
    },
    "location": {
      "address1": "123 Main St",
      "city": "San Francisco",
      "state": "CA",
      "zip": "94102",
      "country": "US"
    },
    "pay": {
      "base": 150.00
    }
  }'
```
  
  
  
```javascript
const workOrder = await fetch(
  `https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token=${accessToken}`,
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      title: 'Network Equipment Installation',
      description: 'Install and configure network switch at customer site',
      schedule: {
        service_window: {
          start: '2024-12-15T09:00:00Z',
          end: '2024-12-15T17:00:00Z'
        }
      },
      location: {
        address1: '123 Main St',
        city: 'San Francisco',
        state: 'CA',
        zip: '94102',
        country: 'US'
      },
      pay: {
        base: 150.00
      }
    })
  }
);

const workOrderData = await workOrder.json();
console.log('Work Order Created:', workOrderData.id);
```
  
  
  
```python
work_order = requests.post(
    f'https://api-sandbox.fndev.net/api/rest/v2/workorders?access_token={access_token}',
    json={
        'title': 'Network Equipment Installation',
        'description': 'Install and configure network switch at customer site',
        'schedule': {
            'service_window': {
                'start': '2024-12-15T09:00:00Z',
                'end': '2024-12-15T17:00:00Z'
            }
        },
        'location': {
            'address1': '123 Main St',
            'city': 'San Francisco',
            'state': 'CA',
            'zip': '94102',
            'country': 'US'
        },
        'pay': {
            'base': 150.00
        }
    }
)

work_order_data = work_order.json()
print(f"Work Order Created: {work_order_data['id']}")
```
  

**Response:**
```json
{
  "id": 12345,
  "title": "Network Equipment Installation",
  "description": "Install and configure network switch at customer site",
  "status": {
    "id": 0,
    "name": "Draft"
  },
  "schedule": {
    "service_window": {
      "start": "2024-12-15T09:00:00Z",
      "end": "2024-12-15T17:00:00Z"
    }
  },
  "location": {
    "address1": "123 Main St",
    "city": "San Francisco",
    "state": "CA",
    "zip": "94102",
    "country": "US"
  },
  "pay": {
    "base": 150.00
  },
  "created": "2024-12-07T10:30:00Z",
  // ... other fields
}
```

> [INFO] **Work Order Created!** The work order is in "Draft" status. Save the `id` (12345 in this example) for next steps.

---

## Step 3: Publish the Work Order

Publish the work order to make it available to providers:

  
```bash
curl -X POST "https://api-sandbox.fndev.net/api/rest/v2/workorders/12345/publish?access_token=YOUR_ACCESS_TOKEN"
```
  
  
  
```javascript
const publish = await fetch(
  `https://api-sandbox.fndev.net/api/rest/v2/workorders/12345/publish?access_token=${accessToken}`,
  { method: 'POST' }
);

console.log('Work Order Published!');
```
  
  
  
```python
publish = requests.post(
    f'https://api-sandbox.fndev.net/api/rest/v2/workorders/12345/publish?access_token={access_token}'
)

print('Work Order Published!')
```
  

**Response:**
```json
{
  "id": 12345,
  "status": {
    "id": 1,
    "name": "Published"
  },
  "published": "2024-12-07T10:35:00Z",
  // ... other fields
}
```

---

## Step 4: Retrieve Work Order Details

Check the work order status:

  
```bash
curl "https://api-sandbox.fndev.net/api/rest/v2/workorders/12345?access_token=YOUR_ACCESS_TOKEN"
```
  
  
  
```javascript
const details = await fetch(
  `https://api-sandbox.fndev.net/api/rest/v2/workorders/12345?access_token=${accessToken}`
);

const workOrderDetails = await details.json();
console.log('Status:', workOrderDetails.status.name);
```
  
  
  
```python
details = requests.get(
    f'https://api-sandbox.fndev.net/api/rest/v2/workorders/12345?access_token={access_token}'
)

work_order_details = details.json()
print(f"Status: {work_order_details['status']['name']}")
```
  

---

## 🎉 Congratulations!

You've successfully:
- ✅ Obtained an access token
- ✅ Created a work order
- ✅ Published it to the marketplace
- ✅ Retrieved work order details

---

## Common Enhancements

### Add More Details

Enhance your work order with:

**Type of Work:**
```json
{
  "type_of_work": {
    "id": 123,
    "name": "Network Installation"
  }
}
```

**Contact Information:**
```json
{
  "contacts": [{
    "name": "John Doe",
    "phone": "+1-555-0123",
    "email": "john@example.com"
  }]
}
```

**Custom Fields:**
```json
{
  "custom_fields": [{
    "id": 456,
    "value": "Switch Model: Cisco 2960"
  }]
}
```

**Tasks/Checklist:**
```json
{
  "tasks": [{
    "label": "Power on equipment",
    "description": "Verify all LEDs are green"
  }]
}
```

---

## Error Handling

Handle common errors gracefully:

```javascript
try {
  const response = await fetch(url, options);
  
  if (!response.ok) {
    const error = await response.json();
    console.error('API Error:', error.message);
    
    if (response.status === 401) {
      // Token expired - refresh token
    } else if (response.status === 400) {
      // Invalid request - check payload
    }
  }
  
  return await response.json();
} catch (error) {
  console.error('Network Error:', error);
}
```

---

## Production Checklist

Before going to production:

- ☐ Switch to production API URL
- ☐ Use production credentials
- ☐ Implement token refresh logic
- ☐ Add proper error handling
- ☐ Implement retry logic with exponential backoff
- ☐ Log API requests for debugging
- ☐ Monitor API usage and rate limits
- ☐ Test with various work order scenarios

---

---

## Webhooks (21)

### undefined
URL: /docs/webhooks/api-playground

# Webhooks: undefined
URL: /docs/webhooks/api-playground
Source: content/docs/webhooks/api-playground.mdx

---
title: API Playground
description: Jump to the Webhooks v3 playground to explore requests and responses.
icon: SatelliteDish
---

Visit the Webhooks v3 playground to test payloads, signatures, and responses:

  Open Webhooks Playground

---

### undefined
URL: /docs/webhooks/introduction

# Webhooks: undefined
URL: /docs/webhooks/introduction
Source: content/docs/webhooks/introduction.mdx

---
title: Introduction
description: Real-time event notifications from Field Nation to your system. Build reactive integrations that respond instantly to work order changes.
icon: Webhook
---

## What Are Webhooks?

Webhooks are **server-to-server HTTP callbacks** that notify your system when specific events happen in Field Nation. Think of them as "reverse API calls" – instead of your system asking Field Nation for updates, Field Nation pushes updates to you.

```mermaid
sequenceDiagram
    participant FN as Field Nation
    participant Your as Your System
    
    Note over FN: Work Order Published
    FN->>Your: POST https://your-endpoint.com/webhooks
    Note over Your: Process Event
    Your-->>FN: 200 OK
    Note over Your: Update Local Records
```

### How They Work

1. **Subscribe** - Register your HTTPS endpoint and select events to receive
2. **Event Occurs** - A work order is created, updated, or status changes
3. **Notification Sent** - Field Nation POSTs event payload to your endpoint
4. **Process & Respond** - Your system processes the event and returns 200 OK
5. **Automatic Retry** - If delivery fails, Field Nation retries with exponential backoff

---

## Why Use Webhooks?

  
    Receive updates within seconds of events occurring. Keep your systems in sync without polling delays.
  
  
    Eliminate constant polling. Webhooks push data only when something changes, reducing API calls by 95%+.
  
  
    Build reactive workflows that trigger automatically. Assign providers, update ERP systems, send notifications—all in real-time.
  
  
    Lower infrastructure costs. No need to run continuous polling jobs or maintain complex scheduling logic.
  

---

## Common Use Cases

### 1. **Work Order Lifecycle Automation**

Automatically respond to work order status changes:

- **Published** → Auto-assign to preferred provider
- **Assigned** → Update dispatch board, notify technician
- **Checked In** → Log start time in ERP system
- **Work Done** → Trigger approval workflow
- **Approved** → Generate invoice, update accounting system

### 2. **Real-Time Notifications**

Keep stakeholders informed instantly:

- Notify clients when work orders are completed
- Alert managers when providers decline assignments
- Send SMS/email when work is approved
- Update dashboards in real-time

### 3. **Data Synchronization**

Maintain consistent data across systems:

- Sync work order details to Salesforce, ServiceNow, or NetSuite
- Update custom dashboards and reporting tools
- Mirror Field Nation data in your database
- Replicate changes to multiple downstream systems

### 4. **Compliance & Auditing**

Track every change for regulatory requirements:

- Log all status transitions with timestamps
- Record who approved, declined, or modified work orders
- Maintain audit trails for compliance reporting
- Alert on specific event patterns

---

## When to Use Webhooks vs REST API

| Scenario | Use Webhooks | Use REST API |
|----------|-------------|--------------|
| **Real-time updates** | ✅ Ideal | ❌ Requires polling |
| **Event-driven workflows** | ✅ Perfect fit | ⚠️ Complex to implement |
| **Creating work orders** | ❌ Not supported | ✅ Use POST requests |
| **Bulk data queries** | ❌ Not designed for this | ✅ Use GET endpoints |
| **On-demand data retrieval** | ❌ Event-based only | ✅ Query anytime |
| **Reducing API calls** | ✅ Push notifications | ❌ Constant polling |

> [INFO] **Best Practice**: Use webhooks for event-driven updates and REST API for on-demand queries and write operations. Most integrations use both together.

---

## Available Events

Field Nation Webhooks support **33 distinct events** covering the complete work order lifecycle:

### Event Categories

  
    - **workorder.created** - New work order created
    - **workorder.routed** - Routed to specific provider(s)
    - **workorder.requested** - Provider requested assignment
    - **workorder.declined** - Provider declined assignment
    - **workorder.undeclined** - Decline reversed
  
  
    - **workorder.status.published** - Work order published to marketplace
    - **workorder.status.assigned** - Provider assigned to work order
    - **workorder.status.on_my_way** - Provider en route
    - **workorder.status.checked_in** - Provider arrived on site
    - **workorder.status.work_done** - Work completed
    - **workorder.status.approved** - Work approved by buyer
    - And 14 more status changes...
  
  
    - **workorder.message_posted** - New message or reply
    - **workorder.provider_upload** - Document uploaded
    - **workorder.task_completed** - Task marked complete
    - **workorder.schedule_updated** - Schedule changed
    - **workorder.tag_added** / **tag_removed** - Tags modified
  

[View complete event catalog →](/docs/webhooks/concepts/events)

---

## Key Features

### 🔒 **Secure Delivery**

- **HMAC-SHA256 signatures** - Verify webhook authenticity
- **Custom headers** - Pass authentication tokens
- **IP whitelisting** - Restrict to Field Nation IPs
- **HTTPS required** - Encrypted transmission

[Learn about security →](/docs/webhooks/guides/security)

### 🔁 **Automatic Retries**

- **Exponential backoff** - 10s, 20s, 40s, 80s, 160s, 320s, 640s
- **Up to 7 attempts** - Based on delivery success rate
- **Manual retry** - Reprocess failed deliveries via API
- **Dead letter queue** - Access failed events for debugging

[Understanding delivery →](/docs/webhooks/concepts/delivery)

### 📊 **Comprehensive Monitoring**

- **Delivery logs** - Every attempt recorded
- **Pre-signed log URLs** - Access complete request/response
- **Filtering & search** - Find deliveries by event, status, work order
- **Change history** - Audit trail of webhook modifications

[Monitoring webhooks →](/docs/webhooks/guides/monitoring)

### 🛠️ **Flexible Management**

- **Web UI** - Visual webhook configuration dashboard
- **REST API** - Programmatic webhook management
- **Multiple webhooks** - Different endpoints per event type
- **Status control** - Active, inactive, or archived

[Creating webhooks →](/docs/webhooks/guides/creating-webhooks)

---

## Prerequisites

Before working with webhooks, ensure you have:

### Field Nation Account Access

- **Buyer account** with active contract
- **API credentials** (client_id and client_secret)
- **Webhook access** enabled (contact support if needed)

### Technical Requirements

- **HTTPS endpoint** - Publicly accessible URL
- **Response within 5 seconds** - Acknowledge deliveries quickly
- **2xx status code** - Indicate successful receipt

### Development Tools (Optional)

- **ngrok** or **localtunnel** - For local testing
- **Request inspection tools** - webhook.site, request.bin
- **Monitoring setup** - Logs, alerts, dashboards

[Complete prerequisites guide →](/docs/getting-started/prerequisites)

---

## Getting Started

Ready to receive your first webhook?

  
    Create your first webhook and receive events in under 15 minutes
  
  
    Understand events, payloads, and delivery mechanics
  
  
    Verify signatures and secure your webhook endpoint
  
  
    Complete API documentation for programmatic management
  

---

## Need Help?

> [INFO] **Support Resources**

- **Technical Issues**: [Submit a support case](https://app.fieldnation.com/support-cases)
- **Email**: integrations-engineering@fieldnation.com
- **API Playground**: [Swagger UI (Sandbox)](https://ui-sandbox.fndev.net/integrations/webhooks/_api)

---

---

### undefined
URL: /docs/webhooks/migration

# Webhooks: undefined
URL: /docs/webhooks/migration
Source: content/docs/webhooks/migration.mdx

---
title: Migration Guide
description: Migrate from legacy webhook implementations to Webhooks v3 with updated event names, improved delivery mechanics, and enhanced features.
icon: ArrowRight
---

## What's New in v3

### Enhanced Delivery System

- **Redis-based message queuing**: Reliable delivery with automatic retries
- **Exponential backoff**: Intelligent retry strategy (10s, 20s, 40s, 80s...)
- **Dynamic retry count**: Adjusts based on webhook success rate
- **Dead letter queue**: Manual retry for permanently failed deliveries

### Improved Event System

- **33 webhook events**: Expanded from 15 events in v2
- **Consistent naming**: All events follow `model.action` or `model.status.value` pattern
- **Better payload structure**: Standardized event data format

### Security Enhancements

- **HMAC-SHA256 signatures**: Cryptographically secure webhook verification
- **IP whitelisting**: Restrict access to Field Nation IPs
- **Custom headers**: Add authentication tokens to webhook requests

### API Improvements

- **Comprehensive delivery logs**: Full request/response details for debugging
- **Webhook history**: Complete audit trail of all configuration changes
- **Manual retry**: Programmatically retry failed deliveries

---

## Breaking Changes

### Event Name Changes

Many event names have changed in v3:

| v2 Event Name | v3 Event Name | Notes |
|---------------|---------------|-------|
| `work_order.created` | `workorder.created` | Removed underscore |
| `work_order.published` | `workorder.status.published` | Now a status change event |
| `work_order.assigned` | `workorder.status.assigned` | Now a status change event |
| `work_order.completed` | `workorder.status.work_done` | Renamed to match platform terminology |
| `work_order.approved` | `workorder.status.approved` | Now a status change event |

> **Action Required**: Update your webhook event subscriptions to use new v3 event names.

### Payload Structure

v3 introduces a consistent payload structure:

**v2 Payload (inconsistent):**

```json
{
  "id": "evt_123",
  "event": "work_order.published",
  "work_order_id": 12345,
  "created_at": "2025-01-15T10:00:00Z",
  "work_order": {
    // work order data
  }
}
```

**v3 Payload (standardized):**

```json
{
  "eventId": "evt_abc123",
  "eventName": "workorder.status.published",
  "workOrderId": 12345,
  "timestamp": "2025-01-15T10:00:00Z",
  "data": {
    "id": 12345,
    "status": "published",
    // complete work order data
  }
}
```

**Key Changes:**
- `id` → `eventId`
- `event` → `eventName`
- `work_order_id` → `workOrderId`
- `created_at` → `timestamp`
- `work_order` → `data`
- Field names use camelCase instead of snake_case

### Signature Verification

v3 uses HMAC-SHA256 instead of basic auth:

**v2 (Basic Auth):**

```javascript
// Authorization: Basic base64(username:password)
const auth = req.headers.authorization;
const [username, password] = Buffer.from(auth.split(' ')[1], 'base64')
  .toString()
  .split(':');
```

**v3 (HMAC-SHA256):**

```javascript
// x-fn-signature: sha256=abc123...
const signature = req.headers['x-fn-signature'];
const [algorithm, hash] = signature.split('=');

const expectedHash = crypto
  .createHmac(algorithm, secret)
  .update(rawBody)
  .digest('hex');

const valid = crypto.timingSafeEqual(
  Buffer.from(expectedHash),
  Buffer.from(hash)
);
```

[Complete security guide →](/docs/webhooks/guides/security)

---

## Migration Steps

### Audit Current Webhook Usage

Document your current webhooks:

```javascript
// List all v2 webhooks
const v2Webhooks = await fetch('https://api.fieldnation.com/v2/webhooks', {
  headers: { 'Authorization': 'Bearer YOUR_TOKEN' }
});

// Document subscribed events
const webhooks = await v2Webhooks.json();
webhooks.forEach(webhook => {
  console.log(`Webhook ${webhook.id}:`);
  console.log(`  URL: ${webhook.url}`);
  console.log(`  Events: ${webhook.events.join(', ')}`);
});
```

### Map v2 Events to v3

Create event mapping:

```javascript
const eventMapping = {
  'work_order.created': 'workorder.created',
  'work_order.published': 'workorder.status.published',
  'work_order.assigned': 'workorder.status.assigned',
  'work_order.completed': 'workorder.status.work_done',
  'work_order.approved': 'workorder.status.approved',
  'work_order.paid': 'workorder.status.paid',
  'work_order.cancelled': 'workorder.status.cancelled',
  // ... map all your events
};

function migrateEvents(v2Events) {
  return v2Events.map(event => {
    if (eventMapping[event]) {
      return eventMapping[event];
    }
    console.warn(`No v3 mapping for event: ${event}`);
    return null;
  }).filter(Boolean);
}
```

### Update Webhook Handler

Modify your handler to support both v2 and v3 payloads during transition:

```javascript
app.post('/webhooks/fieldnation', express.raw({type: 'application/json'}), (req, res) => {
  // Detect version
  const signature = req.headers['x-fn-signature'];
  const isV3 = !!signature;
  
  if (isV3) {
    // v3 processing
    if (!verifySignatureV3(req.body, signature, process.env.WEBHOOK_SECRET_V3)) {
      return res.status(401).send('Unauthorized');
    }
    
    const payload = JSON.parse(req.body.toString());
    processV3Webhook(payload);
  } else {
    // v2 processing (legacy)
    if (!verifyBasicAuth(req.headers.authorization)) {
      return res.status(401).send('Unauthorized');
    }
    
    const payload = JSON.parse(req.body.toString());
    processV2Webhook(payload);
  }
  
  res.status(200).send('OK');
});

function processV3Webhook(payload) {
  // Handle v3 payload structure
  const { eventId, eventName, workOrderId, data } = payload;
  console.log(`[v3] Event ${eventName} for work order ${workOrderId}`);
  // ... process
}

function processV2Webhook(payload) {
  // Handle v2 payload structure
  const { id, event, work_order_id, work_order } = payload;
  console.log(`[v2] Event ${event} for work order ${work_order_id}`);
  // ... process
}
```

### Create v3 Webhooks

Create new v3 webhooks in sandbox:

```javascript
async function createV3Webhook(v2Webhook) {
  // Map v2 events to v3
  const v3Events = migrateEvents(v2Webhook.events);
  
  // Create v3 webhook
  const response = await fetch(
    'https://api-sandbox.fndev.net/api/v1/webhooks',
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        url: v2Webhook.url,
        method: 'post',
        status: 'active',
        events: v3Events,
        notificationEmail: 'alerts@example.com'
      })
    }
  );
  
  const v3Webhook = await response.json();
  
  console.log(`Created v3 webhook ${v3Webhook.result.webhookId}`);
  console.log(`Secret: ${v3Webhook.result.secret}`);
  
  return v3Webhook.result;
}
```

### Test in Sandbox

Thoroughly test v3 webhooks before production:

```bash
# Use ngrok for local testing
ngrok http 3000

# Create test webhook
curl -X POST https://api-sandbox.fndev.net/api/v1/webhooks \
  -H "Authorization: Bearer YOUR_SANDBOX_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://your-ngrok-url.ngrok-free.app/webhooks",
    "method": "post",
    "status": "active",
    "events": ["workorder.status.published", "workorder.status.assigned"]
  }'

# Trigger test events
# ... create and publish work orders in sandbox
```

### Parallel Run

Run v2 and v3 webhooks in parallel:

```javascript
// Keep v2 webhook active
// Add v3 webhook pointing to same endpoint
// Your handler supports both versions

app.post('/webhooks', (req, res) => {
  const signature = req.headers['x-fn-signature'];
  const version = signature ? 'v3' : 'v2';
  
  console.log(`Received ${version} webhook`);
  
  // Process based on version
  if (version === 'v3') {
    processV3(req);
  } else {
    processV2(req);
  }
  
  res.status(200).send('OK');
});
```

### Monitor Both Versions

Track v3 delivery health:

```javascript
async function compareVersions() {
  // v2 webhooks (your monitoring)
  const v2Stats = await getV2Stats();
  
  // v3 webhooks (delivery logs API)
  const v3Logs = await fetch(
    'https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123',
    {
      headers: { 'Authorization': `Bearer ${token}` }
    }
  );
  
  const v3Stats = calculateStats(await v3Logs.json());
  
  console.log('v2 Success Rate:', v2Stats.successRate);
  console.log('v3 Success Rate:', v3Stats.successRate);
  
  // Continue if v3 performs as well as v2
  return v3Stats.successRate >= v2Stats.successRate;
}
```

### Cutover to v3

Once confident, switch to v3 only:

```javascript
// 1. Update handler to v3 only
app.post('/webhooks', express.raw({type: 'application/json'}), (req, res) => {
  const signature = req.headers['x-fn-signature'];
  
  if (!verifySignatureV3(req.body, signature, secret)) {
    return res.status(401).send('Unauthorized');
  }
  
  const payload = JSON.parse(req.body.toString());
  processV3Webhook(payload);
  
  res.status(200).send('OK');
});

// 2. Deactivate v2 webhooks
await deactivateV2Webhooks();

// 3. Monitor for issues
await monitorV3Health(24); // 24 hours
```

### Cleanup

After successful migration:

```javascript
// Delete v2 webhooks
await deleteV2Webhooks();

// Remove v2 compatibility code
// Update documentation
```

---

## Feature Adoption

### Use New v3 Events

Subscribe to new events not available in v2:

```javascript
const newV3Events = [
  'workorder.routed',
  'workorder.requested',
  'workorder.declined',
  'workorder.undeclined',
  'workorder.task_completed',
  'workorder.task_incomplete',
  'workorder.provider_upload',
  'workorder.message_posted',
  'workorder.custom_field_value_updated',
  'workorder.schedule_updated',
  'workorder.tag_added',
  'workorder.tag_removed',
  'workorder.part_updated'
];
```

### Implement Retry Logic

Leverage v3's automatic retry system:

```javascript
// Monitor delivery logs
async function monitorDeliveries(webhookId) {
  const logs = await fetch(
    `https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=${webhookId}`,
    {
      headers: { 'Authorization': `Bearer ${token}` }
    }
  );
  
  const { result } = await logs.json();
  
  const failed = result.filter(log => log.deliveryStatus >= 400);
  
  if (failed.length > 0) {
    console.log(`${failed.length} failed deliveries`);
    
    // Manual retry if needed
    for (const log of failed) {
      await retryDelivery(log.deliveryId);
    }
  }
}
```

---

## Rollback Plan

If issues arise, you can rollback:

```javascript
// 1. Reactivate v2 webhooks
await reactivateV2Webhooks();

// 2. Deactivate v3 webhooks
await fetch(`https://api-sandbox.fndev.net/api/v1/webhooks/${webhookId}`, {
  method: 'PUT',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ status: 'inactive' })
});

// 3. Restore v2 handler logic
```

---

## Need Help?

- **Support Portal**: [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases)
- **API Documentation**: [developers.fieldnation.com/docs/webhooks](https://developers.fieldnation.com/docs/webhooks)

---

---

### undefined
URL: /docs/webhooks/quickstart

# Webhooks: undefined
URL: /docs/webhooks/quickstart
Source: content/docs/webhooks/quickstart.mdx

---
title: Quickstart
description: Create your first webhook and receive Field Nation events in under 15 minutes. Step-by-step guide from setup to testing.
icon: Rocket
---

## Overview

By the end of this quickstart, you'll have:

- ✅ A publicly accessible webhook endpoint
- ✅ A webhook configured in Field Nation
- ✅ Received and verified a real webhook event
- ✅ Validated the HMAC-SHA256 signature

**Estimated Time**: 10-15 minutes

---

## Step 1: Set Up Your Endpoint

You need a publicly accessible HTTPS endpoint to receive webhooks. Choose your approach:

  
    **Perfect for testing** - No code required!

    ### Using webhook.site

    1. Visit [webhook.site](https://webhook.site)
    2. Copy your unique URL (e.g., `https://webhook.site/abc123...`)
    3. Keep the tab open to see incoming requests

    ```plaintext
    Your Webhook URL:
    https://webhook.site/abc-1234-def-5678
    ```

    > [INFO] **Tip**: webhook.site automatically returns 200 OK and displays request details. Perfect for initial testing!
  
  
    **Test with your local server**

    ### Install ngrok

    ```bash
    # macOS (Homebrew)
    brew install ngrok/ngrok/ngrok

    # Or download from https://ngrok.com/download
    ```

    ### Start your local server

    ```javascript title="server.js"
    const express = require('express');
    const app = express();

    app.use(express.raw({ type: 'application/json' }));

    app.post('/webhooks/fieldnation', (req, res) => {
      console.log('Webhook received:', req.body.toString());
      res.status(200).send('OK');
    });

    app.listen(3000, () => {
      console.log('Webhook server running on port 3000');
    });
    ```

    ### Expose with ngrok

    ```bash
    ngrok http 3000
    ```

    Copy the HTTPS forwarding URL:

    ```plaintext
    Forwarding: https://abc123.ngrok-free.app → localhost:3000
    ```

    Your webhook URL: `https://abc123.ngrok-free.app/webhooks/fieldnation`
  
  
    **For production use**

    ### Example Express.js Server

    ```javascript title="webhook-server.js"
    const express = require('express');
    const crypto = require('crypto');
    const app = express();

    // Important: Use raw body for signature verification
    app.use(express.raw({ type: 'application/json' }));

    app.post('/webhooks/fieldnation', (req, res) => {
      // Verify signature (see Security Guide)
      const signature = req.headers['x-fn-signature'];
      
      // Process the event
      const event = JSON.parse(req.body.toString());
      console.log('Event received:', event.eventName);
      
      // Respond quickly (< 5 seconds)
      res.status(200).send('OK');
      
      // Process asynchronously
      processWebhookAsync(event);
    });

    function processWebhookAsync(event) {
      // Your business logic here
      // Update database, trigger workflows, etc.
    }

    app.listen(443, () => {
      console.log('Production webhook server running');
    });
    ```

    Deploy to your cloud provider (AWS, GCP, Azure, Heroku, etc.)
  

---

## Step 2: Get API Credentials

You need an OAuth access token to create webhooks via API.

### Obtain Client Credentials

If you don't have them yet:

1. Navigate to [Field Nation Support](https://app.fieldnation.com/support-cases)
2. Submit a case requesting API credentials
3. Receive `client_id` and `client_secret`

### Generate Access Token

```bash title="Get OAuth Token"
curl -X POST https://api-sandbox.fndev.net/authentication/api/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=YOUR_CLIENT_ID" \
  -d "client_secret=YOUR_CLIENT_SECRET"
```

Response:

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

> **Important**: Save your access token. It's valid for 1 hour. For production, implement token refresh logic.

---

## Step 3: Create Your Webhook

Choose your preferred method:

  
    ### Using the Webhooks Dashboard

    

    ### Navigate to Dashboard

    - **Sandbox**: [https://ui-sandbox.fndev.net/integrations/webhooks](https://ui-sandbox.fndev.net/integrations/webhooks)
    - **Production**: [https://app.fieldnation.com/integrations/webhooks](https://app.fieldnation.com/integrations/webhooks)

    ### Click "Create New"

    ### Configure Basic Settings

    - **URL**: Your endpoint from Step 1
    - **HTTP Method**: POST (recommended)
    - **Status**: Active

    ### Select Events

    For this quickstart, select:
    - `workorder.created`
    - `workorder.status.published`
    - `workorder.status.assigned`

    > [INFO] **Tip**: Start with a few events, then expand once you're comfortable.

    ### Save Webhook Configuration

    Note your **Webhook ID** and **Secret** - you'll need these for signature verification.

    
  
  
    ### Using the Webhooks API

    ```bash title="Create Webhook"
    curl -X POST https://api-sandbox.fndev.net/api/v1/webhooks \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "url": "https://your-endpoint.com/webhooks",
        "method": "post",
        "status": "active",
        "events": [
          "workorder.created",
          "workorder.status.published",
          "workorder.status.assigned"
        ],
        "notificationEmail": "your-email@example.com"
      }'
    ```

    **Response:**

    ```json
    {
      "metadata": {
        "timestamp": "2025-01-15T10:30:00Z"
      },
      "result": {
        "id": 123,
        "webhookId": "wh_abc123def456",
        "url": "https://your-endpoint.com/webhooks",
        "method": "post",
        "status": "active",
        "secret": "01999f51-5c66-4449-b441-6b4a053fee6a",
        "events": [
          "workorder.created",
          "workorder.status.published",
          "workorder.status.assigned"
        ],
        "createdAt": "2025-01-15T10:30:00Z"
      }
    }
    ```

    > **Save the secret!** You'll use this to verify webhook signatures. It's only shown once during creation.
  

---

## Step 4: Trigger a Test Event

Now let's create an event to trigger your webhook:

### Create a Work Order (Sandbox)

Use the Field Nation sandbox UI or API to create a test work order:

**Via Sandbox UI:**
1. Login to [Sandbox](https://ui-sandbox.fndev.net)
2. Navigate to Work Orders
3. Click "Create Work Order"
4. Fill in basic details and publish

**Via REST API:**

```bash
curl -X POST https://api-sandbox.fndev.net/api/rest/v2/workorder \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Test Webhook Work Order",
    "description": "Testing webhook delivery",
    "schedule": {
      "serviceWindow": {
        "start": "2025-01-20T09:00:00Z",
        "end": "2025-01-20T17:00:00Z"
      }
    }
  }'
```

### Check Your Endpoint

Within seconds, you should receive a `workorder.created` event:

```json
{
  "eventName": "workorder.created",
  "eventId": "evt_abc123",
  "workOrderId": 12345,
  "timestamp": "2025-01-15T10:35:00Z",
  "data": {
    "id": 12345,
    "title": "Test Webhook Work Order",
    "status": "draft",
    // ... full work order details
  }
}
```

---

## Step 5: Verify Webhook Signature

**Security critical!** Always verify that webhooks actually came from Field Nation:

  
    ```javascript
    const crypto = require('crypto');

    function verifyWebhookSignature(req, secret) {
      // Get signature from header
      const signature = req.headers['x-fn-signature'];
      if (!signature) return false;

      // Parse algorithm and hash
      const [algorithm, requestHash] = signature.split('=');
      
      // Compute expected signature
      const expectedHash = crypto
        .createHmac(algorithm, secret)
        .update(req.body) // Raw body buffer
        .digest('hex');
      
      // Timing-safe comparison
      return crypto.timingSafeEqual(
        Buffer.from(expectedHash),
        Buffer.from(requestHash)
      );
    }

    // Usage
    app.post('/webhooks/fieldnation', (req, res) => {
      if (!verifyWebhookSignature(req, process.env.WEBHOOK_SECRET)) {
        return res.status(401).send('Invalid signature');
      }
      
      // Process the verified webhook
      const event = JSON.parse(req.body.toString());
      console.log('Verified event:', event.eventName);
      
      res.status(200).send('OK');
    });
    ```
  
  
    ```python
    import hmac
    import hashlib

    def verify_webhook_signature(request, secret):
        # Get signature from header
        signature = request.headers.get('x-fn-signature')
        if not signature:
            return False
        
        # Parse algorithm and hash
        algorithm, request_hash = signature.split('=')
        
        # Compute expected signature
        expected_hash = hmac.new(
            secret.encode(),
            msg=request.body,
            digestmod=algorithm
        ).hexdigest()
        
        # Timing-safe comparison
        return hmac.compare_digest(expected_hash, request_hash)

    # Usage in Flask
    @app.route('/webhooks/fieldnation', methods=['POST'])
    def handle_webhook():
        if not verify_webhook_signature(request, os.environ['WEBHOOK_SECRET']):
            return 'Invalid signature', 401
        
        # Process the verified webhook
        event = request.get_json()
        print(f"Verified event: {event['eventName']}")
        
        return 'OK', 200
    ```
  
  
    ```php
    <?php
    function verifyWebhookSignature($headers, $body, $secret) {
        // Get signature from header
        if (!isset($headers['x-fn-signature'])) {
            return false;
        }
        
        // Parse algorithm and hash
        [$algorithm, $requestHash] = explode('=', $headers['x-fn-signature']);
        
        // Compute expected signature
        $expectedHash = hash_hmac($algorithm, $body, $secret);
        
        // Timing-safe comparison
        return hash_equals($expectedHash, $requestHash);
    }

    // Usage
    $headers = getallheaders();
    $body = file_get_contents('php://input');
    $secret = getenv('WEBHOOK_SECRET');

    if (!verifyWebhookSignature($headers, $body, $secret)) {
        http_response_code(401);
        die('Invalid signature');
    }

    // Process the verified webhook
    $event = json_decode($body);
    error_log("Verified event: " . $event->eventName);

    http_response_code(200);
    echo 'OK';
    ?>
    ```
  
  
    ```go
    package main

    import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "io"
        "net/http"
        "os"
        "strings"
    )

    func verifyWebhookSignature(r *http.Request, body []byte, secret string) bool {
        // Get signature from header
        signature := r.Header.Get("x-fn-signature")
        if signature == "" {
            return false
        }
        
        // Parse algorithm and hash
        parts := strings.Split(signature, "=")
        if len(parts) != 2 {
            return false
        }
        algorithm, requestHash := parts[0], parts[1]
        
        // Compute expected signature (assuming SHA256)
        h := hmac.New(sha256.New, []byte(secret))
        h.Write(body)
        expectedHash := hex.EncodeToString(h.Sum(nil))
        
        // Timing-safe comparison
        return hmac.Equal([]byte(expectedHash), []byte(requestHash))
    }

    func handleWebhook(w http.ResponseWriter, r *http.Request) {
        body, _ := io.ReadAll(r.Body)
        secret := os.Getenv("WEBHOOK_SECRET")
        
        if !verifyWebhookSignature(r, body, secret) {
            http.Error(w, "Invalid signature", http.StatusUnauthorized)
            return
        }
        
        // Process the verified webhook
        // event := parseJSON(body)
        
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    }
    ```
  

> **Critical Security**: Always verify signatures in production. Without verification, anyone can send fake webhooks to your endpoint.

---

## Step 6: Monitor Delivery

Check that your webhook was delivered successfully:

### Via Web UI

1. Navigate to [Webhooks Dashboard](https://ui-sandbox.fndev.net/integrations/webhooks)
2. Click on your webhook
3. Go to "Delivery Logs" tab
4. Verify delivery status is 200

### Via API

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=YOUR_WEBHOOK_ID" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T10:40:00Z",
    "count": 1,
    "total": 1
  },
  "result": [
    {
      "deliveryId": "del_xyz789",
      "webhookId": "wh_abc123",
      "eventName": "workorder.created",
      "deliveryStatus": 200,
      "deliveryAttempt": 1,
      "createdAt": "2025-01-15T10:35:05Z"
    }
  ]
}
```

---

## Troubleshooting

### Not Receiving Webhooks?

  
    Ensure your webhook is **active**, not inactive or archived.
    
    ```bash
    curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/YOUR_WEBHOOK_ID \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    Test your endpoint is publicly accessible:
    
    ```bash
    curl -X POST https://your-endpoint.com/webhooks \
      -H "Content-Type: application/json" \
      -d '{"test": "data"}'
    ```
    
    Should return 200 OK.
  
  
    Look for failed deliveries and error messages:
    
    - **404 Not Found**: Check your URL path
    - **SSL Error**: Verify HTTPS certificate is valid
    - **Timeout**: Ensure response within 5 seconds
  
  
    Confirm you're subscribed to the event you triggered:
    
    ```bash
    # List subscribed events
    curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/YOUR_WEBHOOK_ID \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
      | jq '.result.events'
    ```
  

### Common Issues

| Issue | Solution |
|-------|----------|
| **401 Unauthorized** | Refresh your OAuth access token |
| **Webhook auto-deactivated** | Fix endpoint errors, then reactivate |
| **Receiving duplicates** | Implement idempotency using `eventId` |
| **Signature verification fails** | Use raw body buffer, not parsed JSON |

[Complete troubleshooting guide →](/docs/webhooks/troubleshooting/common-issues)

---

---

### undefined
URL: /docs/webhooks/api-reference/delivery-logs

# Webhooks: undefined
URL: /docs/webhooks/api-reference/delivery-logs
Source: content/docs/webhooks/api-reference/delivery-logs.mdx

---
title: Delivery Logs API
description: Monitor webhook delivery attempts, access detailed logs, and retry failed deliveries programmatically.
---

## Endpoints Overview

| Method | Endpoint | Description |
|--------|----------|-------------|
| **GET** | `/api/v1/webhooks/delivery-logs` | List delivery logs |
| **GET** | `/api/v1/webhooks/delivery-logs/{deliveryId}` | Get delivery details |
| **PATCH** | `/api/v1/webhooks/delivery-logs/{deliveryId}/retry` | Retry failed delivery |

---

## List Delivery Logs

Retrieve paginated list of webhook delivery attempts.

### Request

**GET** `/api/v1/webhooks/delivery-logs`

**Query Parameters:**

### Example Requests

  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?perPage=50" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?deliveryStatus=500" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?workOrderId=12345" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  

### Response

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "query": {
      "webhookId": "wh_abc123",
      "page": 1,
      "perPage": 50
    }
  },
  "result": [
    {
      "deliveryId": "del_xyz789",
      "webhookId": "wh_abc123",
      "workOrderId": 12345,
      "eventName": "workorder.status.published",
      "deliveryStatus": 200,
      "deliveryAttempt": 1,
      "createdAt": "2025-01-15T11:59:00Z"
    }
  ]
}
```

---

## Get Delivery Details

Retrieve detailed information including pre-signed URL to complete log file.

### Request

**GET** `/api/v1/webhooks/delivery-logs/{deliveryId}`

### Example

```bash
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/del_xyz789 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Response

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z"
  },
  "result": {
    "deliveryId": "del_xyz789",
    "webhookId": "wh_abc123",
    "eventName": "workorder.status.published",
    "deliveryStatus": 200,
    "deliveryAttempt": 1,
    "createdAt": "2025-01-15T11:59:00Z",
    "delivery_log": "https://s3.amazonaws.com/fn-logs/del_xyz789?AWSAccessKeyId=...&Expires=1642252800&Signature=..."
  }
}
```

![Delivery Logs Dashboard](/docs/webhook-v3/delivery-logs.png)

---

## Retry Failed Delivery

Manually retry a failed delivery attempt.

### Request

**PATCH** `/api/v1/webhooks/delivery-logs/{deliveryId}/retry`

### Example

```bash
curl -X PATCH https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/del_xyz789/retry \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Response

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z"
  },
  "result": {
    "job_id": "job_abc123"
  }
}
```

![Retry Delivery](/docs/webhook-v3/delivery-log-retry.png)

> [INFO] The `job_id` can be used to track the retry attempt in delivery logs.

---

## Code Examples

```javascript
class DeliveryLogMonitor {
  constructor(accessToken) {
    this.accessToken = accessToken;
    this.baseUrl = 'https://api-sandbox.fndev.net';
  }
  
  async getLogs(filters = {}) {
    const params = new URLSearchParams(filters);
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks/delivery-logs?${params}`,
      {
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    return await response.json();
  }
  
  async getDeliveryDetails(deliveryId) {
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks/delivery-logs/${deliveryId}`,
      {
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    return await response.json();
  }
  
  async retryDelivery(deliveryId) {
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks/delivery-logs/${deliveryId}/retry`,
      {
        method: 'PATCH',
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    return await response.json();
  }
  
  async getFailedDeliveries(webhookId, hours = 24) {
    const since = new Date(Date.now() - hours * 60 * 60 * 1000).toISOString();
    
    const logs = await this.getLogs({
      webhookId,
      sortBy: 'createdAt',
      sortDirection: 'DESC'
    });
    
    return logs.result.filter(log =>
      log.deliveryStatus >= 400 &&
      new Date(log.createdAt) >= new Date(since)
    );
  }
  
  async retryAllFailed(webhookId) {
    const failed = await this.getFailedDeliveries(webhookId);
    
    const results = [];
    for (const log of failed) {
      try {
        const result = await this.retryDelivery(log.deliveryId);
        results.push({ deliveryId: log.deliveryId, success: true, jobId: result.result.job_id });
      } catch (error) {
        results.push({ deliveryId: log.deliveryId, success: false, error: error.message });
      }
    }
    
    return results;
  }
}

// Usage
const monitor = new DeliveryLogMonitor(accessToken);

// Get failed deliveries
const failed = await monitor.getFailedDeliveries('wh_abc123', 24);
console.log(`${failed.length} failed deliveries in last 24 hours`);

// Retry all failed
const results = await monitor.retryAllFailed('wh_abc123');
console.log(`Retried ${results.length} deliveries`);
```

---

---

### undefined
URL: /docs/webhooks/api-reference/events

# Webhooks: undefined
URL: /docs/webhooks/api-reference/events
Source: content/docs/webhooks/api-reference/events.mdx

---
title: Events API
description: List and discover available webhook events with filtering by model type. Programmatically retrieve all 33 webhook events.
---

## List Webhook Events

Retrieve all available webhook events with their details.

### Request

**GET** `/api/v1/webhooks/events`

**Headers:**
- `Authorization: Bearer {access_token}` (required)

**Query Parameters:**

### Example Requests

  
    ```bash
    curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/events \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/events?model=WorkOrder" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  

### Response

**Status**: `200 OK`

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "query": {
      "model": null
    }
  },
  "result": [
    {
      "name": "workorder.created",
      "label": "Work Order created",
      "description": "Triggered when a work order is created.",
      "model": "WorkOrder"
    },
    {
      "name": "workorder.routed",
      "label": "Work Order routed",
      "description": "Triggered when a work order is routed to a provider.",
      "model": "WorkOrder"
    },
    {
      "name": "workorder.status.published",
      "label": "Work Order status published",
      "description": "Triggered when a work order status changes to published.",
      "model": "WorkOrder"
    },
    {
      "name": "workorder.status.assigned",
      "label": "Work Order status assigned",
      "description": "Triggered when a work order status changes to assigned.",
      "model": "WorkOrder"
    },
    {
      "name": "workorder.status.work_done",
      "label": "Work Order status work done",
      "description": "Triggered when a work order status changes to work done.",
      "model": "WorkOrder"
    }
    // ... all 33 events
  ]
}
```

---

## Event Object Structure

Each event in the response includes:

---

## Complete Event List

### Lifecycle Events (13 events)

```json
[
  {
    "name": "workorder.created",
    "label": "Work Order created",
    "description": "Triggered when a work order is created.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.routed",
    "label": "Work Order routed",
    "description": "Triggered when a work order is routed to a provider.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.requested",
    "label": "Work Order requested",
    "description": "Triggered when a work order is requested.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.declined",
    "label": "Work Order declined",
    "description": "Triggered when a work order is declined by a provider.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.undeclined",
    "label": "Work Order undeclined",
    "description": "Triggered when a work order is undeclined by a provider.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.task_completed",
    "label": "Work Order task completed",
    "description": "Triggered when a task on a work order is completed.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.task_incomplete",
    "label": "Work Order task incomplete",
    "description": "Triggered when a task on a work order is marked as incomplete.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.provider_upload",
    "label": "Work Order provider upload",
    "description": "Triggered when a provider uploads a document to a work order.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.message_posted",
    "label": "Work Order message posted",
    "description": "Triggered when a message is posted or replied to on a work order.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.custom_field_value_updated",
    "label": "Work Order custom field value updated",
    "description": "Triggered when a custom field value is updated on a work order.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.schedule_updated",
    "label": "Work Order schedule updated",
    "description": "Triggered when a schedule is updated on a work order.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.tag_added",
    "label": "Work Order tag added",
    "description": "Triggered when a tag is added to a work order.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.tag_removed",
    "label": "Work Order tag removed",
    "description": "Triggered when a tag is removed from a work order.",
    "model": "WorkOrder"
  }
]
```

### Status Change Events (19 events)

```json
[
  {
    "name": "workorder.status.draft",
    "label": "Work Order status draft",
    "description": "Triggered when a work order status changes to draft.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.routed",
    "label": "Work Order status routed",
    "description": "Triggered when a work order status changes to routed.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.published",
    "label": "Work Order status published",
    "description": "Triggered when a work order status changes to published.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.confirmed",
    "label": "Work Order status confirmed",
    "description": "Triggered when a work order status changes to confirmed.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.assigned",
    "label": "Work Order status assigned",
    "description": "Triggered when a work order status changes to assigned.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.assigned_cancelled",
    "label": "Work Order status assigned cancelled",
    "description": "Triggered when a work order status changes to assigned cancelled.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.at_risk",
    "label": "Work Order status at risk",
    "description": "Triggered when a work order status changes to at risk.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.delayed",
    "label": "Work Order status delayed",
    "description": "Triggered when a work order status changes to delayed.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.on_my_way",
    "label": "Work Order status on my way",
    "description": "Triggered when a work order status changes to on my way.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.checked_in",
    "label": "Work Order status checked in",
    "description": "Triggered when a work order status changes to checked in.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.checked_out",
    "label": "Work Order status checked out",
    "description": "Triggered when a work order status changes to checked out.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.work_done",
    "label": "Work Order status work done",
    "description": "Triggered when a work order status changes to work done.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.approved",
    "label": "Work Order status approved",
    "description": "Triggered when a work order status changes to approved.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.paid",
    "label": "Work Order status paid",
    "description": "Triggered when a work order status changes to paid.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.cancelled",
    "label": "Work Order status cancelled",
    "description": "Triggered when a work order status changes to cancelled.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.deleted",
    "label": "Work Order status deleted",
    "description": "Triggered when a work order status changes to deleted.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.status.postponed",
    "label": "Work Order status postponed",
    "description": "Triggered when a work order status changes to postponed.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.problem_reported",
    "label": "Work Order problem reported",
    "description": "Triggered when a problem is reported or reopened on a work order.",
    "model": "WorkOrder"
  },
  {
    "name": "workorder.problem_resolved",
    "label": "Work Order problem resolved",
    "description": "Triggered when a problem is resolved on a work order.",
    "model": "WorkOrder"
  }
]
```

### Additional Event

```json
{
  "name": "workorder.part_updated",
  "label": "Work Order part updated",
  "description": "Triggered when parts/materials on a work order are updated.",
  "model": "WorkOrder"
}
```

---

## Usage Examples

### Dynamic Event Selection UI

Build a dynamic event selector using the API:

```javascript
async function buildEventSelector() {
  // Fetch available events
  const response = await fetch(
    'https://api-sandbox.fndev.net/api/v1/webhooks/events',
    {
      headers: { 'Authorization': `Bearer ${accessToken}` }
    }
  );
  
  const { result: events } = await response.json();
  
  // Group by category
  const grouped = {
    lifecycle: events.filter(e => !e.name.includes('status.')),
    status: events.filter(e => e.name.includes('status.'))
  };
  
  // Render UI
  return {
    lifecycleEvents: grouped.lifecycle.map(e => ({
      value: e.name,
      label: e.label,
      description: e.description
    })),
    statusEvents: grouped.status.map(e => ({
      value: e.name,
      label: e.label,
      description: e.description
    }))
  };
}
```

### Validate Event Names

Ensure event names are valid before creating webhooks:

```javascript
async function validateEvents(eventNames) {
  // Get available events
  const response = await fetch(
    'https://api-sandbox.fndev.net/api/v1/webhooks/events',
    {
      headers: { 'Authorization': `Bearer ${accessToken}` }
    }
  );
  
  const { result: events } = await response.json();
  const validEvents = new Set(events.map(e => e.name));
  
  // Check each event
  const invalid = eventNames.filter(name => !validEvents.has(name));
  
  if (invalid.length > 0) {
    throw new Error(`Invalid events: ${invalid.join(', ')}`);
  }
  
  return true;
}

// Usage
await validateEvents([
  'workorder.status.published',
  'workorder.status.assigned',
  'invalid.event.name' // Will throw error
]);
```

### Cache Events Locally

Reduce API calls by caching event metadata:

```javascript
class EventCache {
  constructor(accessToken) {
    this.accessToken = accessToken;
    this.cache = null;
    this.cacheExpiry = null;
  }
  
  async getEvents() {
    // Return cache if valid (cache for 24 hours)
    if (this.cache && this.cacheExpiry > Date.now()) {
      return this.cache;
    }
    
    // Fetch from API
    const response = await fetch(
      'https://api-sandbox.fndev.net/api/v1/webhooks/events',
      {
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    
    const { result } = await response.json();
    
    // Cache for 24 hours
    this.cache = result;
    this.cacheExpiry = Date.now() + (24 * 60 * 60 * 1000);
    
    return result;
  }
  
  async getEventByName(eventName) {
    const events = await this.getEvents();
    return events.find(e => e.name === eventName);
  }
  
  async getEventsByModel(model) {
    const events = await this.getEvents();
    return events.filter(e => e.model === model);
  }
}

// Usage
const cache = new EventCache(accessToken);

// Get all events
const allEvents = await cache.getEvents();

// Get specific event
const event = await cache.getEventByName('workorder.status.published');

// Get by model
const workOrderEvents = await cache.getEventsByModel('WorkOrder');
```

---

## Best Practices

### Always Fetch Latest Events

Event list may change as Field Nation adds new events:

```javascript
// ❌ Don't hardcode events
const events = [
  'workorder.status.published',
  'workorder.status.assigned'
];

// ✅ Do fetch from API
const response = await fetch('/api/v1/webhooks/events');
const { result: events } = await response.json();
```

### Validate Before Creating Webhooks

```javascript
async function createValidatedWebhook(config) {
  // 1. Fetch valid events
  const eventsResponse = await fetch(
    'https://api-sandbox.fndev.net/api/v1/webhooks/events',
    {
      headers: { 'Authorization': `Bearer ${accessToken}` }
    }
  );
  
  const { result: validEvents } = await eventsResponse.json();
  const validEventNames = new Set(validEvents.map(e => e.name));
  
  // 2. Validate config events
  const invalid = config.events.filter(name => !validEventNames.has(name));
  
  if (invalid.length > 0) {
    throw new Error(`Invalid events: ${invalid.join(', ')}`);
  }
  
  // 3. Create webhook
  const response = await fetch(
    'https://api-sandbox.fndev.net/api/v1/webhooks',
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(config)
    }
  );
  
  return await response.json();
}
```

### Document Your Subscriptions

```javascript
async function documentWebhookEvents(webhookId) {
  const webhook = await getWebhook(webhookId);
  const allEvents = await getEvents();
  
  const subscribedEvents = webhook.result.events.map(eventName => {
    const event = allEvents.find(e => e.name === eventName);
    return {
      name: eventName,
      label: event?.label || 'Unknown',
      description: event?.description || 'No description'
    };
  });
  
  console.log(`\nWebhook ${webhookId} subscribed to ${subscribedEvents.length} events:\n`);
  subscribedEvents.forEach(event => {
    console.log(`  • ${event.label}`);
    console.log(`    ${event.description}`);
  });
}
```

---

---

### undefined
URL: /docs/webhooks/api-reference/history

# Webhooks: undefined
URL: /docs/webhooks/api-reference/history
Source: content/docs/webhooks/api-reference/history.mdx

---
title: History API
description: Access webhook change history and audit trail. Track all modifications with user, timestamp, and change details.
---

## Get Webhook History

Retrieve paginated change history for a specific webhook.

### Request

**GET** `/api/v1/webhooks/{webhookId}/history`

**Query Parameters:**

### Example Requests

  
    ```bash
    curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123/history \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123/history?userId=456" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123/history?search=status_changed" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  

### Response

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "count": 5,
    "total": 5
  },
  "result": [
    {
      "id": 123,
      "userId": 456,
      "action": "status_changed",
      "changes": {
        "status": {
          "from": "active",
          "to": "inactive"
        }
      },
      "createdAt": "2025-01-15T10:45:00Z",
      "updatedAt": "2025-01-15T10:45:00Z"
    },
    {
      "id": 122,
      "userId": 456,
      "action": "events_updated",
      "changes": {
        "events": {
          "added": ["workorder.status.approved"],
          "removed": ["workorder.status.draft"]
        }
      },
      "createdAt": "2025-01-15T09:30:00Z",
      "updatedAt": "2025-01-15T09:30:00Z"
    },
    {
      "id": 121,
      "userId": 456,
      "action": "url_changed",
      "changes": {
        "url": {
          "from": "https://old-endpoint.com/webhook",
          "to": "https://new-endpoint.com/webhooks"
        }
      },
      "createdAt": "2025-01-14T15:20:00Z",
      "updatedAt": "2025-01-14T15:20:00Z"
    },
    {
      "id": 120,
      "userId": 456,
      "action": "webhook_created",
      "changes": {
        "url": "https://new-endpoint.com/webhooks",
        "events": ["workorder.status.published", "workorder.status.draft"],
        "status": "active"
      },
      "createdAt": "2025-01-14T15:00:00Z",
      "updatedAt": "2025-01-14T15:00:00Z"
    }
  ]
}
```

![Webhook Change History](/docs/webhook-v3/webhook-update-history.png)

---

## Change Record Structure

---

## Common Action Types

| Action | Description | Changes Object |
|--------|-------------|----------------|
| `webhook_created` | Webhook created | Initial configuration |
| `status_changed` | Status modified | `{ status: { from, to } }` |
| `url_changed` | URL updated | `{ url: { from, to } }` |
| `events_updated` | Events modified | `{ events: { added: [], removed: [] } }` |
| `webhook_updated` | General update | Modified fields |
| `webhook_deleted` | Webhook deleted | Final configuration |

---

## Code Examples

```javascript
class WebhookAudit {
  constructor(accessToken) {
    this.accessToken = accessToken;
    this.baseUrl = 'https://api-sandbox.fndev.net';
  }
  
  async getHistory(webhookId, filters = {}) {
    const params = new URLSearchParams(filters);
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks/${webhookId}/history?${params}`,
      {
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    return await response.json();
  }
  
  async getChangesByUser(webhookId, userId) {
    return await this.getHistory(webhookId, { userId });
  }
  
  async getRecentChanges(webhookId, hours = 24) {
    const history = await this.getHistory(webhookId, {
      sortBy: 'createdAt',
      sortDirection: 'DESC'
    });
    
    const since = new Date(Date.now() - hours * 60 * 60 * 1000);
    
    return history.result.filter(record =>
      new Date(record.createdAt) >= since
    );
  }
  
  async generateAuditReport(webhookId) {
    const history = await this.getHistory(webhookId);
    
    const report = {
      webhookId,
      totalChanges: history.metadata.total,
      changes: history.result.map(record => ({
        timestamp: record.createdAt,
        user: record.userId,
        action: record.action,
        details: this.formatChanges(record.changes)
      }))
    };
    
    return report;
  }
  
  formatChanges(changes) {
    return Object.entries(changes).map(([key, value]) => {
      if (value.from && value.to) {
        return `${key}: ${value.from} → ${value.to}`;
      }
      if (value.added && value.removed) {
        return `${key}: +${value.added.length} -${value.removed.length}`;
      }
      return `${key}: ${JSON.stringify(value)}`;
    }).join(', ');
  }
}

// Usage
const audit = new WebhookAudit(accessToken);

// Get full history
const history = await audit.getHistory('wh_abc123');

// Get changes by specific user
const userChanges = await audit.getChangesByUser('wh_abc123', 456);

// Get recent changes
const recent = await audit.getRecentChanges('wh_abc123', 24);

// Generate audit report
const report = await audit.generateAuditReport('wh_abc123');
console.log(`Webhook has ${report.totalChanges} changes`);
report.changes.forEach(change => {
  console.log(`  ${change.timestamp} - ${change.action} by user ${change.user}`);
});
```

---

---

### undefined
URL: /docs/webhooks/api-reference/overview

# Webhooks: undefined
URL: /docs/webhooks/api-reference/overview
Source: content/docs/webhooks/api-reference/overview.mdx

---
title: API Reference Overview
description: Complete API documentation for Field Nation Webhooks v3 including authentication, base URLs, endpoints, and best practices.
---

## Base Information

### API Version

**Current Version**: v3.0

**Base URL (Sandbox)**: `https://api-sandbox.fndev.net`

**Base URL (Production)**: Contact Field Nation support for production access

### OpenAPI Specification

- **Swagger UI (Sandbox)**: [https://ui-sandbox.fndev.net/integrations/webhooks/_api](https://ui-sandbox.fndev.net/integrations/webhooks/_api)
- **JSON Spec (Sandbox)**: [https://ui-sandbox.fndev.net/integrations/webhooks/_api-json](https://ui-sandbox.fndev.net/integrations/webhooks/_api-json)

---

## Authentication

The Webhooks API uses OAuth 2.0 Bearer tokens for authentication.

### Getting an Access Token

### Obtain Credentials

Request API credentials from Field Nation:
- `client_id`
- `client_secret`

### Generate Access Token

```bash
curl -X POST https://api-sandbox.fndev.net/authentication/api/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=YOUR_CLIENT_ID" \
  -d "client_secret=YOUR_CLIENT_SECRET"
```

**Response:**

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

### Use Token in Requests

```bash
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

> **Token Expiration**: Access tokens expire after 1 hour. Implement token refresh logic for production applications.

### Token Refresh

```javascript
class FieldNationAuth {
  constructor(clientId, clientSecret) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.accessToken = null;
    this.tokenExpiry = null;
  }
  
  async getAccessToken() {
    // Return cached token if still valid
    if (this.accessToken && this.tokenExpiry > Date.now()) {
      return this.accessToken;
    }
    
    // Request new token
    const response = await fetch(
      'https://api-sandbox.fndev.net/authentication/api/oauth/token',
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'client_credentials',
          client_id: this.clientId,
          client_secret: this.clientSecret
        })
      }
    );
    
    const data = await response.json();
    
    this.accessToken = data.access_token;
    // Refresh 5 minutes before expiry
    this.tokenExpiry = Date.now() + (data.expires_in - 300) * 1000;
    
    return this.accessToken;
  }
}

// Usage
const auth = new FieldNationAuth(CLIENT_ID, CLIENT_SECRET);
const token = await auth.getAccessToken();
```

---

## API Endpoints

The Webhooks API is organized into 5 main categories:

### Core Operations

Manage webhook lifecycle (CRUD operations):

| Method | Endpoint | Description |
|--------|----------|-------------|
| **GET** | `/api/v1/webhooks` | List all webhooks |
| **POST** | `/api/v1/webhooks` | Create a webhook |
| **GET** | `/api/v1/webhooks/{webhookId}` | Get webhook details |
| **PUT** | `/api/v1/webhooks/{webhookId}` | Update a webhook |
| **DELETE** | `/api/v1/webhooks/{webhookId}` | Delete a webhook |

[Complete reference →](/docs/webhooks/api-reference/webhooks)

### Events

Discover available webhook events:

| Method | Endpoint | Description |
|--------|----------|-------------|
| **GET** | `/api/v1/webhooks/events` | List available events |

[Complete reference →](/docs/webhooks/api-reference/events)

### Delivery Logs

Monitor webhook deliveries:

| Method | Endpoint | Description |
|--------|----------|-------------|
| **GET** | `/api/v1/webhooks/delivery-logs` | List delivery logs |
| **GET** | `/api/v1/webhooks/delivery-logs/{deliveryId}` | Get delivery details |
| **PATCH** | `/api/v1/webhooks/delivery-logs/{deliveryId}/retry` | Retry failed delivery |

[Complete reference →](/docs/webhooks/api-reference/delivery-logs)

### History

Audit webhook changes:

| Method | Endpoint | Description |
|--------|----------|-------------|
| **GET** | `/api/v1/webhooks/{webhookId}/history` | Get webhook change history |

[Complete reference →](/docs/webhooks/api-reference/history)

### Attributes

Manage custom headers and legacy fields:

| Method | Endpoint | Description |
|--------|----------|-------------|
| **DELETE** | `/api/v1/webhooks/{webhookId}/{attributeType}/{attributeName}` | Delete webhook attribute |

---

## Common Request Patterns

### Pagination

List endpoints support pagination:

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?page=1&perPage=25" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Parameters:**
- `page` (integer): Page number, starts at 1. Default: 1
- `perPage` (integer): Items per page. Default: 25

**Response includes pagination metadata:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "count": 25,
    "total": 150
  },
  "result": [...]
}
```

### Filtering

Filter results by specific fields:

```bash
# Filter by status
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?status=active" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"

# Filter by webhook ID
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Sorting

Sort results by specific fields:

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?sortBy=createdAt&sortDirection=DESC" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Parameters:**
- `sortBy` (string): Field to sort by (e.g., `id`, `createdAt`, `updatedAt`)
- `sortDirection` (string): `ASC` or `DESC`

### Field Selection

Request only specific fields:

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/{webhookId}?fields=id,webhookId,url,status,events" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Searching

Search across searchable fields:

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?search=production" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

---

## Response Format

### Success Response

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "count": 1,
    "total": 1
  },
  "result": {
    // Response data
  }
}
```

### Error Response

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "path": "/api/v1/webhooks"
  },
  "errors": [
    {
      "code": 400,
      "message": "Invalid request: missing required field 'url'"
    }
  ],
  "result": {}
}
```

### HTTP Status Codes

| Status | Meaning |
|--------|---------|
| **200** | Success |
| **201** | Created |
| **400** | Bad Request - Invalid parameters |
| **401** | Unauthorized - Invalid or missing token |
| **403** | Forbidden - Insufficient permissions |
| **404** | Not Found - Resource doesn't exist |
| **422** | Unprocessable Entity - Validation failed |
| **429** | Too Many Requests - Rate limit exceeded |
| **500** | Internal Server Error |
| **503** | Service Unavailable |

---

## Rate Limiting

The API enforces rate limits to ensure fair usage:

- **Rate Limit**: 100 requests per minute per client
- **Burst**: 20 requests

**Rate limit headers:**

```http
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 85
X-RateLimit-Reset: 1642252800
```

### Handling Rate Limits

```javascript
async function makeAPIRequest(url, options) {
  const response = await fetch(url, options);
  
  if (response.status === 429) {
    const resetTime = parseInt(response.headers.get('X-RateLimit-Reset'));
    const waitTime = (resetTime * 1000) - Date.now();
    
    console.log(`Rate limit exceeded. Waiting ${waitTime}ms...`);
    await sleep(waitTime);
    
    // Retry
    return await makeAPIRequest(url, options);
  }
  
  return response;
}
```

---

## Best Practices

### Error Handling

Always handle API errors gracefully:

```javascript
async function createWebhook(config) {
  try {
    const response = await fetch(
      'https://api-sandbox.fndev.net/api/v1/webhooks',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(config)
      }
    );
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(`API Error: ${error.errors[0].message}`);
    }
    
    return await response.json();
    
  } catch (error) {
    console.error('Failed to create webhook:', error);
    throw error;
  }
}
```

### Retry Logic

Implement exponential backoff for transient errors:

```javascript
async function apiRequestWithRetry(url, options, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      // Retry on 5xx errors
      if (response.status >= 500) {
        if (attempt === maxRetries) {
          throw new Error(`Max retries exceeded: ${response.status}`);
        }
        
        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
        console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
        await sleep(delay);
        continue;
      }
      
      return response;
      
    } catch (error) {
      if (attempt === maxRetries) throw error;
      
      const delay = Math.pow(2, attempt) * 1000;
      console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
      await sleep(delay);
    }
  }
}
```

### Caching Tokens

Cache access tokens to reduce authentication requests:

```javascript
const tokenCache = {
  token: null,
  expiry: 0
};

async function getToken() {
  const now = Date.now();
  
  // Return cached token if valid
  if (tokenCache.token && tokenCache.expiry > now) {
    return tokenCache.token;
  }
  
  // Fetch new token
  const response = await fetch(/* auth request */);
  const data = await response.json();
  
  tokenCache.token = data.access_token;
  tokenCache.expiry = now + (data.expires_in - 300) * 1000;
  
  return tokenCache.token;
}
```

### Logging Requests

Log API requests for debugging:

```javascript
async function loggedAPIRequest(url, options) {
  const requestId = generateRequestId();
  
  console.log(`[${requestId}] Request: ${options.method} ${url}`);
  console.log(`[${requestId}] Headers:`, options.headers);
  
  const startTime = Date.now();
  const response = await fetch(url, options);
  const duration = Date.now() - startTime;
  
  console.log(`[${requestId}] Response: ${response.status} (${duration}ms)`);
  
  return response;
}
```

---

## SDK Example

Wrapper class for cleaner API interactions:

```javascript title="fieldnation-webhooks-sdk.js"
class FieldNationWebhooksAPI {
  constructor(clientId, clientSecret, baseUrl) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.baseUrl = baseUrl || 'https://api-sandbox.fndev.net';
    this.accessToken = null;
    this.tokenExpiry = null;
  }
  
  async getAccessToken() {
    if (this.accessToken && this.tokenExpiry > Date.now()) {
      return this.accessToken;
    }
    
    const response = await fetch(
      `${this.baseUrl}/authentication/api/oauth/token`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'client_credentials',
          client_id: this.clientId,
          client_secret: this.clientSecret
        })
      }
    );
    
    const data = await response.json();
    this.accessToken = data.access_token;
    this.tokenExpiry = Date.now() + (data.expires_in - 300) * 1000;
    
    return this.accessToken;
  }
  
  async request(method, path, body = null) {
    const token = await this.getAccessToken();
    
    const options = {
      method,
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    };
    
    if (body) {
      options.body = JSON.stringify(body);
    }
    
    const response = await fetch(`${this.baseUrl}${path}`, options);
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(`API Error: ${JSON.stringify(error.errors)}`);
    }
    
    return await response.json();
  }
  
  // Webhook Operations
  async listWebhooks(params = {}) {
    const query = new URLSearchParams(params);
    return await this.request('GET', `/api/v1/webhooks?${query}`);
  }
  
  async getWebhook(webhookId) {
    return await this.request('GET', `/api/v1/webhooks/${webhookId}`);
  }
  
  async createWebhook(config) {
    return await this.request('POST', '/api/v1/webhooks', config);
  }
  
  async updateWebhook(webhookId, updates) {
    return await this.request('PUT', `/api/v1/webhooks/${webhookId}`, updates);
  }
  
  async deleteWebhook(webhookId) {
    return await this.request('DELETE', `/api/v1/webhooks/${webhookId}`);
  }
  
  // Delivery Logs
  async getDeliveryLogs(params = {}) {
    const query = new URLSearchParams(params);
    return await this.request('GET', `/api/v1/webhooks/delivery-logs?${query}`);
  }
  
  async retryDelivery(deliveryId) {
    return await this.request('PATCH', `/api/v1/webhooks/delivery-logs/${deliveryId}/retry`);
  }
  
  // Events
  async getAvailableEvents(model = null) {
    const query = model ? `?model=${model}` : '';
    return await this.request('GET', `/api/v1/webhooks/events${query}`);
  }
}

// Usage
const api = new FieldNationWebhooksAPI(CLIENT_ID, CLIENT_SECRET);

// List webhooks
const webhooks = await api.listWebhooks({ status: 'active' });

// Create webhook
const webhook = await api.createWebhook({
  url: 'https://example.com/webhooks',
  method: 'post',
  status: 'active',
  events: ['workorder.status.published']
});

// Get delivery logs
const logs = await api.getDeliveryLogs({ webhookId: webhook.result.webhookId });
```

---

---

### undefined
URL: /docs/webhooks/api-reference/webhooks

# Webhooks: undefined
URL: /docs/webhooks/api-reference/webhooks
Source: content/docs/webhooks/api-reference/webhooks.mdx

---
title: Webhook Operations API
description: Complete API reference for webhook CRUD operations - create, list, get, update, and delete webhooks programmatically.
---

## Endpoints Overview

| Method | Endpoint | Description |
|--------|----------|-------------|
| **POST** | `/api/v1/webhooks` | Create a new webhook |
| **GET** | `/api/v1/webhooks` | List all webhooks |
| **GET** | `/api/v1/webhooks/{webhookId}` | Get webhook details |
| **PUT** | `/api/v1/webhooks/{webhookId}` | Update a webhook |
| **DELETE** | `/api/v1/webhooks/{webhookId}` | Delete a webhook |

---

## Create Webhook

Create a new webhook configuration.

### Request

**POST** `/api/v1/webhooks`

**Headers:**
- `Authorization: Bearer {access_token}` (required)
- `Content-Type: application/json` (required)

**Body Parameters:**

",
      description: "Array of event names to subscribe to. Must contain at least 1 event.",
      required: true
    },
    "secret": {
      type: "string (UUID)",
      description: "Optional secret for HMAC-SHA256 signing. Auto-generated if omitted.",
      required: false
    },
    "notificationEmail": {
      type: "string (email)",
      description: "Email address for delivery failure notifications.",
      required: false
    },
    "isIntegrationOnly": {
      type: "boolean",
      description: "Whether webhook is restricted to API-only access.",
      required: false,
      default: false
    },
    "webhookAttribute": {
      type: "object",
      description: "Custom headers and legacy field mappings.",
      required: false
    }
  }}
/>

### Example Request

```bash
curl -X POST https://api-sandbox.fndev.net/api/v1/webhooks \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://your-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "events": [
      "workorder.status.published",
      "workorder.status.assigned",
      "workorder.status.work_done",
      "workorder.status.approved"
    ],
    "notificationEmail": "webhook-alerts@example.com",
    "webhookAttribute": {
      "header": {
        "Authorization": "Bearer your-api-token",
        "X-Custom-ID": "prod-webhook-001"
      }
    }
  }'
```

### Response

**Status**: `200 OK`

```json
{
  "metadata": {
    "timestamp": "2025-01-15T10:30:00Z"
  },
  "result": {
    "id": 123,
    "webhookId": "wh_abc123def456",
    "companyId": 789,
    "userId": 456,
    "url": "https://your-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "secret": "01999f51-5c66-4449-b441-6b4a053fee6a",
    "events": [
      "workorder.status.published",
      "workorder.status.assigned",
      "workorder.status.work_done",
      "workorder.status.approved"
    ],
    "notificationEmail": "webhook-alerts@example.com",
    "modelProperties": [],
    "isIntegrationOnly": false,
    "createdAt": "2025-01-15T10:30:00Z",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

> **Save the secret!** The `secret` field is only returned during creation. Store it securely for signature verification.

---

## List Webhooks

Retrieve a paginated list of webhooks.

### Request

**GET** `/api/v1/webhooks`

**Headers:**
- `Authorization: Bearer {access_token}` (required)

**Query Parameters:**

### Example Requests

  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?status=active" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?search=production&sortBy=createdAt&sortDirection=DESC" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?fields=id,webhookId,url,status,events" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  

### Response

**Status**: `200 OK`

```json
{
  "metadata": {
    "timestamp": "2025-01-15T11:00:00Z",
    "count": 2,
    "total": 2
  },
  "result": [
    {
      "id": 123,
      "webhookId": "wh_abc123",
      "companyId": 789,
      "userId": 456,
      "url": "https://your-endpoint.com/webhooks",
      "method": "post",
      "status": "active",
      "secret": "01999f51-5c66-4449-b441-6b4a053fee6a",
      "events": ["workorder.status.published", "workorder.status.assigned"],
      "notificationEmail": "alerts@example.com",
      "modelProperties": [],
      "isIntegrationOnly": false,
      "createdAt": "2025-01-15T10:00:00Z",
      "updatedAt": "2025-01-15T10:00:00Z"
    },
    {
      "id": 124,
      "webhookId": "wh_def456",
      "companyId": 789,
      "userId": 456,
      "url": "https://staging.example.com/webhooks",
      "method": "post",
      "status": "inactive",
      "secret": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "events": ["workorder.status.work_done"],
      "notificationEmail": "staging@example.com",
      "modelProperties": [],
      "isIntegrationOnly": false,
      "createdAt": "2025-01-14T15:00:00Z",
      "updatedAt": "2025-01-15T09:00:00Z"
    }
  ]
}
```

---

## Get Webhook Details

Retrieve detailed information about a specific webhook.

### Request

**GET** `/api/v1/webhooks/{webhookId}`

**Headers:**
- `Authorization: Bearer {access_token}` (required)

**Path Parameters:**
- `webhookId` (string, required): Unique webhook identifier

**Query Parameters:**

### Example Requests

  
    ```bash
    curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123?webhookAttribute=header" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  

### Response

**Status**: `200 OK`

```json
{
  "metadata": {
    "timestamp": "2025-01-15T11:00:00Z"
  },
  "result": {
    "id": 123,
    "webhookId": "wh_abc123",
    "companyId": 789,
    "userId": 456,
    "url": "https://your-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "secret": "01999f51-5c66-4449-b441-6b4a053fee6a",
    "events": [
      "workorder.status.published",
      "workorder.status.assigned"
    ],
    "notificationEmail": "alerts@example.com",
    "modelProperties": [],
    "isIntegrationOnly": false,
    "createdAt": "2025-01-15T10:00:00Z",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

---

## Update Webhook

Update an existing webhook configuration. Only include fields you want to change.

### Request

**PUT** `/api/v1/webhooks/{webhookId}`

**Headers:**
- `Authorization: Bearer {access_token}` (required)
- `Content-Type: application/json` (required)

**Path Parameters:**
- `webhookId` (string, required): Unique webhook identifier

**Body Parameters** (all optional):

",
      description: "Updated array of event names (replaces existing list)",
      required: false
    },
    "secret": {
      type: "string (UUID)",
      description: "Updated secret for signature verification",
      required: false
    },
    "notificationEmail": {
      type: "string (email)",
      description: "Updated notification email",
      required: false
    },
    "webhookAttribute": {
      type: "object",
      description: "Updated custom headers",
      required: false
    }
  }}
/>

### Example Requests

  
    ```bash
    curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "url": "https://new-endpoint.com/webhooks"
      }'
    ```
  
  
    ```bash
    curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "status": "inactive"
      }'
    ```
  
  
    ```bash
    curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "events": [
          "workorder.status.published",
          "workorder.status.assigned",
          "workorder.status.work_done",
          "workorder.status.approved"
        ]
      }'
    ```
  
  
    ```bash
    curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "webhookAttribute": {
          "header": {
            "X-Environment": "production",
            "X-Version": "v2"
          }
        }
      }'
    ```
  

### Response

**Status**: `200 OK`

```json
{
  "metadata": {
    "timestamp": "2025-01-15T11:30:00Z"
  },
  "result": {
    "id": 123,
    "webhookId": "wh_abc123",
    "companyId": 789,
    "userId": 456,
    "url": "https://new-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "secret": "01999f51-5c66-4449-b441-6b4a053fee6a",
    "events": [
      "workorder.status.published",
      "workorder.status.assigned"
    ],
    "notificationEmail": "alerts@example.com",
    "modelProperties": [],
    "isIntegrationOnly": false,
    "createdAt": "2025-01-15T10:00:00Z",
    "updatedAt": "2025-01-15T11:30:00Z"
  }
}
```

---

## Delete Webhook

Permanently delete a webhook configuration. Delivery logs are preserved.

### Request

**DELETE** `/api/v1/webhooks/{webhookId}`

**Headers:**
- `Authorization: Bearer {access_token}` (required)

**Path Parameters:**
- `webhookId` (string, required): Unique webhook identifier

### Example Request

```bash
curl -X DELETE https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Response

**Status**: `200 OK`

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z"
  },
  "result": {
    "id": 123,
    "webhookId": "wh_abc123",
    "companyId": 789,
    "userId": 456,
    "url": "https://your-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "secret": "01999f51-5c66-4449-b441-6b4a053fee6a",
    "events": ["workorder.status.published"],
    "notificationEmail": "alerts@example.com",
    "modelProperties": [],
    "isIntegrationOnly": false,
    "createdAt": "2025-01-15T10:00:00Z",
    "updatedAt": "2025-01-15T10:00:00Z"
  }
}
```

> **Irreversible**: Deleted webhooks cannot be recovered. Consider archiving (`status: "archived"`) instead if you want to preserve the configuration.

---

## Delete Webhook Attribute

Remove a specific custom header or legacy field mapping.

### Request

**DELETE** `/api/v1/webhooks/{webhookId}/{attributeType}/{attributeName}`

**Headers:**
- `Authorization: Bearer {access_token}` (required)

**Path Parameters:**
- `webhookId` (string, required): Unique webhook identifier
- `attributeType` (string, required): Type of attribute: `header`, `legacy_field`
- `attributeName` (string, required): Name of the attribute to delete

### Example Request

```bash
# Delete custom header
curl -X DELETE https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123/header/X-Custom-ID \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Response

**Status**: `200 OK`

```json
{
  "message": "Webhook attribute successfully removed"
}
```

---

## Error Responses

### 400 Bad Request

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "path": "/api/v1/webhooks"
  },
  "errors": [
    {
      "code": 400,
      "message": "Invalid request: 'url' must be a valid HTTPS URL"
    }
  ],
  "result": {}
}
```

### 401 Unauthorized

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "path": "/api/v1/webhooks"
  },
  "errors": [
    {
      "code": 401,
      "message": "Invalid or expired access token"
    }
  ],
  "result": {}
}
```

### 404 Not Found

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "path": "/api/v1/webhooks/wh_invalid"
  },
  "errors": [
    {
      "code": 404,
      "message": "Webhook not found"
    }
  ],
  "result": {}
}
```

---

## Code Examples

### Complete CRUD Operations

```javascript
class WebhookManager {
  constructor(accessToken) {
    this.accessToken = accessToken;
    this.baseUrl = 'https://api-sandbox.fndev.net';
  }
  
  async create(config) {
    const response = await fetch(`${this.baseUrl}/api/v1/webhooks`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(config)
    });
    return await response.json();
  }
  
  async list(filters = {}) {
    const params = new URLSearchParams(filters);
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks?${params}`,
      {
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    return await response.json();
  }
  
  async get(webhookId) {
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks/${webhookId}`,
      {
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    return await response.json();
  }
  
  async update(webhookId, updates) {
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks/${webhookId}`,
      {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updates)
      }
    );
    return await response.json();
  }
  
  async delete(webhookId) {
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks/${webhookId}`,
      {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    return await response.json();
  }
}

// Usage
const manager = new WebhookManager(accessToken);

// Create
const webhook = await manager.create({
  url: 'https://example.com/webhooks',
  method: 'post',
  status: 'active',
  events: ['workorder.status.published']
});

// List
const webhooks = await manager.list({ status: 'active' });

// Get
const details = await manager.get('wh_abc123');

// Update
const updated = await manager.update('wh_abc123', {
  status: 'inactive'
});

// Delete
const deleted = await manager.delete('wh_abc123');
```

---

---

### undefined
URL: /docs/webhooks/concepts/delivery

# Webhooks: undefined
URL: /docs/webhooks/concepts/delivery
Source: content/docs/webhooks/concepts/delivery.mdx

---
title: Delivery Mechanics
description: How webhooks are delivered, retry logic with exponential backoff, message queuing, and automatic deactivation policies.
---

## Delivery Flow

```mermaid
sequenceDiagram
    participant Event as Event Occurs
    participant Queue as Message Queue
    participant Delivery as Delivery Service
    participant Your as Your Endpoint
    participant DLQ as Dead Letter Queue
    
    Event->>Queue: Enqueue webhook job
    Queue->>Delivery: Pop job for delivery
    Delivery->>Your: POST webhook payload
    
    alt 2xx Response
        Your-->>Delivery: 200 OK
        Delivery->>Queue: Mark success, log delivery
    else Non-2xx or Timeout
        Your-->>Delivery: 500 Error
        Delivery->>Queue: Requeue with delay
        Note over Queue: Exponential backoff
    end
    
    alt After Max Retries
        Queue->>DLQ: Move to dead letter queue
        DLQ->>Delivery: Available for manual retry
    end
```

---

## Delivery Lifecycle

### Event Triggered

When an event occurs in Field Nation (e.g., work order published), the system identifies all webhooks subscribed to that event.

### Job Creation

For each subscribed webhook, a delivery job is created and added to the message queue with:
- Webhook configuration
- Event payload
- Delivery metadata
- Retry counter (starts at 0)

### Immediate Delivery Attempt

The delivery service picks up the job and sends an HTTP POST/PUT request to your endpoint:

```http
POST /webhooks/fieldnation HTTP/1.1
Host: your-endpoint.com
Content-Type: application/json
x-fn-signature: sha256=abc123...
x-fn-webhook-id: wh_abc123
x-fn-event-name: workorder.created
x-fn-delivery-id: del_xyz789
x-fn-timestamp: 2025-01-15T10:30:00Z

{webhook payload}
```

### Response Evaluation

Your endpoint's response determines the next step:

| Response | Action |
|----------|--------|
| **2xx (Success)** | Mark delivery successful, log, done |
| **404, 410** | Hard failure, skip retries, log error |
| **Other 4xx** | Client error, skip retries, log error |
| **5xx** | Server error, schedule retry with backoff |
| **Timeout (30s)** | Network issue, schedule retry |
| **Connection Error** | Network issue, schedule retry |

### Retry or Complete

- **Success (2xx)**: Job complete, delivery logged
- **Hard failure (404/410)**: Job failed permanently, no retry
- **Retriable error**: Job requeued with exponential delay

---

## Retry Strategy

Field Nation uses **exponential backoff** to retry failed deliveries, giving your system time to recover from temporary issues.

### Retry Schedule

| Attempt | Delay After Previous | Total Time Elapsed | Notes |
|---------|---------------------|-------------------|-------|
| 1 (Initial) | 0 seconds | 0 sec | Immediate |
| 2 | 10 seconds | 10 sec | - |
| 3 | 20 seconds | 30 sec | - |
| 4 | 40 seconds | 1 min 10 sec | - |
| 5 | 80 seconds | 2 min 30 sec | - |
| 6 | 160 seconds | 5 min 10 sec | - |
| 7 | 320 seconds | 10 min 30 sec | - |
| 8 | 640 seconds | 21 min 10 sec | Final attempt |

### Dynamic Retry Count

The maximum retry attempts are **dynamic** based on your webhook's success rate:

- **High success rate (>95%)**: Up to 7 retries
- **Medium success rate (80-95%)**: Up to 5 retries
- **Low success rate (&lt;80%)**: Minimum 3 retries

This adaptive approach:
- ✅ Rewards reliable endpoints with more retry attempts
- ⚠️ Reduces load on consistently failing endpoints
- 🎯 Optimizes resource usage

> [INFO] **Initial Setup**: New webhooks start with 7 retry attempts. Success rate is calculated after ~100 deliveries.

### Backoff Formula

Each retry doubles the previous delay:

```javascript
function calculateDelay(attemptNumber) {
  const baseDelay = 10; // seconds
  return baseDelay * Math.pow(2, attemptNumber - 2);
}

// Attempt 2: 10 * 2^0 = 10 seconds
// Attempt 3: 10 * 2^1 = 20 seconds
// Attempt 4: 10 * 2^2 = 40 seconds
// ...
```

---

## Hard Failures (No Retry)

Certain errors indicate permanent problems and skip retries entirely:

### 404 Not Found

```http
HTTP/1.1 404 Not Found
```

**Meaning**: Your endpoint doesn't exist or path is incorrect

**Action**: No retry, delivery marked as permanently failed

**Fix**: Update webhook URL configuration

---

### 410 Gone

```http
HTTP/1.1 410 Gone
```

**Meaning**: Endpoint permanently removed

**Action**: No retry, delivery marked as permanently failed

**Fix**: Delete webhook or update URL

---

## Message Queue Architecture

Field Nation uses Redis-based queuing with multiple priority levels:

### Queue Priority

1. **High Priority**: Critical events (payment, approval)
2. **Normal Priority**: Standard events (status changes)
3. **Low Priority**: Non-critical events (messages, uploads)

### Queue Management

```plaintext
┌─────────────────┐
│  Event Occurs   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Create Job     │
│  - Payload      │
│  - Retry: 0     │
│  - Priority     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Message Queue  │
│  (Redis)        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Delivery Worker │
│ Pick & Deliver  │
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
    ▼         ▼
  Success   Failure
    │         │
    │         ▼
    │    ┌─────────┐
    │    │ Requeue │
    │    │ + Delay │
    │    └────┬────┘
    │         │
    │    Max retries?
    │         │
    │    ┌────┴────┐
    │    │   Yes   │   No
    │    ▼         ▼
    │   DLQ    Retry Queue
    │    │
    └────┴─> Delivery Log
```

### Worker Pool

- **Multiple workers**: Parallel delivery processing
- **Rate limiting**: Prevents overwhelming your endpoint
- **Timeout handling**: 30-second max per request

---

## Dead Letter Queue (DLQ)

After exhausting all retries, failed deliveries move to the Dead Letter Queue for manual intervention.

### What Goes to DLQ?

- Deliveries that failed all retry attempts
- Events that repeatedly timeout
- Persistent 5xx errors from your endpoint

### Manual Retry

You can manually retry deliveries via API or UI:

**Via API:**

```bash
curl -X PATCH https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/del_xyz789/retry \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T11:00:00Z"
  },
  "result": {
    "job_id": "job_abc123"
  }
}
```

**Via UI:**

![Delivery Log Retry](/docs/webhook-v3/delivery-log-retry.png)

This creates a new delivery job that you can track in delivery logs.

---

## Automatic Deactivation

To prevent infinite failed delivery attempts, webhooks are automatically deactivated under certain conditions:

### Deactivation Policy

- **Trigger**: 7 consecutive days of failed deliveries
- **Action**: Webhook status changes from `active` to `inactive`
- **Notification**: Email sent to `notificationEmail` (if configured)

### What Happens When Deactivated?

- ❌ No new delivery attempts
- ❌ Events are not queued
- ✅ Webhook configuration preserved
- ✅ Historical delivery logs remain accessible

### Reactivation

Update webhook status to `active` after fixing endpoint issues:

```bash
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "status": "active"
  }'
```

> **Important**: Fix the underlying issues before reactivating. Repeated deactivations may result in permanent suspension.

---

## Delivery Logging

Every delivery attempt is logged with complete details:

### Log Contents

```json
{
  "deliveryId": "del_xyz789",
  "webhookId": "wh_abc123",
  "workOrderId": 12345,
  "eventName": "workorder.status.published",
  "deliveryStatus": 200,
  "deliveryAttempt": 1,
  "requestUrl": "https://your-endpoint.com/webhooks",
  "requestMethod": "POST",
  "requestHeaders": {
    "content-type": "application/json",
    "x-fn-signature": "sha256=...",
    "x-fn-webhook-id": "wh_abc123"
  },
  "requestBody": "{...full payload...}",
  "responseStatus": 200,
  "responseHeaders": {
    "content-type": "text/plain"
  },
  "responseBody": "OK",
  "responseTime": 145,
  "createdAt": "2025-01-15T10:30:00Z"
}
```

### Accessing Logs

Via API:

```bash
# List delivery logs
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"

# Get specific delivery details
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/del_xyz789 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

Via UI:
- Navigate to [Webhooks Dashboard](https://ui-sandbox.fndev.net/integrations/webhooks)
- Select your webhook
- Click "Delivery Logs" tab

![Delivery Logs Dashboard](/docs/webhook-v3/delivery-logs.png)

[Learn more about monitoring →](/docs/webhooks/guides/monitoring)

---

## Delivery Best Practices

### Respond Quickly (5%)
- Increased retry attempts
- Slow response times (>2 seconds)
- Webhook deactivation

```javascript
// Example CloudWatch metric
await cloudwatch.putMetricData({
  Namespace: 'Webhooks',
  MetricData: [{
    MetricName: 'DeliveryFailures',
    Value: failureCount,
    Unit: 'Count',
    Timestamp: new Date()
  }]
});
```

---

## Delivery Guarantees

### At-Least-Once Delivery

Field Nation guarantees **at-least-once delivery**:

- ✅ Every event will be delivered at least once
- ⚠️ Events may be delivered more than once
- 🎯 Implement idempotency to handle duplicates

### Ordering

Events are delivered **approximately** in order, but strict ordering is not guaranteed:

- Events from the same work order usually arrive in sequence
- Network latency and retries can cause reordering
- Don't rely on event order for critical logic

### Example Handling Order-Sensitive Events

```javascript
async function processWorkOrderEvent(payload) {
  const { workOrderId, timestamp, data } = payload;
  
  // Fetch current work order state
  const currentState = await getWorkOrder(workOrderId);
  
  // Check if event is stale (older than current state)
  if (new Date(timestamp) < new Date(currentState.updatedAt)) {
    console.log(`Stale event ignored: ${payload.eventId}`);
    return;
  }
  
  // Process the event
  await updateWorkOrder(workOrderId, data);
}
```

---

## Troubleshooting Delivery Issues

### Deliveries Not Arriving?

  
    Ensure webhook is `active`:
    
    ```bash
    curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    Test publicly accessible:
    
    ```bash
    curl -X POST https://your-endpoint.com/webhooks \
      -H "Content-Type: application/json" \
      -d '{"test": "data"}'
    ```
  
  
    Check for error patterns:
    
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?deliveryStatus=500" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    Ensure valid HTTPS certificate:
    
    ```bash
    curl -v https://your-endpoint.com
    ```
    
    Look for SSL verification errors.
  

### Common Delivery Errors

| Error | Cause | Solution |
|-------|-------|----------|
| **Connection timeout** | Endpoint slow to respond | Optimize response time, use async processing |
| **SSL certificate error** | Invalid/expired certificate | Renew SSL certificate |
| **DNS resolution failed** | Domain doesn't resolve | Check DNS configuration |
| **Connection refused** | Server not listening on port | Verify server is running, check firewall |
| **502 Bad Gateway** | Reverse proxy misconfiguration | Check nginx/load balancer config |

[Complete troubleshooting guide →](/docs/webhooks/troubleshooting/delivery-failures)

---

---

### undefined
URL: /docs/webhooks/concepts/events

# Webhooks: undefined
URL: /docs/webhooks/concepts/events
Source: content/docs/webhooks/concepts/events.mdx

---
title: Webhook Events
description: Complete catalog of all 33 webhook events covering the work order lifecycle, status changes, and activity events.
---

## Event Categories

Events are organized into three main categories:

  
    **13 events** - Core work order actions like creation, routing, assignment, and completion.
  
  
    **19 events** - Work order status transitions (draft, published, assigned, approved, paid, etc.)
  
  
    Overlaps with lifecycle - Messages, uploads, task updates, schedule changes, and tags.
  

---

## Complete Event Catalog

### Lifecycle Events

These events track the primary actions in a work order's journey:

#### `workorder.created`

**Triggered when**: A new work order is created in the system

**Typical Use Cases**:
- Log new work orders in your database
- Trigger initial workflows or notifications
- Auto-assign to preferred providers based on criteria

**Event Name**: `workorder.created`

**Model**: `WorkOrder`

```json
{
  "eventName": "workorder.created",
  "eventId": "evt_abc123",
  "workOrderId": 12345,
  "timestamp": "2025-01-15T10:30:00Z",
  "data": {
    "id": 12345,
    "title": "Router Installation",
    "status": "draft",
    // ... full work order details
  }
}
```

---

#### `workorder.routed`

**Triggered when**: A work order is routed to specific provider(s)

**Typical Use Cases**:
- Notify selected providers
- Track routing patterns
- Update dispatch boards

**Event Name**: `workorder.routed`

**Model**: `WorkOrder`

---

#### `workorder.requested`

**Triggered when**: A provider requests assignment to a work order

**Typical Use Cases**:
- Notify managers of provider interest
- Auto-approve based on provider rating/history
- Track request patterns

**Event Name**: `workorder.requested`

**Model**: `WorkOrder`

---

#### `workorder.declined`

**Triggered when**: A provider declines a work order assignment

**Typical Use Cases**:
- Alert managers to find replacement
- Re-route to other providers
- Track decline reasons

**Event Name**: `workorder.declined`

**Model**: `WorkOrder`

---

#### `workorder.undeclined`

**Triggered when**: A declined assignment is reversed

**Typical Use Cases**:
- Update provider availability
- Re-evaluate assignment
- Log status reversals

**Event Name**: `workorder.undeclined`

**Model**: `WorkOrder`

---

#### `workorder.task_completed`

**Triggered when**: A task within a work order is marked complete

**Typical Use Cases**:
- Track task-level progress
- Calculate completion percentage
- Trigger next-step workflows

**Event Name**: `workorder.task_completed`

**Model**: `WorkOrder`

---

#### `workorder.task_incomplete`

**Triggered when**: A task is marked as incomplete

**Typical Use Cases**:
- Alert managers to incomplete tasks
- Adjust work order timeline
- Track quality issues

**Event Name**: `workorder.task_incomplete`

**Model**: `WorkOrder`

---

#### `workorder.provider_upload`

**Triggered when**: A provider uploads a document (photo, PDF, etc.)

**Typical Use Cases**:
- Archive documents in your system
- Trigger review workflows
- Notify stakeholders of completion evidence

**Event Name**: `workorder.provider_upload`

**Model**: `WorkOrder`

---

#### `workorder.message_posted`

**Triggered when**: A message is posted or replied to on a work order

**Typical Use Cases**:
- Send email/SMS notifications
- Log communication history
- Alert on specific keywords

**Event Name**: `workorder.message_posted`

**Model**: `WorkOrder`

---

#### `workorder.custom_field_value_updated`

**Triggered when**: A custom field value is changed

**Typical Use Cases**:
- Sync custom data to external systems
- Trigger workflows based on field values
- Track data changes

**Event Name**: `workorder.custom_field_value_updated`

**Model**: `WorkOrder`

---

#### `workorder.schedule_updated`

**Triggered when**: The work order schedule is modified

**Typical Use Cases**:
- Update calendar systems
- Notify providers and clients of changes
- Track schedule volatility

**Event Name**: `workorder.schedule_updated`

**Model**: `WorkOrder`

---

#### `workorder.tag_added`

**Triggered when**: A tag is added to a work order

**Typical Use Cases**:
- Categorize work orders dynamically
- Trigger tag-based routing
- Track work order classifications

**Event Name**: `workorder.tag_added`

**Model**: `WorkOrder`

---

#### `workorder.tag_removed`

**Triggered when**: A tag is removed from a work order

**Typical Use Cases**:
- Update categorizations
- Log tag history
- Sync taxonomy changes

**Event Name**: `workorder.tag_removed`

**Model**: `WorkOrder`

---

### Status Change Events

These events fire when a work order transitions between statuses:

#### `workorder.status.draft`

**Triggered when**: Work order status changes to **Draft**

**Description**: Initial state when a work order is created but not yet published

**Event Name**: `workorder.status.draft`

**Model**: `WorkOrder`

---

#### `workorder.status.routed`

**Triggered when**: Work order status changes to **Routed**

**Description**: Work order has been routed to specific provider(s)

**Event Name**: `workorder.status.routed`

**Model**: `WorkOrder`

---

#### `workorder.status.published`

**Triggered when**: Work order status changes to **Published**

**Description**: Work order is published to the marketplace and visible to providers

**Typical Use Cases**:
- Notify provider network
- Start SLA timers
- Update dispatch boards

**Event Name**: `workorder.status.published`

**Model**: `WorkOrder`

---

#### `workorder.status.confirmed`

**Triggered when**: Work order status changes to **Confirmed**

**Description**: Provider has confirmed they will take the assignment

**Event Name**: `workorder.status.confirmed`

**Model**: `WorkOrder`

---

#### `workorder.status.assigned`

**Triggered when**: Work order status changes to **Assigned**

**Description**: Work order has been assigned to a provider

**Typical Use Cases**:
- Notify provider of assignment
- Update dispatch board
- Sync to scheduling systems
- Start work order timeline

**Event Name**: `workorder.status.assigned`

**Model**: `WorkOrder`

---

#### `workorder.status.assigned_cancelled`

**Triggered when**: Work order status changes to **Assigned Cancelled**

**Description**: An assigned work order has been cancelled

**Event Name**: `workorder.status.assigned_cancelled`

**Model**: `WorkOrder`

---

#### `workorder.status.at_risk`

**Triggered when**: Work order status changes to **At Risk**

**Description**: Work order is flagged as at risk of not completing on time

**Typical Use Cases**:
- Alert managers
- Escalate to senior technicians
- Prepare backup plans

**Event Name**: `workorder.status.at_risk`

**Model**: `WorkOrder`

---

#### `workorder.status.delayed`

**Triggered when**: Work order status changes to **Delayed**

**Description**: Work order is delayed beyond scheduled time

**Typical Use Cases**:
- Notify clients of delay
- Adjust schedules
- Track on-time performance

**Event Name**: `workorder.status.delayed`

**Model**: `WorkOrder`

---

#### `workorder.status.on_my_way`

**Triggered when**: Work order status changes to **On My Way**

**Description**: Provider is en route to the work location

**Typical Use Cases**:
- Notify client of provider ETA
- Track travel time
- Update real-time dashboards

**Event Name**: `workorder.status.on_my_way`

**Model**: `WorkOrder`

---

#### `workorder.status.checked_in`

**Triggered when**: Work order status changes to **Checked In**

**Description**: Provider has arrived on site and checked in

**Typical Use Cases**:
- Log start time
- Start work timer
- Notify stakeholders work has begun

**Event Name**: `workorder.status.checked_in`

**Model**: `WorkOrder`

---

#### `workorder.status.checked_out`

**Triggered when**: Work order status changes to **Checked Out**

**Description**: Provider has finished on-site work and checked out

**Typical Use Cases**:
- Calculate work duration
- Trigger documentation review
- Update time tracking systems

**Event Name**: `workorder.status.checked_out`

**Model**: `WorkOrder`

---

#### `workorder.status.work_done`

**Triggered when**: Work order status changes to **Work Done**

**Description**: Provider has completed the work and submitted for approval

**Typical Use Cases**:
- Trigger approval workflows
- Notify managers/clients
- Calculate completion metrics

**Event Name**: `workorder.status.work_done`

**Model**: `WorkOrder`

---

#### `workorder.status.approved`

**Triggered when**: Work order status changes to **Approved**

**Description**: Buyer has approved the completed work

**Typical Use Cases**:
- Generate invoices
- Release payments
- Close work orders in external systems
- Calculate approval times

**Event Name**: `workorder.status.approved`

**Model**: `WorkOrder`

---

#### `workorder.status.paid`

**Triggered when**: Work order status changes to **Paid**

**Description**: Provider has been paid for the work order

**Typical Use Cases**:
- Update accounting systems
- Archive completed work orders
- Calculate payment cycles
- Generate financial reports

**Event Name**: `workorder.status.paid`

**Model**: `WorkOrder`

---

#### `workorder.status.cancelled`

**Triggered when**: Work order status changes to **Cancelled**

**Description**: Work order has been cancelled before completion

**Typical Use Cases**:
- Update availability calendars
- Notify affected parties
- Track cancellation reasons
- Calculate cancellation rates

**Event Name**: `workorder.status.cancelled`

**Model**: `WorkOrder`

---

#### `workorder.status.deleted`

**Triggered when**: Work order status changes to **Deleted**

**Description**: Work order has been deleted from the system

**Event Name**: `workorder.status.deleted`

**Model**: `WorkOrder`

---

#### `workorder.status.postponed`

**Triggered when**: Work order status changes to **Postponed**

**Description**: Work order has been postponed to a future date

**Typical Use Cases**:
- Update schedules
- Notify providers of new dates
- Track postponement patterns

**Event Name**: `workorder.status.postponed`

**Model**: `WorkOrder`

---

#### `workorder.problem_reported`

**Triggered when**: A problem is reported or reopened on a work order

**Description**: Issue flagged that requires attention or resolution

**Typical Use Cases**:
- Alert quality assurance teams
- Escalate to managers
- Track problem frequency
- Trigger resolution workflows

**Event Name**: `workorder.problem_reported`

**Model**: `WorkOrder`

---

#### `workorder.problem_resolved`

**Triggered when**: A reported problem is resolved

**Description**: Previously reported issue has been addressed

**Typical Use Cases**:
- Close problem tickets
- Calculate resolution times
- Resume normal workflows
- Update quality metrics

**Event Name**: `workorder.problem_resolved`

**Model**: `WorkOrder`

---

#### `workorder.part_updated`

**Triggered when**: Parts/materials on a work order are updated

**Description**: Inventory or parts list has been modified

**Typical Use Cases**:
- Sync inventory systems
- Track parts usage
- Update cost estimates
- Manage supply chain

**Event Name**: `workorder.part_updated`

**Model**: `WorkOrder`

---

## Event Filtering

When creating a webhook, you can subscribe to:

### All Events

```json
{
  "events": [
    "workorder.created",
    "workorder.routed",
    // ... all 33 events
  ]
}
```

### Specific Categories

**Lifecycle events only:**

```json
{
  "events": [
    "workorder.created",
    "workorder.routed",
    "workorder.requested",
    "workorder.declined",
    "workorder.task_completed"
  ]
}
```

**Status changes only:**

```json
{
  "events": [
    "workorder.status.published",
    "workorder.status.assigned",
    "workorder.status.checked_in",
    "workorder.status.work_done",
    "workorder.status.approved",
    "workorder.status.paid"
  ]
}
```

### Critical Events

For minimal integration, start with these high-value events:

```json
{
  "events": [
    "workorder.status.published",    // Work order available
    "workorder.status.assigned",     // Provider assigned
    "workorder.status.work_done",    // Work completed
    "workorder.status.approved"      // Ready for payment
  ]
}
```

---

## List Available Events via API

Retrieve the complete, up-to-date event catalog programmatically:

```bash
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/events \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T10:30:00Z"
  },
  "result": [
    {
      "name": "workorder.created",
      "label": "Work Order created",
      "description": "Triggered when a work order is created.",
      "model": "WorkOrder"
    },
    {
      "name": "workorder.status.published",
      "label": "Work Order status published",
      "description": "Triggered when a work order status changes to published.",
      "model": "WorkOrder"
    }
    // ... all 33 events
  ]
}
```

### Filter by Model

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/events?model=WorkOrder" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

---

## Event Naming Convention

Events follow a consistent pattern:

```plaintext
{resource}.{action or status}.{optional_sub_status}
```

**Examples:**

- `workorder.created` - Resource: workorder, Action: created
- `workorder.status.published` - Resource: workorder, Category: status, Status: published
- `workorder.task_completed` - Resource: workorder, Action: task_completed

---

## Best Practices

### Start Small, Expand Later

### Begin with Core Events

Subscribe to 4-6 critical events initially:
- `workorder.created`
- `workorder.status.assigned`
- `workorder.status.work_done`
- `workorder.status.approved`

### Test Thoroughly

Verify your system handles events correctly before adding more.

### Add Events Incrementally

Expand to additional events as you build new features.

### Filter Strategically

Don't subscribe to events you won't use:

- ❌ **Bad**: Subscribe to all 33 events "just in case"
- ✅ **Good**: Subscribe only to events your system processes

Unnecessary events increase:
- Processing overhead
- Delivery log volume
- Potential for bugs

### Document Your Event Handling

Maintain internal documentation:

```markdown
| Event                       | Handler          | Purpose                 |
|-----------------------------|------------------|-------------------------|
| workorder.status.published  | publishHandler() | Notify provider network |
| workorder.status.assigned   | assignHandler()  | Update dispatch board   |
| workorder.status.work_done  | completeHandler()| Trigger approval flow   |
```

---

---

### undefined
URL: /docs/webhooks/concepts/payload-structure

# Webhooks: undefined
URL: /docs/webhooks/concepts/payload-structure
Source: content/docs/webhooks/concepts/payload-structure.mdx

---
title: Payload Structure
description: Understanding webhook payloads - standard fields, work order data, headers, and how to parse webhook requests.
---

## HTTP Request Structure

Field Nation sends webhooks as HTTP POST or PUT requests (configurable) to your endpoint:

```http
POST /webhooks/fieldnation HTTP/1.1
Host: your-endpoint.com
Content-Type: application/json
x-fn-signature: sha256=abc123...
x-fn-webhook-id: wh_abc123def456
x-fn-event-name: workorder.status.published
x-fn-delivery-id: del_xyz789
x-fn-timestamp: 2025-01-15T10:30:00Z

{
  "eventName": "workorder.status.published",
  "eventId": "evt_abc123",
  "workOrderId": 12345,
  "timestamp": "2025-01-15T10:30:00Z",
  "data": {
    // ... complete work order object
  }
}
```

---

## Standard Headers

Every webhook request includes these headers:

`",
      required: true
    },
    "x-fn-webhook-id": {
      type: "string",
      description: "Unique identifier of the webhook configuration that triggered this delivery",
      required: true
    },
    "x-fn-event-name": {
      type: "string",
      description: "Name of the event (e.g., `workorder.created`, `workorder.status.published`)",
      required: true
    },
    "x-fn-delivery-id": {
      type: "string",
      description: "Unique identifier for this specific delivery attempt. Use for idempotency and debugging",
      required: true
    },
    "x-fn-timestamp": {
      type: "string",
      description: "ISO 8601 timestamp when the webhook was sent",
      required: true
    },
    "content-type": {
      type: "string",
      description: "Always `application/json`",
      required: true
    }
  }}
/>

### Custom Headers

You can configure additional headers when creating the webhook:

```json
{
  "webhookAttribute": {
    "header": {
      "Authorization": "Bearer your-api-token",
      "X-Custom-ID": "your-identifier"
    }
  }
}
```

> **Reserved Prefix**: Headers cannot start with `x-fn-` as this prefix is reserved for Field Nation system headers.

---

## JSON Payload Structure

### Top-Level Fields

### Example Complete Payload

```json
{
  "eventName": "workorder.status.published",
  "eventId": "evt_4a7f2b1c",
  "workOrderId": 12345,
  "timestamp": "2025-01-15T10:30:00.000Z",
  "data": {
    "id": 12345,
    "title": "Router Installation - Site 42",
    "description": "Install and configure Cisco router",
    "status": "published",
    "schedule": {
      "serviceWindow": {
        "start": "2025-01-20T09:00:00Z",
        "end": "2025-01-20T17:00:00Z",
        "mode": "hours"
      }
    },
    "location": {
      "address1": "123 Main Street",
      "city": "San Francisco",
      "state": "CA",
      "zip": "94105",
      "coordinates": {
        "latitude": 37.7749,
        "longitude": -122.4194
      }
    },
    "pay": {
      "type": "fixed",
      "amount": 250.00,
      "currency": "USD"
    },
    "buyer": {
      "id": 456,
      "name": "Acme Corporation",
      "companyId": 789
    },
    "tags": ["priority", "router", "installation"],
    "customFields": {
      "ticketNumber": "INC-12345",
      "customerPO": "PO-98765"
    },
    "createdAt": "2025-01-15T09:00:00Z",
    "updatedAt": "2025-01-15T10:30:00Z"
    // ... many more fields
  }
}
```

---

## Work Order Data Object

The `data` field contains the complete work order object, which matches the structure returned by the [REST API](/docs/rest-api/introduction).

### Key Fields Overview

  
    ```json
    {
      "id": 12345,
      "title": "Router Installation - Site 42",
      "description": "Install and configure Cisco router",
      "status": "published",
      "type": "installation",
      "priority": "normal",
      "tags": ["priority", "router"],
      "customFields": {
        "ticketNumber": "INC-12345"
      },
      "createdAt": "2025-01-15T09:00:00Z",
      "updatedAt": "2025-01-15T10:30:00Z"
    }
    ```
  
  
    ```json
    {
      "schedule": {
        "serviceWindow": {
          "start": "2025-01-20T09:00:00Z",
          "end": "2025-01-20T17:00:00Z",
          "mode": "hours"
        },
        "estimatedHours": 3
      },
      "location": {
        "address1": "123 Main Street",
        "address2": "Suite 100",
        "city": "San Francisco",
        "state": "CA",
        "zip": "94105",
        "country": "US",
        "coordinates": {
          "latitude": 37.7749,
          "longitude": -122.4194
        },
        "notes": "Enter through main lobby"
      }
    }
    ```
  
  
    ```json
    {
      "pay": {
        "type": "fixed",
        "amount": 250.00,
        "currency": "USD",
        "hourlyRate": null
      },
      "expenses": {
        "mileage": {
          "allowed": true,
          "rate": 0.655,
          "units": "miles"
        },
        "additional": {
          "allowed": true,
          "maxAmount": 50.00
        }
      }
    }
    ```
  
  
    ```json
    {
      "buyer": {
        "id": 456,
        "name": "Acme Corporation",
        "companyId": 789
      },
      "provider": {
        "id": 789,
        "name": "John Smith",
        "userId": 1011,
        "rating": 4.8
      },
      "contacts": [
        {
          "name": "Jane Doe",
          "phone": "+1-555-0123",
          "email": "jane@example.com",
          "role": "site_contact"
        }
      ]
    }
    ```
  

> [INFO] **Full Schema**: The complete work order schema includes 100+ fields. Refer to the [REST API documentation](/docs/rest-api/introduction) for the full specification.

---

## Parsing Webhooks

### Essential Parsing Steps

### Read Raw Body

**Critical for signature verification** - read the raw request body before parsing:

```javascript
const express = require('express');
const app = express();

// Use raw body parser
app.use(express.raw({ type: 'application/json' }));

app.post('/webhooks', (req, res) => {
  const rawBody = req.body; // Buffer
  const payload = JSON.parse(rawBody.toString());
  
  // Now you can verify signature with rawBody
  // and work with parsed payload
});
```

### Verify Signature

Always verify the `x-fn-signature` header before processing:

```javascript
const crypto = require('crypto');

function verifySignature(rawBody, signature, secret) {
  const [algorithm, hash] = signature.split('=');
  const expectedHash = crypto
    .createHmac(algorithm, secret)
    .update(rawBody)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(expectedHash),
    Buffer.from(hash)
  );
}
```

### Extract Event Details

```javascript
const {
  eventName,
  eventId,
  workOrderId,
  timestamp,
  data
} = payload;

// Check idempotency
if (await hasProcessedEvent(eventId)) {
  return res.status(200).send('Already processed');
}
```

### Process the Event

```javascript
// Handle based on event type
switch (eventName) {
  case 'workorder.status.published':
    await handlePublished(data);
    break;
  case 'workorder.status.assigned':
    await handleAssigned(data);
    break;
  // ... more handlers
}
```

### Respond Quickly

```javascript
// Acknowledge receipt immediately
res.status(200).send('OK');

// Process asynchronously
processWebhookAsync(payload);
```

---

## Complete Processing Example

```javascript title="webhook-handler.js"
const express = require('express');
const crypto = require('crypto');
const app = express();

// Use raw body for signature verification
app.use(express.raw({ type: 'application/json' }));

app.post('/webhooks/fieldnation', async (req, res) => {
  try {
    // 1. Verify signature
    const signature = req.headers['x-fn-signature'];
    const secret = process.env.WEBHOOK_SECRET;
    
    if (!verifySignature(req.body, signature, secret)) {
      return res.status(401).send('Invalid signature');
    }
    
    // 2. Parse payload
    const payload = JSON.parse(req.body.toString());
    const {
      eventName,
      eventId,
      workOrderId,
      timestamp,
      data
    } = payload;
    
    // 3. Check idempotency
    if (await hasProcessedEvent(eventId)) {
      console.log(`Duplicate event: ${eventId}`);
      return res.status(200).send('Already processed');
    }
    
    // 4. Respond immediately (< 5 seconds)
    res.status(200).send('OK');
    
    // 5. Process asynchronously
    await processEventAsync({
      eventName,
      eventId,
      workOrderId,
      timestamp,
      data
    });
    
  } catch (error) {
    console.error('Webhook processing error:', error);
    res.status(500).send('Internal error');
  }
});

function verifySignature(rawBody, signature, secret) {
  if (!signature) return false;
  
  const [algorithm, hash] = signature.split('=');
  const expectedHash = crypto
    .createHmac(algorithm, secret)
    .update(rawBody)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(expectedHash),
    Buffer.from(hash)
  );
}

async function hasProcessedEvent(eventId) {
  // Check your database or cache
  return await redis.exists(`event:${eventId}`);
}

async function processEventAsync(event) {
  // Mark as processing
  await redis.setex(`event:${event.eventId}`, 86400, 'processed');
  
  // Handle based on event type
  switch (event.eventName) {
    case 'workorder.status.published':
      await syncToSalesforce(event.data);
      await notifyProviders(event.data);
      break;
      
    case 'workorder.status.assigned':
      await updateDispatchBoard(event.data);
      await notifyTechnician(event.data);
      break;
      
    case 'workorder.status.work_done':
      await triggerApprovalFlow(event.data);
      break;
      
    case 'workorder.status.approved':
      await generateInvoice(event.data);
      await updateAccounting(event.data);
      break;
  }
}

app.listen(3000);
```

---

## Idempotency

Webhooks may be delivered more than once (due to retries). Always check if you've already processed an event:

### Use eventId for Deduplication

```javascript
// Redis example
async function processWebhook(payload) {
  const key = `webhook:${payload.eventId}`;
  
  // Try to set key with NX (only if not exists)
  const wasSet = await redis.set(key, '1', 'EX', 86400, 'NX');
  
  if (!wasSet) {
    console.log('Duplicate webhook, skipping');
    return;
  }
  
  // Process the webhook
  await handleEvent(payload);
}
```

### Database-Based Tracking

```sql
CREATE TABLE processed_webhooks (
  event_id VARCHAR(255) PRIMARY KEY,
  processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  event_name VARCHAR(255),
  work_order_id INTEGER
);

CREATE INDEX idx_processed_at ON processed_webhooks(processed_at);
```

```javascript
async function hasProcessedEvent(eventId) {
  const result = await db.query(
    'SELECT event_id FROM processed_webhooks WHERE event_id = $1',
    [eventId]
  );
  return result.rows.length > 0;
}

async function markEventProcessed(eventId, eventName, workOrderId) {
  await db.query(
    'INSERT INTO processed_webhooks (event_id, event_name, work_order_id) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING',
    [eventId, eventName, workOrderId]
  );
}
```

---

## Response Requirements

Your endpoint must respond correctly to receive continued deliveries:

### Success Response

```http
HTTP/1.1 200 OK
Content-Type: text/plain

OK
```

> [INFO] **Response Body**: Field Nation doesn't parse the response body. Any 2xx status code indicates success.

### Response Time

- ** **Security**: Never log webhooks in production—they contain sensitive data (PII, financial details, etc.)

---

---

### undefined
URL: /docs/webhooks/concepts/webhook-lifecycle

# Webhooks: undefined
URL: /docs/webhooks/concepts/webhook-lifecycle
Source: content/docs/webhooks/concepts/webhook-lifecycle.mdx

---
title: Webhook Lifecycle
description: Understanding webhook states (active, inactive, archived), transitions, history tracking, and change auditing.
---

## Webhook States

```mermaid
stateDiagram-v2
    [*] --> active: Create (default)
    [*] --> inactive: Create (paused)
    active --> inactive: Pause deliveries
    inactive --> active: Resume deliveries
    active --> archived: Deactivate
    inactive --> archived: Deactivate
    archived --> [*]: Permanent (read-only)
    
    note right of active
        Receiving notifications
        Events queued & delivered
    end note
    
    note right of inactive
        Paused temporarily
        Events not delivered
    end note
    
    note right of archived
        Permanently deactivated
        Cannot be reactivated
    end note
```

---

## Active State

**Definition**: Webhook is fully operational and receiving event notifications.

### Characteristics

- ✅ Events are queued for delivery
- ✅ Delivery attempts made according to retry policy
- ✅ Delivery logs generated
- ✅ Can be modified (events, URL, etc.)
- ✅ Can transition to inactive or archived

### When to Use

- **Production webhooks**: Actively processing events
- **Monitoring**: Need real-time updates
- **Integration running**: System operational

### Creating Active Webhook

  
    ```bash
    curl -X POST https://api-sandbox.fndev.net/api/v1/webhooks \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "url": "https://your-endpoint.com/webhooks",
        "method": "post",
        "status": "active",
        "events": ["workorder.status.published"]
      }'
    ```
  
  
    1. Navigate to [Webhooks Dashboard](https://ui-sandbox.fndev.net/integrations/webhooks)
    2. Click "Create New"
    3. Fill in configuration
    4. Set **Status** to "Active"
    5. Click "Create"
  

---

## Inactive State

**Definition**: Webhook is temporarily paused and not receiving events.

### Characteristics

- ❌ Events are **not** queued or delivered
- ❌ No delivery attempts made
- ✅ Configuration preserved
- ✅ Historical delivery logs remain accessible
- ✅ Can be modified
- ✅ Can transition to active or archived

### When to Use

- **Maintenance**: Endpoint undergoing updates
- **Temporary issues**: Fixing integration problems
- **Testing**: Paused during development
- **Rate limiting**: Temporarily reduce load

### Common Use Cases

#### Maintenance Window

```javascript
// Pause webhook during deployment
await fetch('https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123', {
  method: 'PUT',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ status: 'inactive' })
});

// Perform deployment...

// Reactivate after deployment
await fetch('https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123', {
  method: 'PUT',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ status: 'active' })
});
```

#### Incident Response

```bash
# Quickly pause webhook during incident
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "inactive"}'
```

### Pausing vs Deleting

> [INFO] **Best Practice**: Use `inactive` for temporary pauses instead of deleting and recreating. This preserves:
- Webhook ID and secret
- Delivery history
- Configuration settings
- Change history

---

## Archived State

**Definition**: Webhook is permanently deactivated and read-only.

### Characteristics

- ❌ Events are **not** delivered
- ❌ Cannot be reactivated (permanent)
- ❌ Cannot be modified
- ✅ Configuration visible (read-only)
- ✅ Historical delivery logs preserved
- ✅ Appears in webhook list with "archived" badge

### When to Use

- **Decommissioned integrations**: Project ended
- **Replaced webhooks**: New version created
- **Historical record**: Keep audit trail
- **Cleanup**: Organize active webhooks

### Archiving a Webhook

  
    ```bash
    curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "status": "archived"
      }'
    ```
    
    > **Irreversible**: Once archived, a webhook cannot be reactivated. Create a new webhook if needed.
  
  
    1. Navigate to webhook details
    2. Click "Settings"
    3. Change **Status** to "Archived"
    4. Confirm action
    
    > **Irreversible**: Cannot undo archival. Consider using "Inactive" for temporary pauses.
  

### Archive vs Delete

| Action | Configuration | Delivery Logs | Reversible |
|--------|--------------|---------------|------------|
| **Archive** | Preserved (read-only) | Preserved | No |
| **Delete** | Removed | Preserved | No |

> [INFO] **Recommendation**: Archive webhooks instead of deleting to maintain audit trails.

---

## State Transitions

### Valid Transitions

```plaintext
active ⟷ inactive    ✅ Bidirectional
active → archived    ✅ One-way
inactive → archived  ✅ One-way
archived → active    ❌ Not allowed
archived → inactive  ❌ Not allowed
```

### Transition API

```bash
# Active → Inactive
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "inactive"}'

# Inactive → Active
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "active"}'

# Any → Archived (permanent)
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "archived"}'
```

---

## Automatic State Changes

Field Nation may automatically change webhook state under certain conditions:

### Auto-Deactivation

**Trigger**: 7 consecutive days of failed deliveries

**Action**: `active` → `inactive`

**Notification**: Email sent to `notificationEmail` (if configured)

**Reason**: Prevent infinite retry loops on broken endpoints

**Recovery**:

```bash
# Fix endpoint issues first, then reactivate
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "active"}'
```

> **Important**: Fix underlying issues before reactivating. Repeated auto-deactivations may result in webhook being permanently archived.

---

## Change History & Audit Trail

Every webhook modification is tracked in a comprehensive change history.

### Tracked Changes

- Status transitions (active ⟷ inactive, → archived)
- URL modifications
- Event subscriptions (added/removed)
- HTTP method changes
- Secret regeneration
- Custom header updates
- Notification email changes

### Accessing Change History

#### Via API

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123/history" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T11:00:00Z",
    "count": 5,
    "total": 5
  },
  "result": [
    {
      "id": 123,
      "userId": 456,
      "action": "status_changed",
      "changes": {
        "status": {
          "from": "active",
          "to": "inactive"
        }
      },
      "createdAt": "2025-01-15T10:45:00Z",
      "updatedAt": "2025-01-15T10:45:00Z"
    },
    {
      "id": 122,
      "userId": 456,
      "action": "events_updated",
      "changes": {
        "events": {
          "added": ["workorder.status.approved"],
          "removed": ["workorder.status.draft"]
        }
      },
      "createdAt": "2025-01-15T09:30:00Z",
      "updatedAt": "2025-01-15T09:30:00Z"
    },
    {
      "id": 121,
      "userId": 456,
      "action": "url_changed",
      "changes": {
        "url": {
          "from": "https://old-endpoint.com/webhook",
          "to": "https://new-endpoint.com/webhooks"
        }
      },
      "createdAt": "2025-01-14T15:20:00Z",
      "updatedAt": "2025-01-14T15:20:00Z"
    }
  ]
}
```

#### Via Web UI

1. Navigate to [Webhooks Dashboard](https://ui-sandbox.fndev.net/integrations/webhooks)
2. Click on webhook
3. Go to "History" tab
4. View chronological list of changes

![Webhook Change History](/docs/webhook-v3/webhook-update-history.png)

### Filter History

```bash
# Filter by user
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123/history?userId=456" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"

# Filter by action
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123/history?search=status_changed" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

---

## Lifecycle Management Best Practices

### Use Descriptive Notification Emails

Configure an email to receive alerts:

```json
{
  "notificationEmail": "webhook-alerts+production@example.com"
}
```

Benefits:
- Receive auto-deactivation warnings
- Track delivery failures
- Monitor webhook health

### Tag Webhooks for Organization

Use naming conventions or custom headers to identify webhooks:

```javascript
// Create webhook with identifier in URL or custom headers
{
  "url": "https://your-endpoint.com/webhooks/production",
  "webhookAttribute": {
    "header": {
      "X-Webhook-Environment": "production",
      "X-Webhook-Owner": "team-integrations"
    }
  }
}
```

### Monitor State Changes

Track webhook state changes in your monitoring system:

```javascript
async function checkWebhookHealth() {
  const webhooks = await fetch(
    'https://api-sandbox.fndev.net/api/v1/webhooks',
    {
      headers: { 'Authorization': `Bearer ${accessToken}` }
    }
  ).then(r => r.json());
  
  const inactive = webhooks.result.filter(w => w.status === 'inactive');
  
  if (inactive.length > 0) {
    await alertTeam(`${inactive.length} webhooks are inactive`, inactive);
  }
}
```

### Implement Graceful Deprecation

When replacing webhooks:

### Create New Webhook

Create the new webhook with updated configuration:

```bash
curl -X POST https://api-sandbox.fndev.net/api/v1/webhooks \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://new-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "events": ["workorder.status.published"]
  }'
```

### Test New Webhook

Verify new webhook works correctly before deactivating old one.

### Pause Old Webhook

Set old webhook to `inactive`:

```bash
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_old123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "inactive"}'
```

### Monitor for Issues

Watch for missing events or processing errors.

### Archive Old Webhook

Once confident, archive the old webhook:

```bash
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_old123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "archived"}'
```

---

## Viewing Webhook Status

### List Webhooks by Status

  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?status=active" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?status=inactive" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks?status=archived" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  
  
    ```bash
    curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks" \
      -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
  

### Get Specific Webhook Status

```bash
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T11:00:00Z"
  },
  "result": {
    "id": 123,
    "webhookId": "wh_abc123",
    "url": "https://your-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "events": ["workorder.status.published", "workorder.status.assigned"],
    "createdAt": "2025-01-10T10:00:00Z",
    "updatedAt": "2025-01-15T10:45:00Z"
  }
}
```

---

## Lifecycle Event Flow

```mermaid
graph TD
    A[Create Webhook] -->|Default| B[Active]
    A -->|Specify inactive| C[Inactive]
    
    B -->|Process Events| D[Event Occurs]
    D -->|Queue & Deliver| E[Delivery Attempt]
    
    E -->|Success| F[Log Success]
    E -->|Failure| G{7 Days Failed?}
    
    G -->|Yes| H[Auto-Deactivate to Inactive]
    G -->|No| I[Retry with Backoff]
    
    B -->|Manual Pause| C
    C -->|Manual Reactivate| B
    
    B -->|Permanent Deactivate| J[Archived]
    C -->|Permanent Deactivate| J
    
    J -->|Read-Only| K[Historical Record]
    
    style B fill:#90EE90
    style C fill:#FFD700
    style J fill:#D3D3D3
```

---

---

### undefined
URL: /docs/webhooks/guides/creating-webhooks

# Webhooks: undefined
URL: /docs/webhooks/guides/creating-webhooks
Source: content/docs/webhooks/guides/creating-webhooks.mdx

---
title: Creating Webhooks
description: Step-by-step guide to creating and configuring webhooks using the Web UI or REST API with examples for both methods.
---

## Prerequisites

Before creating a webhook, ensure you have:

- ✅ Field Nation API credentials (`client_id` and `client_secret`)
- ✅ OAuth access token (for API method)
- ✅ HTTPS endpoint URL ready to receive webhooks
- ✅ List of events you want to subscribe to

[Review prerequisites →](/docs/getting-started/prerequisites)

---

## Method 1: Web UI (Visual)

Best for:
- Quick setup and testing
- Non-technical users
- Visual configuration
- One-off webhook creation

### Navigate to Webhooks Dashboard

**Sandbox**: [https://ui-sandbox.fndev.net/integrations/webhooks](https://ui-sandbox.fndev.net/integrations/webhooks)

**Production**: [https://app.fieldnation.com/integrations/webhooks](https://app.fieldnation.com/integrations/webhooks)

### Click "Create New"

Located in the top-right corner of the dashboard.

### Configure Basic Settings

Fill in the required fields:

**Webhook URL**:
- Enter your HTTPS endpoint (e.g., `https://your-endpoint.com/webhooks`)
- Must be publicly accessible
- Must use HTTPS (HTTP not allowed)

**HTTP Method**:
- **POST** (recommended) - Standard for webhooks
- **PUT** - Use if your endpoint requires PUT

**Status**:
- **Active** - Start receiving events immediately
- **Inactive** - Create paused, activate later

### Select Events

Choose which events trigger this webhook:

**Option 1: Select All Events**
- Check "Subscribe to all events"
- Receives all 33 events automatically
- Future events included automatically

**Option 2: Select Specific Events**
- Click "Add Event"
- Search or browse available events
- Select only events your system processes

> [INFO] **Recommendation**: Start with a small set of events (4-6), then expand as needed. Subscribing to unused events creates unnecessary processing overhead.

### Configure Advanced Settings (Optional)

Click "Advanced Settings" to configure:

**Notification Email**:
- Email address for delivery failure alerts
- Recommended: Use a monitored team email

**Custom Headers**:
- Add authentication tokens or custom identifiers
- Click "Add Header"
- Enter key-value pairs

**Example:**
```plaintext
Authorization: Bearer your-api-token
X-Custom-ID: integration-prod
X-Environment: production
```

> **Reserved Prefix**: Headers cannot start with `x-fn-` (reserved for Field Nation).

**Secret Key**:
- Auto-generated by default
- Optionally provide your own UUID
- Used for HMAC-SHA256 signature verification

### Review & Create

- Review all settings
- Click "Create Webhook"
- **Save the webhook ID and secret** - you'll need these

### UI Configuration Example

![Webhook Creation Form](/docs/webhook-v3/create-webhook.png)

**Advanced Settings:**

![Advanced Webhook Configuration](/docs/webhook-v3/create-webhook-advanced.png)

> [INFO] **After Creation**: The webhook is immediately active if status was set to "active". Test by triggering an event!

---

## Method 2: REST API (Programmatic)

Best for:
- Automation and infrastructure-as-code
- Multiple webhook creation
- CI/CD pipelines
- Dynamic configuration

### Step 1: Get OAuth Access Token

```bash title="Generate Access Token"
curl -X POST https://api-sandbox.fndev.net/authentication/api/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=YOUR_CLIENT_ID" \
  -d "client_secret=YOUR_CLIENT_SECRET"
```

**Response:**

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

### Step 2: Create Webhook

```bash title="Create Webhook"
curl -X POST https://api-sandbox.fndev.net/api/v1/webhooks \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://your-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "events": [
      "workorder.created",
      "workorder.status.published",
      "workorder.status.assigned",
      "workorder.status.work_done",
      "workorder.status.approved"
    ],
    "notificationEmail": "webhook-alerts@example.com"
  }'
```

**Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T10:30:00Z"
  },
  "result": {
    "id": 123,
    "webhookId": "wh_abc123def456",
    "companyId": 789,
    "userId": 456,
    "url": "https://your-endpoint.com/webhooks",
    "method": "post",
    "status": "active",
    "secret": "01999f51-5c66-4449-b441-6b4a053fee6a",
    "events": [
      "workorder.created",
      "workorder.status.published",
      "workorder.status.assigned",
      "workorder.status.work_done",
      "workorder.status.approved"
    ],
    "notificationEmail": "webhook-alerts@example.com",
    "modelProperties": [],
    "isIntegrationOnly": false,
    "createdAt": "2025-01-15T10:30:00Z",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

> **Save the secret!** The `secret` field is only returned during creation. Store it securely—you'll need it for signature verification.

### Step 3: Verify Webhook Created

```bash title="Get Webhook Details"
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123def456 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

---

## Request Body Reference

### Required Fields

",
      description: "Array of event names to subscribe to. Must contain at least 1 event. See [event catalog](/docs/webhooks/concepts/events) for complete list.",
      required: true
    }
  }}
/>

### Optional Fields

---

## Configuration Examples

### Minimal Configuration

Subscribe to single event:

```json
{
  "url": "https://your-endpoint.com/webhooks",
  "method": "post",
  "status": "active",
  "events": ["workorder.status.published"]
}
```

### Production-Ready Configuration

Full configuration with custom headers and notifications:

```json
{
  "url": "https://api.example.com/integrations/fieldnation/webhooks",
  "method": "post",
  "status": "active",
  "events": [
    "workorder.created",
    "workorder.status.published",
    "workorder.status.assigned",
    "workorder.status.checked_in",
    "workorder.status.work_done",
    "workorder.status.approved",
    "workorder.status.paid"
  ],
  "secret": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "notificationEmail": "integrations-alerts@example.com",
  "webhookAttribute": {
    "header": {
      "Authorization": "Bearer prod-api-token-xyz",
      "X-Webhook-Environment": "production",
      "X-Webhook-Version": "v1",
      "X-Team-Owner": "integrations"
    }
  }
}
```

### Multi-Environment Setup

Create separate webhooks for different environments:

  
    ```json
    {
      "url": "https://dev.example.com/webhooks",
      "method": "post",
      "status": "active",
      "events": ["workorder.created", "workorder.status.published"],
      "notificationEmail": "dev-team@example.com",
      "webhookAttribute": {
        "header": {
          "X-Environment": "development"
        }
      }
    }
    ```
  
  
    ```json
    {
      "url": "https://staging.example.com/webhooks",
      "method": "post",
      "status": "active",
      "events": [
        "workorder.created",
        "workorder.status.published",
        "workorder.status.assigned",
        "workorder.status.work_done"
      ],
      "notificationEmail": "staging-alerts@example.com",
      "webhookAttribute": {
        "header": {
          "X-Environment": "staging"
        }
      }
    }
    ```
  
  
    ```json
    {
      "url": "https://api.example.com/webhooks",
      "method": "post",
      "status": "active",
      "events": [
        "workorder.created",
        "workorder.status.published",
        "workorder.status.assigned",
        "workorder.status.checked_in",
        "workorder.status.work_done",
        "workorder.status.approved",
        "workorder.status.paid",
        "workorder.problem_reported"
      ],
      "notificationEmail": "prod-alerts@example.com",
      "webhookAttribute": {
        "header": {
          "Authorization": "Bearer prod-api-token",
          "X-Environment": "production"
        }
      }
    }
    ```
  

---

## Adding Custom Headers

Custom headers are sent with every webhook delivery:

### Authentication Headers

```json
{
  "webhookAttribute": {
    "header": {
      "Authorization": "Bearer your-api-token",
      "X-API-Key": "your-api-key"
    }
  }
}
```

### Identifier Headers

```json
{
  "webhookAttribute": {
    "header": {
      "X-Webhook-ID": "prod-wh-001",
      "X-Environment": "production",
      "X-Version": "v1",
      "X-Owner": "integrations-team"
    }
  }
}
```

> [INFO] **Best Practice**: Use custom headers for authentication instead of query parameters. Headers are encrypted in transit and stored encrypted in the database.

---

## Event Selection Strategies

### Strategy 1: Minimal (Core Events)

Subscribe only to critical lifecycle events:

```json
{
  "events": [
    "workorder.status.published",
    "workorder.status.assigned",
    "workorder.status.work_done",
    "workorder.status.approved"
  ]
}
```

**Use When**: Building MVP or simple integration

**Benefits**: Minimal processing, easy to test, focused integration

---

### Strategy 2: Comprehensive (All Status Changes)

Subscribe to complete status lifecycle:

```json
{
  "events": [
    "workorder.status.published",
    "workorder.status.confirmed",
    "workorder.status.assigned",
    "workorder.status.on_my_way",
    "workorder.status.checked_in",
    "workorder.status.checked_out",
    "workorder.status.work_done",
    "workorder.status.approved",
    "workorder.status.paid",
    "workorder.status.cancelled"
  ]
}
```

**Use When**: Need complete visibility into work order progress

**Benefits**: Real-time dashboards, detailed tracking, comprehensive sync

---

### Strategy 3: Activity-Focused

Subscribe to work order activities:

```json
{
  "events": [
    "workorder.message_posted",
    "workorder.provider_upload",
    "workorder.task_completed",
    "workorder.schedule_updated",
    "workorder.problem_reported",
    "workorder.problem_resolved"
  ]
}
```

**Use When**: Monitoring provider activity and work progress

**Benefits**: Track communications, document uploads, task completion

---

### Strategy 4: All Events

Subscribe to everything:

```json
{
  "events": [
    "workorder.created",
    "workorder.routed",
    // ... all 33 events
  ]
}
```

**Use When**: Building comprehensive integration or analytics

**Caution**: High event volume, requires robust processing

---

## Infrastructure as Code

### Terraform Example

```hcl
resource "fieldnation_webhook" "production" {
  url    = "https://api.example.com/webhooks"
  method = "post"
  status = "active"
  
  events = [
    "workorder.status.published",
    "workorder.status.assigned",
    "workorder.status.work_done",
    "workorder.status.approved"
  ]
  
  notification_email = "prod-alerts@example.com"
  
  custom_headers = {
    "Authorization" = "Bearer ${var.api_token}"
    "X-Environment" = "production"
  }
}
```

### Script-Based Creation

```javascript title="create-webhook.js"
const fetch = require('node-fetch');

async function createWebhook(config) {
  // Get access token
  const tokenResponse = await fetch(
    'https://api-sandbox.fndev.net/authentication/api/oauth/token',
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'client_credentials',
        client_id: process.env.FN_CLIENT_ID,
        client_secret: process.env.FN_CLIENT_SECRET
      })
    }
  );
  
  const { access_token } = await tokenResponse.json();
  
  // Create webhook
  const webhookResponse = await fetch(
    'https://api-sandbox.fndev.net/api/v1/webhooks',
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${access_token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(config)
    }
  );
  
  const webhook = await webhookResponse.json();
  
  console.log('Webhook created:', webhook.result.webhookId);
  console.log('Secret:', webhook.result.secret);
  
  return webhook.result;
}

// Usage
createWebhook({
  url: 'https://your-endpoint.com/webhooks',
  method: 'post',
  status: 'active',
  events: ['workorder.status.published', 'workorder.status.assigned'],
  notificationEmail: 'alerts@example.com'
});
```

---

## Best Practices

### Start Inactive for Testing

Create webhooks in `inactive` state for safe testing:

```json
{
  "status": "inactive",
  // ... other config
}
```

Activate after verifying endpoint:

```bash
curl -X PUT https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "active"}'
```

### Use Descriptive Notification Emails

```json
{
  "notificationEmail": "webhook-prod-team-integrations@example.com"
}
```

Benefits:
- Easy to identify which webhook failed
- Route to correct team
- Track multiple environments

### Generate Strong Secrets

```javascript
const crypto = require('crypto');
const uuid = require('uuid');

// Option 1: UUID v4
const secret = uuid.v4();

// Option 2: Random hex
const secret = crypto.randomBytes(32).toString('hex');
```

### Document Your Webhooks

Maintain a registry:

```markdown
| Webhook ID | Environment | Events | Owner | Purpose |
|------------|-------------|--------|-------|---------|
| wh_prod_01 | Production | Status changes | Integrations | Salesforce sync |
| wh_prod_02 | Production | All events | Analytics | Data warehouse |
| wh_dev_01 | Development | Core events | Dev Team | Local testing |
```

---

---

### undefined
URL: /docs/webhooks/guides/handling-events

# Webhooks: undefined
URL: /docs/webhooks/guides/handling-events
Source: content/docs/webhooks/guides/handling-events.mdx

---
title: Handling Events
description: Build robust webhook event processing with idempotency, async patterns, error handling, and production-ready best practices.
---

## Event Processing Architecture

```mermaid
graph TD
    A[Webhook Received] --> B{Verify Signature}
    B -->|Invalid| C[Reject 401]
    B -->|Valid| D{Check Idempotency}
    D -->|Duplicate| E[Return 200 Already Processed]
    D -->|New| F[Respond 200 OK]
    F --> G[Queue for Async Processing]
    G --> H[Process Event]
    H --> I{Success?}
    I -->|Yes| J[Mark Complete]
    I -->|No| K{Retriable?}
    K -->|Yes| L[Requeue with Backoff]
    K -->|No| M[Send to DLQ]
    L --> H
    
    style C fill:#ff6b6b
    style E fill:#ffe066
    style J fill:#51cf66
    style M fill:#ff6b6b
```

---

## 1. Idempotency

**Critical**: Webhooks may be delivered more than once. Your system must handle duplicate events gracefully.

### Why Idempotency Matters

- **Retry logic**: Failed deliveries are retried
- **Network issues**: Timeout may occur after processing
- **Manual retries**: Operators can manually retry events
- **At-least-once delivery**: Field Nation guarantees at-least-once, not exactly-once

### Implementing Idempotency

Use `eventId` as the unique identifier:

  
    ```javascript
    const redis = require('redis');
    const client = redis.createClient();

    async function isEventProcessed(eventId) {
      return await client.exists(`event:${eventId}`);
    }

    async function markEventProcessed(eventId) {
      // Store for 7 days (604800 seconds)
      await client.setex(`event:${eventId}`, 604800, 'processed');
    }

    async function processWebhook(payload) {
      const { eventId } = payload;
      
      // Check if already processed
      if (await isEventProcessed(eventId)) {
        console.log(`Duplicate event ${eventId}, skipping`);
        return { status: 'duplicate', eventId };
      }
      
      // Mark as processing (prevents race conditions)
      const wasSet = await client.set(
        `event:${eventId}`, 
        'processing',
        'EX', 604800,
        'NX'  // Only set if not exists
      );
      
      if (!wasSet) {
        console.log(`Event ${eventId} already being processed`);
        return { status: 'duplicate', eventId };
      }
      
      try {
        // Process the event
        await handleEvent(payload);
        
        // Update to processed
        await client.set(`event:${eventId}`, 'processed', 'EX', 604800);
        
        return { status: 'processed', eventId };
      } catch (error) {
        // Remove processing lock on failure
        await client.del(`event:${eventId}`);
        throw error;
      }
    }
    ```
  
  
    ```sql
    -- Create processed_events table
    CREATE TABLE processed_events (
      event_id VARCHAR(255) PRIMARY KEY,
      event_name VARCHAR(255) NOT NULL,
      work_order_id INTEGER,
      processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      payload JSONB,
      status VARCHAR(50) DEFAULT 'processed'
    );

    -- Index for cleanup
    CREATE INDEX idx_processed_at ON processed_events(processed_at);
    ```

    ```javascript
    const { Pool } = require('pg');
    const pool = new Pool();

    async function isEventProcessed(eventId) {
      const result = await pool.query(
        'SELECT event_id FROM processed_events WHERE event_id = $1',
        [eventId]
      );
      return result.rows.length > 0;
    }

    async function markEventProcessed(eventId, eventName, workOrderId, payload) {
      try {
        await pool.query(
          `INSERT INTO processed_events (event_id, event_name, work_order_id, payload, status)
           VALUES ($1, $2, $3, $4, 'processed')
           ON CONFLICT (event_id) DO NOTHING`,
          [eventId, eventName, workOrderId, JSON.stringify(payload)]
        );
      } catch (error) {
        // Unique constraint violation means already processed
        if (error.code === '23505') {
          return false;
        }
        throw error;
      }
      return true;
    }

    async function processWebhook(payload) {
      const { eventId, eventName, workOrderId } = payload;
      
      // Try to insert event (atomic operation)
      const wasInserted = await markEventProcessed(
        eventId,
        eventName,
        workOrderId,
        { status: 'processing' }
      );
      
      if (!wasInserted) {
        console.log(`Duplicate event ${eventId}`);
        return { status: 'duplicate', eventId };
      }
      
      try {
        // Process the event
        await handleEvent(payload);
        
        // Update status
        await pool.query(
          'UPDATE processed_events SET status = $1, payload = $2 WHERE event_id = $3',
          ['processed', JSON.stringify(payload), eventId]
        );
        
        return { status: 'processed', eventId };
      } catch (error) {
        // Mark as failed
        await pool.query(
          'UPDATE processed_events SET status = $1 WHERE event_id = $2',
          ['failed', eventId]
        );
        throw error;
      }
    }

    // Cleanup old events (run daily)
    async function cleanupOldEvents() {
      await pool.query(
        'DELETE FROM processed_events WHERE processed_at < NOW() - INTERVAL \'7 days\''
      );
    }
    ```
  
  
    ```javascript
    // WARNING: Only for development - data lost on restart
    const processedEvents = new Set();

    function isEventProcessed(eventId) {
      return processedEvents.has(eventId);
    }

    function markEventProcessed(eventId) {
      processedEvents.add(eventId);
    }

    async function processWebhook(payload) {
      const { eventId } = payload;
      
      if (isEventProcessed(eventId)) {
        console.log(`Duplicate event ${eventId}`);
        return { status: 'duplicate', eventId };
      }
      
      markEventProcessed(eventId);
      
      try {
        await handleEvent(payload);
        return { status: 'processed', eventId };
      } catch (error) {
        // Remove on failure to allow retry
        processedEvents.delete(eventId);
        throw error;
      }
    }
    ```
  

> **Important**: Store idempotency keys for at least 7 days to handle late retries and manual replays.

---

## 2. Async Processing Pattern

**Critical**: Respond to webhooks within 5 seconds, then process asynchronously.

### Why Async Processing?

- **Fast response**: Prevents timeouts and retries
- **Scalability**: Handle high event volumes
- **Reliability**: Failures don't block webhook delivery
- **Resource management**: Control processing concurrency

### Basic Async Pattern

```javascript
const express = require('express');
const { Queue } = require('bull');

const app = express();
const webhookQueue = new Queue('webhooks', 'redis://localhost:6379');

// Webhook endpoint - respond immediately
app.post('/webhooks/fieldnation', async (req, res) => {
  try {
    // 1. Verify signature
    if (!verifySignature(req.body, req.headers['x-fn-signature'])) {
      return res.status(401).send('Unauthorized');
    }
    
    // 2. Parse payload
    const payload = JSON.parse(req.body.toString());
    
    // 3. Check idempotency
    if (await isEventProcessed(payload.eventId)) {
      console.log(`Duplicate: ${payload.eventId}`);
      return res.status(200).send('Already processed');
    }
    
    // 4. Queue for processing
    await webhookQueue.add('process', payload, {
      attempts: 5,
      backoff: {
        type: 'exponential',
        delay: 2000
      },
      removeOnComplete: true,
      removeOnFail: false
    });
    
    // 5. Respond immediately
    res.status(200).send('OK');
    
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).send('Internal error');
  }
});

// Worker - process async
webhookQueue.process('process', async (job) => {
  const payload = job.data;
  
  try {
    // Mark as processing
    await markEventProcessing(payload.eventId);
    
    // Process the event
    await processEvent(payload);
    
    // Mark as complete
    await markEventProcessed(payload.eventId);
    
    return { status: 'success', eventId: payload.eventId };
  } catch (error) {
    console.error(`Failed to process ${payload.eventId}:`, error);
    throw error; // Will trigger retry
  }
});

async function processEvent(payload) {
  const { eventName, data } = payload;
  
  switch (eventName) {
    case 'workorder.status.published':
      await handlePublished(data);
      break;
    case 'workorder.status.assigned':
      await handleAssigned(data);
      break;
    case 'workorder.status.work_done':
      await handleWorkDone(data);
      break;
    default:
      console.log(`Unhandled event: ${eventName}`);
  }
}
```

### Advanced: Multi-Queue Architecture

Separate queues by priority or event type:

```javascript
const highPriorityQueue = new Queue('webhooks-high', 'redis://localhost:6379');
const normalQueue = new Queue('webhooks-normal', 'redis://localhost:6379');
const lowPriorityQueue = new Queue('webhooks-low', 'redis://localhost:6379');

function getQueueForEvent(eventName) {
  // High priority: payment, approval
  if (eventName.includes('approved') || eventName.includes('paid')) {
    return highPriorityQueue;
  }
  
  // Low priority: messages, uploads
  if (eventName.includes('message') || eventName.includes('upload')) {
    return lowPriorityQueue;
  }
  
  // Normal priority: everything else
  return normalQueue;
}

app.post('/webhooks/fieldnation', async (req, res) => {
  const payload = JSON.parse(req.body.toString());
  const queue = getQueueForEvent(payload.eventName);
  
  await queue.add('process', payload);
  res.status(200).send('OK');
});

// Process each queue with different concurrency
highPriorityQueue.process('process', 10, processEvent);
normalQueue.process('process', 5, processEvent);
lowPriorityQueue.process('process', 2, processEvent);
```

---

## 3. Error Handling

Robust error handling prevents data loss and ensures reliability.

### Error Categories

  
    **Retry these errors** - temporary issues that may resolve:

    ```javascript
    const RETRIABLE_ERRORS = [
      'ECONNREFUSED',    // Connection refused
      'ETIMEDOUT',       // Connection timeout
      'ENOTFOUND',       // DNS lookup failed
      'ENETUNREACH',     // Network unreachable
      'ECONNRESET',      // Connection reset
      '503',             // Service Unavailable
      '504',             // Gateway Timeout
      '429'              // Too Many Requests
    ];

    function isRetriable(error) {
      return RETRIABLE_ERRORS.some(code =>
        error.code === code ||
        error.message.includes(code) ||
        error.statusCode === parseInt(code)
      );
    }

    async function processWithRetry(payload) {
      try {
        await syncToSalesforce(payload.data);
      } catch (error) {
        if (isRetriable(error)) {
          console.log(`Retriable error for ${payload.eventId}:`, error.message);
          throw error; // Bull will retry
        }
        
        // Non-retriable error - log and move to DLQ
        console.error(`Non-retriable error for ${payload.eventId}:`, error);
        await sendToDLQ(payload, error);
      }
    }
    ```
  
  
    **Don't retry these** - permanent failures:

    ```javascript
    const NON_RETRIABLE_ERRORS = [
      'VALIDATION_ERROR',     // Invalid data format
      'AUTHENTICATION_ERROR', // Invalid credentials
      'AUTHORIZATION_ERROR',  // Insufficient permissions
      'NOT_FOUND',           // Resource doesn't exist
      '400',                 // Bad Request
      '401',                 // Unauthorized
      '403',                 // Forbidden
      '404',                 // Not Found
      '422'                  // Unprocessable Entity
    ];

    async function processEvent(payload) {
      try {
        // Validate payload
        if (!validatePayload(payload)) {
          throw new Error('VALIDATION_ERROR: Invalid payload format');
        }
        
        // Process event
        await handleEvent(payload);
        
      } catch (error) {
        if (isNonRetriable(error)) {
          // Log and move to DLQ immediately
          console.error(`Non-retriable error for ${payload.eventId}:`, error);
          await sendToDLQ(payload, error);
          return; // Don't throw - prevents retry
        }
        
        throw error; // Retriable - let it retry
      }
    }
    ```
  
  
    **Handle partial success** - some operations succeed:

    ```javascript
    async function processEvent(payload) {
      const results = {
        salesforce: null,
        database: null,
        notification: null
      };
      
      try {
        // Step 1: Update Salesforce
        results.salesforce = await syncToSalesforce(payload.data);
      } catch (error) {
        console.error('Salesforce sync failed:', error);
        // Continue - don't fail entire job
      }
      
      try {
        // Step 2: Update database
        results.database = await updateDatabase(payload.data);
      } catch (error) {
        console.error('Database update failed:', error);
        throw error; // Critical failure - retry everything
      }
      
      try {
        // Step 3: Send notification
        results.notification = await sendNotification(payload.data);
      } catch (error) {
        console.error('Notification failed:', error);
        // Log but don't fail - not critical
      }
      
      // Log results
      await logProcessingResults(payload.eventId, results);
      
      return results;
    }
    ```
  

### Dead Letter Queue (DLQ)

Send permanently failed events to DLQ for manual review:

```javascript
const dlqQueue = new Queue('webhooks-dlq', 'redis://localhost:6379');

async function sendToDLQ(payload, error) {
  await dlqQueue.add('failed', {
    payload,
    error: {
      message: error.message,
      stack: error.stack,
      code: error.code
    },
    failedAt: new Date().toISOString(),
    attempts: payload.attempts || 0
  }, {
    removeOnComplete: false, // Keep DLQ items
    removeOnFail: false
  });
  
  // Alert team
  await alertTeam({
    type: 'webhook_dlq',
    eventId: payload.eventId,
    eventName: payload.eventName,
    error: error.message
  });
}

// Monitor DLQ
dlqQueue.on('completed', async (job) => {
  console.log(`DLQ item resolved: ${job.data.payload.eventId}`);
});
```

---

## 4. Event-Specific Handlers

Organize your code by event type for clarity and maintainability:

```javascript
// handlers/workorder.js
class WorkOrderHandlers {
  async handlePublished(data) {
    console.log(`Work order ${data.id} published`);
    
    // Notify provider network
    await this.notifyProviders(data);
    
    // Update dispatch board
    await this.updateDispatchBoard(data);
    
    // Sync to Salesforce
    await this.syncToSalesforce(data);
  }
  
  async handleAssigned(data) {
    console.log(`Work order ${data.id} assigned to provider ${data.provider.id}`);
    
    // Notify provider
    await this.notifyProvider(data.provider, data);
    
    // Update scheduling system
    await this.updateSchedule(data);
    
    // Log assignment
    await this.logAssignment(data);
  }
  
  async handleWorkDone(data) {
    console.log(`Work order ${data.id} work completed`);
    
    // Trigger approval workflow
    await this.triggerApprovalWorkflow(data);
    
    // Notify buyer
    await this.notifyBuyer(data.buyer, data);
    
    // Update analytics
    await this.updateMetrics(data);
  }
  
  async handleApproved(data) {
    console.log(`Work order ${data.id} approved`);
    
    // Generate invoice
    await this.generateInvoice(data);
    
    // Update accounting system
    await this.updateAccounting(data);
    
    // Archive work order
    await this.archiveWorkOrder(data);
  }
}

// handlers/index.js
const workOrderHandlers = new WorkOrderHandlers();

async function processEvent(payload) {
  const { eventName, data } = payload;
  
  // Route to appropriate handler
  switch (eventName) {
    case 'workorder.status.published':
      return await workOrderHandlers.handlePublished(data);
      
    case 'workorder.status.assigned':
      return await workOrderHandlers.handleAssigned(data);
      
    case 'workorder.status.work_done':
      return await workOrderHandlers.handleWorkDone(data);
      
    case 'workorder.status.approved':
      return await workOrderHandlers.handleApproved(data);
      
    default:
      console.log(`No handler for event: ${eventName}`);
  }
}
```

---

## 5. Circuit Breaker Pattern

Prevent cascading failures when downstream services are unavailable:

```javascript
const CircuitBreaker = require('opossum');

// Configure circuit breaker
const salesforceBreaker = new CircuitBreaker(async (data) => {
  return await syncToSalesforce(data);
}, {
  timeout: 5000,                    // 5 second timeout
  errorThresholdPercentage: 50,     // Open after 50% failures
  resetTimeout: 30000,              // Try again after 30 seconds
  rollingCountTimeout: 10000,       // Track errors over 10 seconds
  rollingCountBuckets: 10,          // 10 buckets
  name: 'salesforce'
});

// Monitor circuit breaker state
salesforceBreaker.on('open', () => {
  console.error('Circuit breaker OPEN - Salesforce unavailable');
  alertTeam({ service: 'salesforce', status: 'circuit_open' });
});

salesforceBreaker.on('halfOpen', () => {
  console.log('Circuit breaker HALF-OPEN - Testing Salesforce');
});

salesforceBreaker.on('close', () => {
  console.log('Circuit breaker CLOSED - Salesforce recovered');
});

// Use in event handler
async function handlePublished(data) {
  try {
    await salesforceBreaker.fire(data);
  } catch (error) {
    if (salesforceBreaker.opened) {
      console.log('Salesforce circuit open, queuing for later');
      await queueForLater(data);
    } else {
      throw error;
    }
  }
}
```

---

## 6. Rate Limiting Downstream Services

Protect your downstream services from overload:

```javascript
const Bottleneck = require('bottleneck');

// Rate limiter: max 10 requests per second
const salesforceLimiter = new Bottleneck({
  maxConcurrent: 5,        // Max 5 concurrent requests
  minTime: 100,            // Min 100ms between requests
  reservoir: 10,           // 10 requests
  reservoirRefreshAmount: 10,
  reservoirRefreshInterval: 1000 // per second
});

async function syncToSalesforce(data) {
  return await salesforceLimiter.schedule(async () => {
    const response = await fetch('https://salesforce.com/api/workorders', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}` },
      body: JSON.stringify(data)
    });
    return await response.json();
  });
}
```

---

## 7. Monitoring & Observability

Track webhook processing health:

```javascript
const prometheus = require('prom-client');

// Metrics
const webhookCounter = new prometheus.Counter({
  name: 'webhooks_received_total',
  help: 'Total webhooks received',
  labelNames: ['event_name', 'status']
});

const webhookDuration = new prometheus.Histogram({
  name: 'webhook_processing_duration_seconds',
  help: 'Time to process webhook',
  labelNames: ['event_name'],
  buckets: [0.1, 0.5, 1, 2, 5, 10]
});

const webhookErrors = new prometheus.Counter({
  name: 'webhook_errors_total',
  help: 'Total webhook processing errors',
  labelNames: ['event_name', 'error_type']
});

// Instrumented handler
async function processEvent(payload) {
  const timer = webhookDuration.startTimer({ event_name: payload.eventName });
  
  try {
    await handleEvent(payload);
    
    webhookCounter.inc({ event_name: payload.eventName, status: 'success' });
    timer();
    
  } catch (error) {
    webhookCounter.inc({ event_name: payload.eventName, status: 'error' });
    webhookErrors.inc({
      event_name: payload.eventName,
      error_type: error.code || 'unknown'
    });
    timer();
    throw error;
  }
}
```

---

## Complete Production Example

Here's a full production-ready webhook handler:

```javascript title="webhook-handler.js"
const express = require('express');
const { Queue } = require('bull');
const CircuitBreaker = require('opossum');
const redis = require('redis');

const app = express();
const redisClient = redis.createClient();
const webhookQueue = new Queue('webhooks', 'redis://localhost:6379');

// Circuit breakers
const salesforceBreaker = new CircuitBreaker(syncToSalesforce, {
  timeout: 5000,
  errorThresholdPercentage: 50,
  resetTimeout: 30000
});

// Webhook endpoint
app.use(express.raw({ type: 'application/json' }));

app.post('/webhooks/fieldnation', async (req, res) => {
  try {
    // 1. Verify signature
    if (!verifySignature(req.body, req.headers['x-fn-signature'], process.env.WEBHOOK_SECRET)) {
      return res.status(401).send('Unauthorized');
    }
    
    // 2. Parse payload
    const payload = JSON.parse(req.body.toString());
    
    // 3. Check idempotency
    const alreadyProcessed = await redisClient.exists(`event:${payload.eventId}`);
    if (alreadyProcessed) {
      return res.status(200).send('Already processed');
    }
    
    // 4. Queue for async processing
    await webhookQueue.add('process', payload, {
      attempts: 5,
      backoff: { type: 'exponential', delay: 2000 },
      removeOnComplete: true
    });
    
    // 5. Respond immediately
    res.status(200).send('OK');
    
  } catch (error) {
    console.error('Webhook endpoint error:', error);
    res.status(500).send('Internal error');
  }
});

// Worker
webhookQueue.process('process', 5, async (job) => {
  const payload = job.data;
  
  try {
    // Mark as processing
    await redisClient.set(`event:${payload.eventId}`, 'processing', 'EX', 604800, 'NX');
    
    // Process event
    await processEvent(payload);
    
    // Mark complete
    await redisClient.set(`event:${payload.eventId}`, 'processed', 'EX', 604800);
    
  } catch (error) {
    console.error(`Processing failed for ${payload.eventId}:`, error);
    
    if (isNonRetriable(error)) {
      await sendToDLQ(payload, error);
      return; // Don't throw - prevents retry
    }
    
    throw error; // Retriable
  }
});

async function processEvent(payload) {
  const { eventName, data } = payload;
  
  switch (eventName) {
    case 'workorder.status.published':
      await salesforceBreaker.fire(data);
      break;
      
    case 'workorder.status.assigned':
      await handleAssigned(data);
      break;
      
    case 'workorder.status.work_done':
      await handleWorkDone(data);
      break;
      
    default:
      console.log(`Unhandled event: ${eventName}`);
  }
}

app.listen(3000);
```

---

## Best Practices Checklist

- ✅ Implement idempotency with `eventId`
- ✅ Respond to webhooks within 5 seconds
- ✅ Process events asynchronously
- ✅ Handle retriable vs non-retriable errors differently
- ✅ Use circuit breakers for downstream services
- ✅ Rate limit calls to external APIs
- ✅ Implement Dead Letter Queue for failed events
- ✅ Monitor processing metrics
- ✅ Log errors with context
- ✅ Set up alerts for anomalies

---

---

### undefined
URL: /docs/webhooks/guides/monitoring

# Webhooks: undefined
URL: /docs/webhooks/guides/monitoring
Source: content/docs/webhooks/guides/monitoring.mdx

---
title: Monitoring Webhooks
description: Set up monitoring, alerts, and dashboards to track webhook delivery health, processing metrics, and system reliability.
---

## Monitoring Strategy

```mermaid
graph LR
    A[Webhook Delivery] --> B[Metrics Collection]
    B --> C[Dashboards]
    B --> D[Alerts]
    B --> E[Logs]
    
    C --> F[Real-time Monitoring]
    D --> G[Incident Response]
    E --> H[Debugging]
    
    F --> I[Proactive Management]
    G --> I
    H --> I
```

---

## Key Metrics to Track

### 1. Delivery Metrics

99%",
      required: true
    },
    "delivery_latency": {
      type: "duration (ms)",
      description: "Time from event trigger to successful delivery. Target: 

### 2. Processing Metrics

### 3. Business Metrics

---

## Monitoring Field Nation's Delivery Logs

Access comprehensive delivery data via Field Nation's API:

### List Delivery Logs

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123&page=1&perPage=50" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "count": 50,
    "total": 1234
  },
  "result": [
    {
      "deliveryId": "del_xyz789",
      "webhookId": "wh_abc123",
      "workOrderId": 12345,
      "eventName": "workorder.status.published",
      "deliveryStatus": 200,
      "deliveryAttempt": 1,
      "createdAt": "2025-01-15T11:59:00Z"
    }
    // ... more deliveries
  ]
}
```

### Filter by Status

```bash
# Failed deliveries only
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123&deliveryStatus=500" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"

# Retried deliveries
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123&sortBy=deliveryAttempt&sortDirection=DESC" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Get Detailed Log

```bash
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/del_xyz789 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

**Response includes pre-signed URL to full log file:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z"
  },
  "result": {
    "deliveryId": "del_xyz789",
    "webhookId": "wh_abc123",
    "eventName": "workorder.status.published",
    "deliveryStatus": 200,
    "deliveryAttempt": 1,
    "createdAt": "2025-01-15T11:59:00Z",
    "delivery_log": "https://s3.amazonaws.com/fn-logs/del_xyz789?expires=..."
  }
}
```

![Delivery Logs Dashboard](/docs/webhook-v3/delivery-logs.png)

---

## Automated Monitoring Script

Poll delivery logs and alert on issues:

```javascript title="monitor-webhooks.js"
const fetch = require('node-fetch');

class WebhookMonitor {
  constructor(accessToken) {
    this.accessToken = accessToken;
    this.baseUrl = 'https://api-sandbox.fndev.net';
  }
  
  async getDeliveryLogs(webhookId, filters = {}) {
    const params = new URLSearchParams({
      webhookId,
      perPage: 100,
      ...filters
    });
    
    const response = await fetch(
      `${this.baseUrl}/api/v1/webhooks/delivery-logs?${params}`,
      {
        headers: { 'Authorization': `Bearer ${this.accessToken}` }
      }
    );
    
    return await response.json();
  }
  
  async calculateSuccessRate(webhookId, minutes = 60) {
    const sinceTime = new Date(Date.now() - minutes * 60 * 1000).toISOString();
    
    const logs = await this.getDeliveryLogs(webhookId, {
      sortBy: 'createdAt',
      sortDirection: 'DESC'
    });
    
    // Filter to time window
    const recentLogs = logs.result.filter(log =>
      new Date(log.createdAt) >= new Date(sinceTime)
    );
    
    if (recentLogs.length === 0) return 100;
    
    const successful = recentLogs.filter(log =>
      log.deliveryStatus >= 200 && log.deliveryStatus < 300
    ).length;
    
    return (successful / recentLogs.length) * 100;
  }
  
  async getRetryRate(webhookId, minutes = 60) {
    const sinceTime = new Date(Date.now() - minutes * 60 * 1000).toISOString();
    
    const logs = await this.getDeliveryLogs(webhookId);
    
    const recentLogs = logs.result.filter(log =>
      new Date(log.createdAt) >= new Date(sinceTime)
    );
    
    if (recentLogs.length === 0) return 0;
    
    const retried = recentLogs.filter(log =>
      log.deliveryAttempt > 1
    ).length;
    
    return (retried / recentLogs.length) * 100;
  }
  
  async checkHealth(webhookId) {
    const successRate = await this.calculateSuccessRate(webhookId, 60);
    const retryRate = await this.getRetryRate(webhookId, 60);
    
    const health = {
      webhookId,
      successRate,
      retryRate,
      status: 'healthy',
      issues: []
    };
    
    // Check success rate
    if (successRate < 95) {
      health.status = 'degraded';
      health.issues.push({
        type: 'low_success_rate',
        severity: successRate < 90 ? 'critical' : 'warning',
        message: `Success rate ${successRate.toFixed(2)}% is below threshold`
      });
    }
    
    // Check retry rate
    if (retryRate > 10) {
      health.status = 'degraded';
      health.issues.push({
        type: 'high_retry_rate',
        severity: retryRate > 20 ? 'critical' : 'warning',
        message: `Retry rate ${retryRate.toFixed(2)}% is above threshold`
      });
    }
    
    return health;
  }
}

// Usage
const monitor = new WebhookMonitor(process.env.FN_ACCESS_TOKEN);

async function runHealthCheck() {
  const webhookIds = ['wh_abc123', 'wh_def456'];
  
  for (const webhookId of webhookIds) {
    const health = await monitor.checkHealth(webhookId);
    
    console.log(`\nWebhook: ${webhookId}`);
    console.log(`Status: ${health.status}`);
    console.log(`Success Rate: ${health.successRate.toFixed(2)}%`);
    console.log(`Retry Rate: ${health.retryRate.toFixed(2)}%`);
    
    if (health.issues.length > 0) {
      console.log('Issues:');
      health.issues.forEach(issue => {
        console.log(`  - [${issue.severity}] ${issue.message}`);
      });
      
      // Send alerts
      await sendAlert(health);
    }
  }
}

// Run every 5 minutes
setInterval(runHealthCheck, 5 * 60 * 1000);
```

---

## Application-Level Monitoring

Track your webhook processing metrics:

### Prometheus Metrics

```javascript title="metrics.js"
const prometheus = require('prom-client');

// Register default metrics
prometheus.collectDefaultMetrics();

// Webhook-specific metrics
const webhooksReceived = new prometheus.Counter({
  name: 'webhooks_received_total',
  help: 'Total webhooks received',
  labelNames: ['event_name', 'webhook_id']
});

const webhooksProcessed = new prometheus.Counter({
  name: 'webhooks_processed_total',
  help: 'Total webhooks processed',
  labelNames: ['event_name', 'status']
});

const webhookProcessingDuration = new prometheus.Histogram({
  name: 'webhook_processing_duration_seconds',
  help: 'Webhook processing duration',
  labelNames: ['event_name'],
  buckets: [0.1, 0.5, 1, 2, 5, 10, 30]
});

const webhookQueueSize = new prometheus.Gauge({
  name: 'webhook_queue_size',
  help: 'Number of webhooks in processing queue'
});

const webhookErrors = new prometheus.Counter({
  name: 'webhook_errors_total',
  help: 'Total webhook processing errors',
  labelNames: ['event_name', 'error_type']
});

// Usage
app.post('/webhooks/fieldnation', async (req, res) => {
  const payload = JSON.parse(req.body.toString());
  
  webhooksReceived.inc({
    event_name: payload.eventName,
    webhook_id: req.headers['x-fn-webhook-id']
  });
  
  // Queue and process...
  res.status(200).send('OK');
});

// Metrics endpoint
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', prometheus.register.contentType);
  res.end(await prometheus.register.metrics());
});
```

### Grafana Dashboard

Create a Grafana dashboard with these panels:

  
    ```
    # Success rate over 5 minutes
    sum(rate(webhooks_processed_total{status="success"}[5m]))
    /
    sum(rate(webhooks_processed_total[5m]))
    * 100
    
    # Alert if < 95%
    ```
  
  
    ```
    # p95 processing latency
    histogram_quantile(0.95,
      sum(rate(webhook_processing_duration_seconds_bucket[5m])) by (le)
    )
    
    # Alert if > 5 seconds
    ```
  
  
    ```
    # Errors per minute
    sum(rate(webhook_errors_total[1m])) by (error_type)
    
    # Alert if > 10/minute
    ```
  
  
    ```
    # Current queue size
    webhook_queue_size
    
    # Alert if > 1000
    ```
  

---

## Alerting Rules

Set up alerts for critical conditions:

### Alert Definitions

  
    ```yaml
    - alert: WebhookSuccessRateLow
      expr: |
        sum(rate(webhooks_processed_total{status="success"}[5m]))
        /
        sum(rate(webhooks_processed_total[5m]))
        < 0.95
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Webhook success rate below 95%"
        description: "Success rate is {{ $value | humanizePercentage }} over the last 5 minutes"
    
    - alert: WebhookSuccessRateCritical
      expr: |
        sum(rate(webhooks_processed_total{status="success"}[5m]))
        /
        sum(rate(webhooks_processed_total[5m]))
        < 0.90
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "Webhook success rate below 90%"
        description: "CRITICAL: Success rate is {{ $value | humanizePercentage }}"
    ```
  
  
    ```yaml
    - alert: WebhookHighRetryRate
      expr: |
        sum(rate(webhooks_processed_total{status="retry"}[10m]))
        /
        sum(rate(webhooks_processed_total[10m]))
        > 0.10
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "High webhook retry rate"
        description: "{{ $value | humanizePercentage }} of webhooks require retries"
    ```
  
  
    ```yaml
    - alert: WebhookQueueBuildup
      expr: webhook_queue_size > 1000
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Webhook queue size growing"
        description: "Queue has {{ $value }} pending webhooks"
    
    - alert: WebhookQueueCritical
      expr: webhook_queue_size > 5000
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "Webhook queue critically large"
        description: "CRITICAL: Queue has {{ $value }} pending webhooks"
    ```
  
  
    ```yaml
    - alert: WebhookProcessingErrors
      expr: sum(rate(webhook_errors_total[5m])) > 10
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High webhook processing error rate"
        description: "{{ $value }} errors per minute"
    ```
  

### Alert Destinations

```yaml
# alertmanager.yml
route:
  receiver: 'webhook-team'
  group_by: ['alertname', 'severity']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 4h
  
  routes:
    - match:
        severity: critical
      receiver: 'pagerduty'
    
    - match:
        severity: warning
      receiver: 'slack'

receivers:
  - name: 'webhook-team'
    email_configs:
      - to: 'webhooks-team@example.com'
  
  - name: 'pagerduty'
    pagerduty_configs:
      - service_key: '<pagerduty_key>'
  
  - name: 'slack'
    slack_configs:
      - api_url: '<slack_webhook_url>'
        channel: '#webhooks-alerts'
```

---

## Logging Best Practices

### Structured Logging

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  defaultMeta: { service: 'webhook-processor' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// Log webhook receipt
logger.info('Webhook received', {
  eventId: payload.eventId,
  eventName: payload.eventName,
  workOrderId: payload.workOrderId,
  webhookId: req.headers['x-fn-webhook-id'],
  deliveryId: req.headers['x-fn-delivery-id']
});

// Log processing success
logger.info('Webhook processed', {
  eventId: payload.eventId,
  duration: processingTime,
  status: 'success'
});

// Log errors with context
logger.error('Webhook processing failed', {
  eventId: payload.eventId,
  eventName: payload.eventName,
  error: error.message,
  stack: error.stack,
  retryable: isRetriable(error)
});
```

### Log Aggregation

Use tools like ELK Stack, Datadog, or CloudWatch:

```javascript
// CloudWatch Logs
const AWS = require('aws-sdk');
const cloudwatchlogs = new AWS.CloudWatchLogs();

async function logToCloudWatch(logGroupName, logStreamName, message) {
  await cloudwatchlogs.putLogEvents({
    logGroupName,
    logStreamName,
    logEvents: [{
      message: JSON.stringify(message),
      timestamp: Date.now()
    }]
  }).promise();
}
```

---

## Dashboard Examples

### Real-Time Health Dashboard

```javascript title="health-dashboard.js"
const express = require('express');
const app = express();

app.get('/health', async (req, res) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    checks: {
      webhookEndpoint: await checkEndpoint(),
      queueHealth: await checkQueue(),
      deliveryLogs: await checkDeliveryLogs(),
      downstream: await checkDownstreamServices()
    }
  };
  
  // Determine overall status
  const hasErrors = Object.values(health.checks).some(check => !check.healthy);
  health.status = hasErrors ? 'unhealthy' : 'healthy';
  
  res.status(hasErrors ? 503 : 200).json(health);
});

async function checkEndpoint() {
  try {
    // Check if endpoint is responsive
    const response = await fetch('https://your-endpoint.com/health');
    return {
      healthy: response.ok,
      latency: response.headers.get('x-response-time')
    };
  } catch (error) {
    return { healthy: false, error: error.message };
  }
}

async function checkQueue() {
  const queueSize = await getQueueSize();
  return {
    healthy: queueSize < 1000,
    queueSize,
    threshold: 1000
  };
}

async function checkDeliveryLogs() {
  const monitor = new WebhookMonitor(process.env.FN_ACCESS_TOKEN);
  const successRate = await monitor.calculateSuccessRate('wh_abc123', 60);
  
  return {
    healthy: successRate > 95,
    successRate,
    threshold: 95
  };
}

async function checkDownstreamServices() {
  // Check Salesforce, database, etc.
  return { healthy: true };
}

app.listen(3001);
```

---

## Debugging Tools

### Webhook Request Inspector

```javascript
// Log incoming webhook details
app.post('/webhooks/fieldnation/debug', express.raw({ type: 'application/json' }), (req, res) => {
  const debug = {
    timestamp: new Date().toISOString(),
    method: req.method,
    url: req.url,
    headers: req.headers,
    body: req.body.toString(),
    signature: req.headers['x-fn-signature'],
    webhookId: req.headers['x-fn-webhook-id'],
    eventName: req.headers['x-fn-event-name'],
    deliveryId: req.headers['x-fn-delivery-id']
  };
  
  console.log('=== WEBHOOK DEBUG ===');
  console.log(JSON.stringify(debug, null, 2));
  
  res.status(200).send('OK');
});
```

### Replay Failed Events

```javascript
async function replayFailedEvents(webhookId, since) {
  const logs = await getDeliveryLogs(webhookId, {
    deliveryStatus: '500',
    sortBy: 'createdAt',
    sortDirection: 'DESC'
  });
  
  for (const log of logs.result) {
    if (new Date(log.createdAt) < since) continue;
    
    console.log(`Retrying delivery: ${log.deliveryId}`);
    
    await fetch(
      `https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/${log.deliveryId}/retry`,
      {
        method: 'PATCH',
        headers: { 'Authorization': `Bearer ${accessToken}` }
      }
    );
  }
}
```

---

## Monitoring Checklist

- ✅ Track delivery success rate (>99%)
- ✅ Monitor processing latency (&lt;5s p95)
- ✅ Alert on high retry rates (>10%)
- ✅ Watch queue depth (&lt;100)
- ✅ Track error rates by type
- ✅ Monitor downstream service health
- ✅ Set up automated health checks
- ✅ Configure alerts to Slack/PagerDuty
- ✅ Implement structured logging
- ✅ Create dashboards for visibility

---

---

### undefined
URL: /docs/webhooks/guides/security

# Webhooks: undefined
URL: /docs/webhooks/guides/security
Source: content/docs/webhooks/guides/security.mdx

---
title: Security Best Practices
description: Secure your webhook endpoints with HMAC-SHA256 signature verification, IP whitelisting, HTTPS, and custom authentication headers.
---

## Security Layers

Implement multiple security layers for defense in depth:

```mermaid
graph TD
    A[Incoming Webhook] -->|Layer 1| B{HTTPS?}
    B -->|No| C[Reject]
    B -->|Yes| D{IP Whitelisted?}
    D -->|No| E[Reject]
    D -->|Yes| F{Valid Signature?}
    F -->|No| G[Reject]
    F -->|Yes| H{Custom Auth?}
    H -->|No| I[Reject]
    H -->|Yes| J[Process Event]
    
    style C fill:#ff6b6b
    style E fill:#ff6b6b
    style G fill:#ff6b6b
    style I fill:#ff6b6b
    style J fill:#51cf66
```

---

## 1. HTTPS Only

**Critical**: Always use HTTPS endpoints. Field Nation rejects HTTP webhook URLs.

### Why HTTPS Matters

- **Encryption**: Protects data in transit from eavesdropping
- **Integrity**: Prevents man-in-the-middle attacks
- **Authentication**: Verifies server identity

### SSL Certificate Requirements

Your endpoint must have a valid SSL certificate:

✅ **Valid Certificates**:
- Certificates from trusted CAs (Let's Encrypt, DigiCert, etc.)
- Wildcard certificates (`*.example.com`)
- Multi-domain certificates (SAN)

❌ **Invalid Certificates**:
- Self-signed certificates
- Expired certificates
- Mismatched domain names

### Testing Your Certificate

```bash
# Check SSL certificate validity
curl -v https://your-endpoint.com/webhooks

# Should see:
# * SSL connection using TLSv1.3
# * Server certificate:
# *  subject: CN=your-endpoint.com
# *  issuer: CN=Let's Encrypt Authority
# *  SSL certificate verify ok
```

### Free SSL with Let's Encrypt

```bash
# Install certbot
sudo apt-get install certbot

# Get certificate
sudo certbot certonly --standalone -d your-endpoint.com

# Auto-renewal
sudo certbot renew --dry-run
```

---

## 2. Signature Verification (HMAC-SHA256)

**Essential**: Always verify webhook signatures to ensure requests come from Field Nation.

### How It Works

1. Field Nation generates HMAC-SHA256 hash of request body using your webhook secret
2. Hash is sent in `x-fn-signature` header
3. You recompute the hash with your secret
4. Compare hashes using timing-safe comparison

### Signature Format

```plaintext
x-fn-signature: sha256=abc123def456...
```

Format: `{algorithm}={hex_digest}`

---

### Implementation Examples

  
    ```javascript
    const crypto = require('crypto');
    const express = require('express');
    const app = express();

    // IMPORTANT: Use raw body parser
    app.use(express.raw({ type: 'application/json' }));

    function verifyWebhookSignature(rawBody, signature, secret) {
      if (!signature) {
        return false;
      }
      
      // Parse algorithm and hash from signature
      const [algorithm, requestHash] = signature.split('=');
      
      if (algorithm !== 'sha256') {
        return false;
      }
      
      // Compute expected hash
      const expectedHash = crypto
        .createHmac('sha256', secret)
        .update(rawBody)
        .digest('hex');
      
      // Timing-safe comparison
      try {
        return crypto.timingSafeEqual(
          Buffer.from(expectedHash, 'hex'),
          Buffer.from(requestHash, 'hex')
        );
      } catch {
        return false;
      }
    }

    app.post('/webhooks/fieldnation', (req, res) => {
      const signature = req.headers['x-fn-signature'];
      const secret = process.env.WEBHOOK_SECRET;
      
      // Verify signature
      if (!verifyWebhookSignature(req.body, signature, secret)) {
        console.error('Invalid webhook signature');
        return res.status(401).send('Unauthorized');
      }
      
      // Signature valid, process webhook
      const payload = JSON.parse(req.body.toString());
      console.log('Verified webhook:', payload.eventName);
      
      res.status(200).send('OK');
    });

    app.listen(3000);
    ```
    
    > **Critical**: Use raw body (`Buffer`) for signature verification, not parsed JSON. Parsing changes formatting and breaks signature validation.
  
  
    ```python
    import os
    import hmac
    import hashlib
    from flask import Flask, request

    app = Flask(__name__)

    def verify_webhook_signature(body, signature, secret):
        if not signature:
            return False
        
        # Parse algorithm and hash
        try:
            algorithm, request_hash = signature.split('=')
        except ValueError:
            return False
        
        if algorithm != 'sha256':
            return False
        
        # Compute expected hash
        expected_hash = hmac.new(
            secret.encode('utf-8'),
            body,
            hashlib.sha256
        ).hexdigest()
        
        # Timing-safe comparison
        return hmac.compare_digest(expected_hash, request_hash)

    @app.route('/webhooks/fieldnation', methods=['POST'])
    def handle_webhook():
        signature = request.headers.get('x-fn-signature')
        secret = os.environ['WEBHOOK_SECRET']
        body = request.get_data()
        
        # Verify signature
        if not verify_webhook_signature(body, signature, secret):
            print('Invalid webhook signature')
            return 'Unauthorized', 401
        
        # Signature valid, process webhook
        payload = request.get_json()
        print(f"Verified webhook: {payload['eventName']}")
        
        return 'OK', 200

    if __name__ == '__main__':
        app.run(port=3000)
    ```
  
  
    ```php
    <?php
    function verifyWebhookSignature($body, $signature, $secret) {
        if (empty($signature)) {
            return false;
        }
        
        // Parse algorithm and hash
        $parts = explode('=', $signature, 2);
        if (count($parts) !== 2) {
            return false;
        }
        
        [$algorithm, $requestHash] = $parts;
        
        if ($algorithm !== 'sha256') {
            return false;
        }
        
        // Compute expected hash
        $expectedHash = hash_hmac('sha256', $body, $secret);
        
        // Timing-safe comparison
        return hash_equals($expectedHash, $requestHash);
    }

    // Get request data
    $signature = $_SERVER['HTTP_X_FN_SIGNATURE'] ?? '';
    $secret = getenv('WEBHOOK_SECRET');
    $body = file_get_contents('php://input');

    // Verify signature
    if (!verifyWebhookSignature($body, $signature, $secret)) {
        error_log('Invalid webhook signature');
        http_response_code(401);
        exit('Unauthorized');
    }

    // Signature valid, process webhook
    $payload = json_decode($body, true);
    error_log("Verified webhook: " . $payload['eventName']);

    http_response_code(200);
    echo 'OK';
    ?>
    ```
  
  
    ```go
    package main

    import (
        "crypto/hmac"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/hex"
        "io"
        "log"
        "net/http"
        "os"
        "strings"
    )

    func verifyWebhookSignature(body []byte, signature, secret string) bool {
        if signature == "" {
            return false
        }
        
        // Parse algorithm and hash
        parts := strings.SplitN(signature, "=", 2)
        if len(parts) != 2 {
            return false
        }
        
        algorithm, requestHash := parts[0], parts[1]
        
        if algorithm != "sha256" {
            return false
        }
        
        // Compute expected hash
        h := hmac.New(sha256.New, []byte(secret))
        h.Write(body)
        expectedHash := hex.EncodeToString(h.Sum(nil))
        
        // Timing-safe comparison
        return subtle.ConstantTimeCompare(
            []byte(expectedHash),
            []byte(requestHash),
        ) == 1
    }

    func handleWebhook(w http.ResponseWriter, r *http.Request) {
        signature := r.Header.Get("x-fn-signature")
        secret := os.Getenv("WEBHOOK_SECRET")
        
        // Read body
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "Bad request", http.StatusBadRequest)
            return
        }
        
        // Verify signature
        if !verifyWebhookSignature(body, signature, secret) {
            log.Println("Invalid webhook signature")
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // Signature valid, process webhook
        log.Println("Verified webhook")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    }

    func main() {
        http.HandleFunc("/webhooks/fieldnation", handleWebhook)
        log.Fatal(http.Listen AndServe(":3000", nil))
    }
    ```
  
  
    ```ruby
    require 'sinatra'
    require 'openssl'
    require 'json'

    def verify_webhook_signature(body, signature, secret)
      return false if signature.nil? || signature.empty?
      
      # Parse algorithm and hash
      algorithm, request_hash = signature.split('=', 2)
      return false if algorithm != 'sha256'
      
      # Compute expected hash
      expected_hash = OpenSSL::HMAC.hexdigest(
        'sha256',
        secret,
        body
      )
      
      # Timing-safe comparison
      Rack::Utils.secure_compare(expected_hash, request_hash)
    end

    post '/webhooks/fieldnation' do
      signature = request.env['HTTP_X_FN_SIGNATURE']
      secret = ENV['WEBHOOK_SECRET']
      body = request.body.read
      
      # Verify signature
      unless verify_webhook_signature(body, signature, secret)
        puts 'Invalid webhook signature'
        halt 401, 'Unauthorized'
      end
      
      # Signature valid, process webhook
      payload = JSON.parse(body)
      puts "Verified webhook: #{payload['eventName']}"
      
      status 200
      body 'OK'
    end
    ```
  

### Common Signature Verification Mistakes

  
    **Wrong**:
    ```javascript
    app.use(express.json());
    const hash = crypto.createHmac('sha256', secret)
      .update(JSON.stringify(req.body)) // ❌ Won't match
      .digest('hex');
    ```
    
    **Correct**:
    ```javascript
    app.use(express.raw({ type: 'application/json' }));
    const hash = crypto.createHmac('sha256', secret)
      .update(req.body) // ✅ Raw buffer
      .digest('hex');
    ```
  
  
    **Wrong**:
    ```javascript
    if (expectedHash === requestHash) { // ❌ Vulnerable to timing attacks
      return true;
    }
    ```
    
    **Correct**:
    ```javascript
    return crypto.timingSafeEqual( // ✅ Timing-safe
      Buffer.from(expectedHash),
      Buffer.from(requestHash)
    );
    ```
  
  
    **Wrong**:
    ```python
    # request_hash is hex string, but comparing with bytes
    return expected_hash == request_hash.encode()
    ```
    
    **Correct**:
    ```python
    # Both as hex strings
    expected_hash = hmac.new(secret, body, hashlib.sha256).hexdigest()
    return hmac.compare_digest(expected_hash, request_hash)
    ```
  

---

## 3. IP Whitelisting

Restrict webhook delivery to Field Nation's IP addresses for an additional security layer.

### Field Nation IP Addresses

  
    ```plaintext
    44.225.211.232
    44.237.253.26
    ```
  
  
    ```plaintext
    3.226.5.230
    34.198.172.230
    ```
  

> **Important**: These IPs may change. Subscribe to Field Nation's infrastructure updates or check documentation regularly.

### Implementation Examples

  
    ```nginx
    # /etc/nginx/sites-available/your-site
    
    geo $is_fieldnation {
        default 0;
        
        # Sandbox IPs
        44.225.211.232 1;
        44.237.253.26 1;
        
        # Production IPs
        3.226.5.230 1;
        34.198.172.230 1;
    }
    
    server {
        listen 443 ssl;
        server_name your-endpoint.com;
        
        location /webhooks/fieldnation {
            if ($is_fieldnation = 0) {
                return 403;
            }
            
            proxy_pass http://localhost:3000;
        }
    }
    ```
  
  
    ```apache
    # /etc/apache2/sites-available/your-site.conf
    
    <VirtualHost *:443>
        ServerName your-endpoint.com
        
        <Location /webhooks/fieldnation>
            # Require Field Nation IPs
            Require ip 44.225.211.232
            Require ip 44.237.253.26
            Require ip 3.226.5.230
            Require ip 34.198.172.230
        </Location>
    </VirtualHost>
    ```
  
  
    ```bash
    # AWS CLI - Create security group rule
    
    # Sandbox IPs
    aws ec2 authorize-security-group-ingress \
      --group-id sg-xxx \
      --protocol tcp \
      --port 443 \
      --cidr 44.225.211.232/32
    
    aws ec2 authorize-security-group-ingress \
      --group-id sg-xxx \
      --protocol tcp \
      --port 443 \
      --cidr 44.237.253.26/32
    
    # Production IPs
    aws ec2 authorize-security-group-ingress \
      --group-id sg-xxx \
      --protocol tcp \
      --port 443 \
      --cidr 3.226.5.230/32
    
    aws ec2 authorize-security-group-ingress \
      --group-id sg-xxx \
      --protocol tcp \
      --port 443 \
      --cidr 34.198.172.230/32
    ```
  
  
    ```javascript
    const express = require('express');
    const app = express();

    const FIELDNATION_IPS = [
      '44.225.211.232', // Sandbox
      '44.237.253.26',  // Sandbox
      '3.226.5.230',    // Production
      '34.198.172.230'  // Production
    ];

    function ipWhitelist(req, res, next) {
      // Get client IP (handle X-Forwarded-For if behind proxy)
      const clientIP = req.headers['x-forwarded-for']?.split(',')[0].trim()
        || req.socket.remoteAddress;
      
      // Check if IP is whitelisted
      if (!FIELDNATION_IPS.includes(clientIP)) {
        console.error(`Rejected request from non-whitelisted IP: ${clientIP}`);
        return res.status(403).send('Forbidden');
      }
      
      next();
    }

    // Apply to webhook endpoints
    app.use('/webhooks/fieldnation', ipWhitelist);

    app.post('/webhooks/fieldnation', (req, res) => {
      // Process webhook
      res.status(200).send('OK');
    });
    ```
  

---

## 4. Custom Authentication Headers

Add your own authentication layer using custom headers configured in the webhook.

### Setting Up Custom Headers

When creating the webhook:

```json
{
  "url": "https://your-endpoint.com/webhooks",
  "webhookAttribute": {
    "header": {
      "Authorization": "Bearer your-secret-api-token",
      "X-API-Key": "your-api-key",
      "X-Webhook-Secret": "additional-secret"
    }
  }
}
```

### Validating Custom Headers

```javascript
function validateCustomAuth(req) {
  const authHeader = req.headers['authorization'];
  const apiKey = req.headers['x-api-key'];
  
  // Validate Authorization header
  if (authHeader !== `Bearer ${process.env.API_TOKEN}`) {
    return false;
  }
  
  // Validate API key
  if (apiKey !== process.env.API_KEY) {
    return false;
  }
  
  return true;
}

app.post('/webhooks/fieldnation', (req, res) => {
  // Verify signature first
  if (!verifySignature(req.body, req.headers['x-fn-signature'])) {
    return res.status(401).send('Invalid signature');
  }
  
  // Then check custom auth
  if (!validateCustomAuth(req)) {
    return res.status(401).send('Invalid authentication');
  }
  
  // All checks passed, process webhook
  res.status(200).send('OK');
});
```

> [INFO] **Best Practice**: Use custom headers for additional authentication, but **always** verify Field Nation's signature first. Custom headers alone are not sufficient security.

---

## 5. Rate Limiting

Protect your endpoint from potential abuse with rate limiting:

###Express Rate Limit

```javascript
const rateLimit = require('express-rate-limit');

const webhookLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 100, // 100 requests per minute
  message: 'Too many webhook requests',
  standardHeaders: true,
  legacyHeaders: false
});

app.use('/webhooks/fieldnation', webhookLimiter);
```

### nginx Rate Limiting

```nginx
# Define rate limit zone (10 req/sec)
limit_req_zone $binary_remote_addr zone=webhook_limit:10m rate=10r/s;

server {
    location /webhooks/fieldnation {
        # Apply rate limit
        limit_req zone=webhook_limit burst=20 nodelay;
        
        proxy_pass http://localhost:3000;
    }
}
```

---

## 6. Logging & Monitoring

Log security events for auditing and incident response:

### What to Log

```javascript
function logSecurityEvent(type, details) {
  const event = {
    timestamp: new Date().toISOString(),
    type,
    ...details
  };
  
  console.log(JSON.stringify(event));
  
  // Send to monitoring system
  if (type === 'security_violation') {
    alertSecurityTeam(event);
  }
}

app.post('/webhooks/fieldnation', (req, res) => {
  const clientIP = req.socket.remoteAddress;
  
  // Log all webhook attempts
  logSecurityEvent('webhook_attempt', {
    ip: clientIP,
    eventName: req.headers['x-fn-event-name']
  });
  
  // Verify signature
  if (!verifySignature(req.body, req.headers['x-fn-signature'])) {
    logSecurityEvent('security_violation', {
      reason: 'invalid_signature',
      ip: clientIP
    });
    return res.status(401).send('Unauthorized');
  }
  
  // Log successful verification
  logSecurityEvent('webhook_verified', {
    ip: clientIP,
    eventId: JSON.parse(req.body.toString()).eventId
  });
  
  res.status(200).send('OK');
});
```

### What NOT to Log

> **Never log**:
- Webhook secrets
- Raw request bodies (may contain PII)
- Authorization tokens
- Payment information
- Personal identifying information (PII)

---

## Complete Security Implementation

Here's a production-ready example with all security layers:

```javascript title="secure-webhook-handler.js"
const express = require('express');
const crypto = require('crypto');
const rateLimit = require('express-rate-limit');

const app = express();

// Configuration
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const API_TOKEN = process.env.API_TOKEN;
const FIELDNATION_IPS = [
  '44.225.211.232',
  '44.237.253.26',
  '3.226.5.230',
  '34.198.172.230'
];

// Rate limiting
const webhookLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 100,
  message: 'Too many requests'
});

// Raw body parser (for signature verification)
app.use(express.raw({ type: 'application/json' }));

// IP whitelist middleware
function ipWhitelist(req, res, next) {
  const clientIP = req.headers['x-forwarded-for']?.split(',')[0].trim()
    || req.socket.remoteAddress;
  
  if (!FIELDNATION_IPS.includes(clientIP)) {
    console.error(`Rejected: Non-whitelisted IP ${clientIP}`);
    return res.status(403).send('Forbidden');
  }
  
  next();
}

// Signature verification
function verifySignature(rawBody, signature, secret) {
  if (!signature) return false;
  
  const [algorithm, requestHash] = signature.split('=');
  if (algorithm !== 'sha256') return false;
  
  const expectedHash = crypto
    .createHmac('sha256', secret)
    .update(rawBody)
    .digest('hex');
  
  try {
    return crypto.timingSafeEqual(
      Buffer.from(expectedHash),
      Buffer.from(requestHash)
    );
  } catch {
    return false;
  }
}

// Custom auth validation
function validateCustomAuth(req) {
  const authHeader = req.headers['authorization'];
  return authHeader === `Bearer ${API_TOKEN}`;
}

// Webhook endpoint with all security layers
app.post('/webhooks/fieldnation',
  webhookLimiter,        // Layer 1: Rate limiting
  ipWhitelist,           // Layer 2: IP whitelist
  (req, res) => {
    try {
      // Layer 3: Signature verification
      const signature = req.headers['x-fn-signature'];
      if (!verifySignature(req.body, signature, WEBHOOK_SECRET)) {
        console.error('Invalid signature');
        return res.status(401).send('Unauthorized');
      }
      
      // Layer 4: Custom authentication
      if (!validateCustomAuth(req)) {
        console.error('Invalid custom authentication');
        return res.status(401).send('Unauthorized');
      }
      
      // All security checks passed
      const payload = JSON.parse(req.body.toString());
      console.log(`Verified webhook: ${payload.eventName}`);
      
      // Respond immediately
      res.status(200).send('OK');
      
      // Process asynchronously
      processWebhookAsync(payload);
      
    } catch (error) {
      console.error('Webhook processing error:', error);
      res.status(500).send('Internal error');
    }
  }
);

async function processWebhookAsync(payload) {
  // Your business logic here
}

app.listen(3000, () => {
  console.log('Secure webhook server running on port 3000');
});
```

---

## Security Checklist

Before going to production:

- ✅ HTTPS with valid SSL certificate
- ✅ Signature verification implemented
- ✅ IP whitelisting configured
- ✅ Custom authentication headers (optional but recommended)
- ✅ Rate limiting enabled
- ✅ Security event logging
- ✅ Monitoring and alerts set up
- ✅ Secrets stored securely (not in code)
- ✅ Error handling doesn't leak sensitive info
- ✅ Regular security audits scheduled

---

---

### undefined
URL: /docs/webhooks/guides/testing

# Webhooks: undefined
URL: /docs/webhooks/guides/testing
Source: content/docs/webhooks/guides/testing.mdx

---
title: Testing Webhooks
description: Test webhooks locally using ngrok, request inspectors, and mock payloads. Strategies for development, staging, and production testing.
---

## Testing Strategy

```mermaid
graph TD
    A[Development] --> B[Local Testing]
    B --> C[ngrok/Localtunnel]
    B --> D[Request Inspectors]
    B --> E[Mock Payloads]
    
    A --> F[Staging]
    F --> G[Full Integration Test]
    F --> H[Load Testing]
    
    F --> I[Production]
    I --> J[Canary Deployment]
    I --> K[Smoke Tests]
    
    style A fill:#e3f2fd
    style F fill:#fff3e0
    style I fill:#c8e6c9
```

---

## Local Testing Tools

### 1. ngrok (Recommended)

**Best for**: Testing with real Field Nation webhooks locally

#### Setup

```bash
# Install ngrok
brew install ngrok/ngrok/ngrok

# Or download from https://ngrok.com/download

# Authenticate
ngrok authtoken YOUR_NGROK_TOKEN

# Start tunnel to local port
ngrok http 3000
```

**Output:**

```plaintext
Session Status                online
Account                       your-account (Plan: Free)
Version                       3.x.x
Region                        United States (us)
Latency                       -
Web Interface                 http://127.0.0.1:4040
Forwarding                    https://abc123.ngrok-free.app -> http://localhost:3000

Connections                   ttl     opn     rt1     rt5     p50     p90
                              0       0       0.00    0.00    0.00    0.00
```

#### Using ngrok URL

1. **Copy the HTTPS URL**: `https://abc123.ngrok-free.app`
2. **Create webhook** with URL: `https://abc123.ngrok-free.app/webhooks/fieldnation`
3. **Test**: Trigger events in Field Nation sandbox

> [INFO] **Web Interface**: Visit `http://127.0.0.1:4040` to see all requests in real-time, including headers and payloads.

#### Advanced ngrok Configuration

```yaml title="ngrok.yml"
version: "2"
authtoken: YOUR_NGROK_TOKEN

tunnels:
  webhook:
    proto: http
    addr: 3000
    hostname: your-custom-domain.ngrok-free.app
    inspect: true
    bind_tls: true
```

Start named tunnel:

```bash
ngrok start webhook
```

---

### 2. localtunnel

**Alternative to ngrok** - no account required

```bash
# Install
npm install -g localtunnel

# Start tunnel
lt --port 3000 --subdomain my-webhook

# Output: https://my-webhook.loca.lt
```

---

### 3. Request Inspectors

Perfect for viewing webhook payloads without writing code.

#### webhook.site

1. Visit [webhook.site](https://webhook.site)
2. Copy your unique URL
3. Create webhook with that URL
4. View requests in real-time

**Features:**
- No signup required
- See headers, body, query params
- Custom responses
- Request history

#### RequestBin / Request.bin

Similar to webhook.site:

1. Visit [requestbin.com](https://requestbin.com)
2. Create a bin
3. Use bin URL as webhook endpoint
4. View all requests

---

## Local Development Setup

### Complete Testing Environment

```javascript title="test-webhook-server.js"
const express = require('express');
const crypto = require('crypto');
const app = express();

// Environment
const PORT = process.env.PORT || 3000;
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET || 'test-secret';

// Middleware
app.use(express.raw({ type: 'application/json' }));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Webhook endpoint with full logging
app.post('/webhooks/fieldnation', (req, res) => {
  console.log('\n=== WEBHOOK RECEIVED ===');
  console.log('Timestamp:', new Date().toISOString());
  
  // Log headers
  console.log('\nHeaders:');
  Object.entries(req.headers).forEach(([key, value]) => {
    if (key.startsWith('x-fn-') || key === 'content-type') {
      console.log(`  ${key}: ${value}`);
    }
  });
  
  // Verify signature
  const signature = req.headers['x-fn-signature'];
  const isValid = verifySignature(req.body, signature, WEBHOOK_SECRET);
  console.log(`\nSignature Valid: ${isValid}`);
  
  if (!isValid) {
    console.log('❌ SIGNATURE VERIFICATION FAILED');
    return res.status(401).send('Unauthorized');
  }
  
  // Parse payload
  const payload = JSON.parse(req.body.toString());
  
  // Log event details
  console.log('\nEvent Details:');
  console.log(`  Event ID: ${payload.eventId}`);
  console.log(`  Event Name: ${payload.eventName}`);
  console.log(`  Work Order ID: ${payload.workOrderId}`);
  console.log(`  Timestamp: ${payload.timestamp}`);
  
  // Log payload preview
  console.log('\nPayload Preview:');
  console.log(JSON.stringify(payload, null, 2).substring(0, 500) + '...');
  
  console.log('\n✅ Webhook processed successfully');
  console.log('=======================\n');
  
  // Respond
  res.status(200).send('OK');
});

function verifySignature(rawBody, signature, secret) {
  if (!signature) return false;
  
  const [algorithm, hash] = signature.split('=');
  const expectedHash = crypto
    .createHmac(algorithm, secret)
    .update(rawBody)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(expectedHash),
    Buffer.from(hash)
  );
}

app.listen(PORT, () => {
  console.log(`🚀 Webhook test server running on port ${PORT}`);
  console.log(`📝 Health check: http://localhost:${PORT}/health`);
  console.log(`📨 Webhook endpoint: http://localhost:${PORT}/webhooks/fieldnation`);
  console.log(`\n🔐 Using secret: ${WEBHOOK_SECRET}`);
  console.log('\n⏳ Waiting for webhooks...\n');
});
```

**Run:**

```bash
# Set secret (get from webhook creation)
export WEBHOOK_SECRET=your-webhook-secret

# Start server
node test-webhook-server.js

# In another terminal, start ngrok
ngrok http 3000
```

---

## Mock Webhook Payloads

Test your processing logic with realistic payloads:

### Work Order Published Event

```json title="mock-payloads/workorder-published.json"
{
  "eventName": "workorder.status.published",
  "eventId": "evt_test_001",
  "workOrderId": 99999,
  "timestamp": "2025-01-15T10:30:00.000Z",
  "data": {
    "id": 99999,
    "title": "Test Router Installation",
    "description": "This is a test work order for webhook testing",
    "status": "published",
    "type": "installation",
    "schedule": {
      "serviceWindow": {
        "start": "2025-01-20T09:00:00Z",
        "end": "2025-01-20T17:00:00Z",
        "mode": "hours"
      }
    },
    "location": {
      "address1": "123 Test Street",
      "city": "San Francisco",
      "state": "CA",
      "zip": "94105",
      "coordinates": {
        "latitude": 37.7749,
        "longitude": -122.4194
      }
    },
    "pay": {
      "type": "fixed",
      "amount": 250.00,
      "currency": "USD"
    },
    "buyer": {
      "id": 456,
      "name": "Test Company",
      "companyId": 789
    },
    "tags": ["test", "router"],
    "customFields": {
      "testField": "test-value"
    },
    "createdAt": "2025-01-15T10:00:00Z",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

### Work Order Assigned Event

```json title="mock-payloads/workorder-assigned.json"
{
  "eventName": "workorder.status.assigned",
  "eventId": "evt_test_002",
  "workOrderId": 99999,
  "timestamp": "2025-01-15T11:00:00.000Z",
  "data": {
    "id": 99999,
    "title": "Test Router Installation",
    "status": "assigned",
    "provider": {
      "id": 12345,
      "name": "John Test Provider",
      "userId": 67890,
      "rating": 4.8,
      "completedJobs": 150
    },
    "schedule": {
      "serviceWindow": {
        "start": "2025-01-20T09:00:00Z",
        "end": "2025-01-20T17:00:00Z"
      }
    }
  }
}
```

### Send Mock Payload

```bash title="send-mock-webhook.sh"
#!/bin/bash

WEBHOOK_URL="http://localhost:3000/webhooks/fieldnation"
WEBHOOK_SECRET="your-webhook-secret"
PAYLOAD_FILE="mock-payloads/workorder-published.json"

# Read payload
PAYLOAD=$(cat $PAYLOAD_FILE)

# Generate signature
SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | awk '{print $2}')

# Send request
curl -X POST "$WEBHOOK_URL" \
  -H "Content-Type: application/json" \
  -H "x-fn-signature: sha256=$SIGNATURE" \
  -H "x-fn-webhook-id: wh_test_123" \
  -H "x-fn-event-name: workorder.status.published" \
  -H "x-fn-delivery-id: del_test_001" \
  -H "x-fn-timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
  -d "$PAYLOAD" \
  -v
```

**Make executable and run:**

```bash
chmod +x send-mock-webhook.sh
./send-mock-webhook.sh
```

### Node.js Mock Sender

```javascript title="send-mock-webhook.js"
const crypto = require('crypto');
const fetch = require('node-fetch');
const fs = require('fs');

async function sendMockWebhook(payloadPath, webhookUrl, secret) {
  // Read payload
  const payload = JSON.parse(fs.readFileSync(payloadPath, 'utf8'));
  const payloadString = JSON.stringify(payload);
  
  // Generate signature
  const signature = crypto
    .createHmac('sha256', secret)
    .update(payloadString)
    .digest('hex');
  
  // Send request
  const response = await fetch(webhookUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-fn-signature': `sha256=${signature}`,
      'x-fn-webhook-id': 'wh_test_123',
      'x-fn-event-name': payload.eventName,
      'x-fn-delivery-id': `del_test_${Date.now()}`,
      'x-fn-timestamp': new Date().toISOString()
    },
    body: payloadString
  });
  
  console.log('Response Status:', response.status);
  console.log('Response Body:', await response.text());
}

// Usage
sendMockWebhook(
  './mock-payloads/workorder-published.json',
  'http://localhost:3000/webhooks/fieldnation',
  'your-webhook-secret'
);
```

---

## Testing Strategies by Environment

### Development Environment

**Goal**: Rapid iteration and debugging

### Use Request Inspector

Start with webhook.site to see raw payloads without writing code.

### Local Server + ngrok

Once you understand the payload structure, build your handler locally.

### Mock Payloads

Test specific scenarios without triggering real events.

### Signature Verification

Always test signature validation logic.

### Error Scenarios

Test invalid signatures, malformed payloads, timeouts.

---

### Staging Environment

**Goal**: Full integration testing before production

```javascript title="staging-test-suite.js"
const assert = require('assert');

describe('Webhook Integration Tests', () => {
  it('should receive and process work order published event', async () => {
    // 1. Create test work order in sandbox
    const workOrder = await createTestWorkOrder();
    
    // 2. Publish work order (triggers webhook)
    await publishWorkOrder(workOrder.id);
    
    // 3. Wait for webhook processing
    await sleep(5000);
    
    // 4. Verify webhook was received
    const logs = await getProcessedEvents();
    const event = logs.find(log =>
      log.workOrderId === workOrder.id &&
      log.eventName === 'workorder.status.published'
    );
    
    assert.ok(event, 'Webhook event not found');
    assert.equal(event.status, 'processed');
    
    // 5. Verify downstream effects
    const salesforceRecord = await getSalesforceRecord(workOrder.id);
    assert.ok(salesforceRecord, 'Work order not synced to Salesforce');
  });
  
  it('should handle duplicate webhooks idempotently', async () => {
    const payload = getMockPayload();
    
    // Send same webhook twice
    await sendWebhook(payload);
    await sendWebhook(payload);
    
    // Verify processed only once
    const processCount = await getProcessingCount(payload.eventId);
    assert.equal(processCount, 1, 'Webhook processed more than once');
  });
  
  it('should retry failed processing', async () => {
    // Temporarily break downstream service
    await disableSalesforceSync();
    
    // Send webhook
    const payload = getMockPayload();
    await sendWebhook(payload);
    
    // Verify failed
    await sleep(2000);
    let status = await getProcessingStatus(payload.eventId);
    assert.equal(status, 'failed');
    
    // Fix service
    await enableSalesforceSync();
    
    // Verify retry succeeded
    await sleep(15000); // Wait for retry
    status = await getProcessingStatus(payload.eventId);
    assert.equal(status, 'processed');
  });
});
```

**Run staging tests:**

```bash
# Set staging environment
export NODE_ENV=staging
export WEBHOOK_URL=https://staging.example.com/webhooks
export FN_CLIENT_ID=staging-client-id
export FN_CLIENT_SECRET=staging-secret

# Run tests
npm test
```

---

### Production Environment

**Goal**: Verify production deployment without disrupting operations

#### Smoke Tests

```javascript title="production-smoke-test.js"
async function runSmokeTests() {
  const tests = {
    webhookEndpoint: false,
    signatureVerification: false,
    queueHealth: false,
    downstreamServices: false
  };
  
  // Test 1: Webhook endpoint responsive
  try {
    const response = await fetch('https://api.example.com/health');
    tests.webhookEndpoint = response.ok;
  } catch (error) {
    console.error('Webhook endpoint test failed:', error);
  }
  
  // Test 2: Signature verification working
  try {
    const testPayload = getMockPayload();
    const signature = generateSignature(testPayload, process.env.WEBHOOK_SECRET);
    const response = await sendWebhook(testPayload, signature);
    tests.signatureVerification = response.status === 200;
  } catch (error) {
    console.error('Signature test failed:', error);
  }
  
  // Test 3: Queue healthy
  try {
    const queueSize = await getQueueSize();
    tests.queueHealth = queueSize < 1000;
  } catch (error) {
    console.error('Queue health test failed:', error);
  }
  
  // Test 4: Downstream services accessible
  try {
    await Promise.all([
      checkSalesforce(),
      checkDatabase(),
      checkRedis()
    ]);
    tests.downstreamServices = true;
  } catch (error) {
    console.error('Downstream services test failed:', error);
  }
  
  // Report
  const allPassed = Object.values(tests).every(t => t);
  
  console.log('\n=== Smoke Test Results ===');
  Object.entries(tests).forEach(([test, passed]) => {
    console.log(`  ${passed ? '✅' : '❌'} ${test}`);
  });
  console.log(`\nOverall: ${allPassed ? '✅ PASSED' : '❌ FAILED'}`);
  
  return allPassed;
}

// Run after deployment
runSmokeTests().then(passed => {
  process.exit(passed ? 0 : 1);
});
```

#### Canary Deployment

```javascript
// Create separate webhook for testing
const canaryWebhook = await createWebhook({
  url: 'https://api-canary.example.com/webhooks',
  status: 'active',
  events: ['workorder.status.published'], // Single event for testing
  notificationEmail: 'canary-alerts@example.com'
});

// Monitor canary for issues
await monitorCanary(canaryWebhook.webhookId, {
  duration: '1 hour',
  successRateThreshold: 99,
  onSuccess: () => {
    console.log('Canary successful, promoting to production');
    // Update main webhook to new version
  },
  onFailure: () => {
    console.log('Canary failed, rolling back');
    // Deactivate canary, keep old version
  }
});
```

---

## Load Testing

Test webhook handling under high volume:

```javascript title="load-test.js"
const autocannon = require('autocannon');

async function loadTest() {
  const result = await autocannon({
    url: 'http://localhost:3000/webhooks/fieldnation',
    connections: 100,        // Concurrent connections
    duration: 30,            // 30 seconds
    pipelining: 1,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-fn-signature': 'sha256=test-signature',
      'x-fn-webhook-id': 'wh_load_test',
      'x-fn-event-name': 'workorder.status.published'
    },
    body: JSON.stringify(getMockPayload())
  });
  
  console.log('\n=== Load Test Results ===');
  console.log(`Requests: ${result.requests.total}`);
  console.log(`Duration: ${result.duration}s`);
  console.log(`RPS: ${result.requests.average}`);
  console.log(`Latency p50: ${result.latency.p50}ms`);
  console.log(`Latency p95: ${result.latency.p95}ms`);
  console.log(`Latency p99: ${result.latency.p99}ms`);
  console.log(`Errors: ${result.errors}`);
  console.log(`Timeouts: ${result.timeouts}`);
}

loadTest();
```

---

## Testing Checklist

### Local Testing
- ✅ Set up local server with logging
- ✅ Use ngrok for public URL
- ✅ Test with request inspector first
- ✅ Verify signature validation
- ✅ Test with mock payloads
- ✅ Test error scenarios

### Staging Testing
- ✅ Full integration tests
- ✅ Test all event types
- ✅ Verify idempotency
- ✅ Test retry logic
- ✅ Load testing
- ✅ Monitor for 24 hours

### Production Testing
- ✅ Smoke tests after deployment
- ✅ Canary deployment
- ✅ Monitor metrics closely
- ✅ Have rollback plan ready
- ✅ Test error handling
- ✅ Verify monitoring/alerts

---

---

### undefined
URL: /docs/webhooks/troubleshooting/common-issues

# Webhooks: undefined
URL: /docs/webhooks/troubleshooting/common-issues
Source: content/docs/webhooks/troubleshooting/common-issues.mdx

---
title: Common Issues
description: Quick solutions for frequently encountered webhook problems including signature verification, payload parsing, and connectivity issues.
---

## Signature Verification Failures

### Issue

```
❌ Signature verification failed
❌ Unauthorized (401)
```

### Causes & Solutions

  
    **Solution**: Verify you're using the correct webhook secret.
    
    ```javascript
    // ❌ Wrong - using wrong secret
    const secret = 'wrong-secret';
    
    // ✅ Correct - use secret from webhook creation
    const secret = process.env.WEBHOOK_SECRET; // From webhook creation response
    ```
  
  
  
    **Solution**: Verify signature using raw request body, before parsing.
    
    ```javascript
    // ❌ Wrong - body already parsed
    app.use(express.json());
    app.post('/webhooks', (req, res) => {
      verifySignature(req.body, signature, secret); // Will fail!
    });
    
    // ✅ Correct - use raw body
    app.post('/webhooks', express.raw({type: 'application/json'}), (req, res) => {
      verifySignature(req.body, signature, secret); // Works!
    });
    ```
  
  
  
    **Solution**: Extract hash from `sha256=...` format.
    
    ```javascript
    // ❌ Wrong - using full signature string
    const valid = expectedHash === req.headers['x-fn-signature'];
    
    // ✅ Correct - extract hash portion
    const [algorithm, hash] = req.headers['x-fn-signature'].split('=');
    const valid = expectedHash === hash;
    ```
  
  
  
    **Solution**: Ensure raw bytes are used for verification.
    
    ```javascript
    // ✅ Correct approach
    const signature = req.headers['x-fn-signature'];
    const [algorithm, providedHash] = signature.split('=');
    
    const expectedHash = crypto
      .createHmac(algorithm, secret)
      .update(req.body) // Raw buffer
      .digest('hex');
    
    const valid = crypto.timingSafeEqual(
      Buffer.from(expectedHash),
      Buffer.from(providedHash)
    );
    ```
  

[Complete security guide →](/docs/webhooks/guides/security)

---

## Webhooks Not Arriving

### Issue

```
❌ No webhooks received
❌ Events triggering but no delivery
```

### Diagnostic Steps

### Check Webhook Status

```bash
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/wh_abc123 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

Verify `status: "active"` in response.

### Test Endpoint Accessibility

```bash
curl -X POST https://your-endpoint.com/webhooks \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}'
```

Should return 200 OK.

### Check SSL Certificate

```bash
curl -v https://your-endpoint.com/webhooks
```

Look for `SSL certificate verify ok`.

### Review Delivery Logs

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

Look for error patterns in failed deliveries.

### Verify Event Subscription

Ensure webhook is subscribed to the events you're triggering:

```javascript
const webhook = await getWebhook('wh_abc123');
console.log('Subscribed events:', webhook.result.events);
```

---

## Timeout Errors

### Issue

```
❌ Request timeout after 30 seconds
❌ Connection timeout
```

### Solution

Respond immediately, process asynchronously:

```javascript
// ❌ Wrong - slow synchronous processing
app.post('/webhooks', async (req, res) => {
  await verifySignature(req);
  await syncToSalesforce(req.body); // Slow operation
  await updateDatabase(req.body);    // Slow operation
  await sendEmail(req.body);         // Slow operation
  res.status(200).send('OK');        // Too late!
});

// ✅ Correct - respond immediately
app.post('/webhooks', async (req, res) => {
  await verifySignature(req);
  
  // Respond immediately
  res.status(200).send('OK');
  
  // Process asynchronously
  processWebhookAsync(req.body)
    .catch(error => console.error('Processing error:', error));
});
```

[Complete handling guide →](/docs/webhooks/guides/handling-events)

---

## Duplicate Events

### Issue

```
❌ Same event received multiple times
❌ Duplicate processing
```

### Solution

Implement idempotency using `eventId`:

```javascript
const processedEvents = new Set(); // Or Redis/Database

app.post('/webhooks', async (req, res) => {
  const payload = JSON.parse(req.body.toString());
  const { eventId } = payload;
  
  // Check if already processed
  if (processedEvents.has(eventId)) {
    console.log(`Duplicate event ${eventId}, skipping`);
    return res.status(200).send('Already processed');
  }
  
  // Mark as processing
  processedEvents.add(eventId);
  
  try {
    // Process event
    await handleEvent(payload);
    res.status(200).send('OK');
  } catch (error) {
    // Remove on failure to allow retry
    processedEvents.delete(eventId);
    throw error;
  }
});
```

[Complete idempotency guide →](/docs/webhooks/guides/handling-events)

---

## JSON Parsing Errors

### Issue

```
❌ SyntaxError: Unexpected token
❌ Invalid JSON
```

### Solution

Handle raw body correctly:

```javascript
// For signature verification
app.use(express.raw({ type: 'application/json' }));

app.post('/webhooks', (req, res) => {
  try {
    // 1. Verify signature with raw body
    const signature = req.headers['x-fn-signature'];
    verifySignature(req.body, signature, secret);
    
    // 2. Parse JSON
    const payload = JSON.parse(req.body.toString());
    
    // 3. Process
    processWebhook(payload);
    
    res.status(200).send('OK');
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(400).send('Bad request');
  }
});
```

---

## Environment-Specific Issues

### Local Development (ngrok)

**Issue**: ngrok tunnel not accessible

```bash
# ❌ Problem
Error: ngrok tunnel not found

# ✅ Solution
ngrok http 3000 --log=stdout
```

**Issue**: ngrok free tier URL changes

```bash
# ✅ Solution: Use ngrok authtoken for persistent URLs
ngrok authtoken YOUR_TOKEN
ngrok http 3000 --hostname=your-subdomain.ngrok-free.app
```

### Staging/Production

**Issue**: Firewall blocking Field Nation IPs

**Solution**: Whitelist Field Nation IPs:

**Sandbox:**
```
18.215.51.196
3.223.100.250
44.199.193.222
```

**Production:** Contact Field Nation support

[Complete security guide →](/docs/webhooks/guides/security)

---

## Error Response Codes

### Issue

Webhooks retrying when they shouldn't.

### Solution

Return appropriate status codes:

```javascript
app.post('/webhooks', async (req, res) => {
  try {
    // Signature verification failure
    if (!verifySignature(req)) {
      return res.status(401).send('Unauthorized'); // Won't retry
    }
    
    // Invalid payload format
    if (!validatePayload(req.body)) {
      return res.status(400).send('Bad request'); // Won't retry
    }
    
    // Process webhook
    await processEvent(req.body);
    
    // Success
    return res.status(200).send('OK');
    
  } catch (error) {
    if (error.retriable) {
      // Temporary issue - allow retry
      return res.status(500).send('Internal error');
    } else {
      // Permanent issue - don't retry
      return res.status(422).send('Unprocessable');
    }
  }
});
```

| Status | Retry? | Use Case |
|--------|--------|----------|
| 200-299 | No | Success |
| 400 | No | Invalid request |
| 401 | No | Invalid signature |
| 404 | No | Endpoint not found |
| 410 | No | Endpoint gone |
| 422 | No | Unprocessable |
| 500-599 | Yes | Server error |
| Timeout | Yes | Network issue |

[Complete delivery mechanics →](/docs/webhooks/concepts/delivery)

---

## Quick Diagnostic Checklist

When webhooks aren't working, check:

- ☐ Webhook status is `active`
- ☐ Events are subscribed
- ☐ Endpoint is HTTPS (not HTTP)
- ☐ Endpoint is publicly accessible
- ☐ SSL certificate is valid
- ☐ Signature verification is correct
- ☐ Response time &lt; 30 seconds
- ☐ Correct status codes returned
- ☐ Firewall allows Field Nation IPs
- ☐ Delivery logs show no errors

---

---

### undefined
URL: /docs/webhooks/troubleshooting/debugging

# Webhooks: undefined
URL: /docs/webhooks/troubleshooting/debugging
Source: content/docs/webhooks/troubleshooting/debugging.mdx

---
title: Debugging Webhooks
description: Advanced debugging techniques, tools, and strategies for troubleshooting complex webhook integration issues.
---

## Debugging Tools

### Request Inspectors

Perfect for viewing raw webhook payloads during development:

| Tool | URL | Features |
|------|-----|----------|
| **webhook.site** | [webhook.site](https://webhook.site) | No signup, custom responses, request history |
| **RequestBin** | [requestbin.com](https://requestbin.com) | Public/private bins, expiring URLs |
| **ngrok Inspector** | `http://127.0.0.1:4040` | Built-in with ngrok, real-time requests |

### Local Debugging Server

```javascript title="debug-webhook-server.js"
const express = require('express');
const crypto = require('crypto');
const fs = require('fs');
const app = express();

// Raw body for signature verification
app.use(express.raw({ type: 'application/json' }));

// Detailed logging middleware
app.use((req, res, next) => {
  const logEntry = {
    timestamp: new Date().toISOString(),
    method: req.method,
    url: req.url,
    headers: req.headers,
    body: req.body ? req.body.toString() : null
  };
  
  // Log to console
  console.log('\n' + '='.repeat(80));
  console.log('WEBHOOK REQUEST');
  console.log('='.repeat(80));
  console.log(JSON.stringify(logEntry, null, 2));
  
  // Log to file
  fs.appendFileSync('webhook-debug.log', JSON.stringify(logEntry) + '\n');
  
  next();
});

// Webhook endpoint
app.post('/webhooks/fieldnation', (req, res) => {
  try {
    // Extract headers
    const signature = req.headers['x-fn-signature'];
    const webhookId = req.headers['x-fn-webhook-id'];
    const eventName = req.headers['x-fn-event-name'];
    const deliveryId = req.headers['x-fn-delivery-id'];
    const timestamp = req.headers['x-fn-timestamp'];
    
    console.log('\n📋 WEBHOOK HEADERS:');
    console.log(`  Signature: ${signature}`);
    console.log(`  Webhook ID: ${webhookId}`);
    console.log(`  Event: ${eventName}`);
    console.log(`  Delivery ID: ${deliveryId}`);
    console.log(`  Timestamp: ${timestamp}`);
    
    // Verify signature
    const isValid = verifySignature(
      req.body,
      signature,
      process.env.WEBHOOK_SECRET
    );
    
    console.log(`\n🔐 SIGNATURE VERIFICATION: ${isValid ? '✅ VALID' : '❌ INVALID'}`);
    
    if (!isValid) {
      console.log('\n❌ SIGNATURE VERIFICATION FAILED');
      console.log('Expected secret:', process.env.WEBHOOK_SECRET);
      console.log('Received signature:', signature);
      return res.status(401).send('Unauthorized');
    }
    
    // Parse payload
    const payload = JSON.parse(req.body.toString());
    
    console.log('\n📦 PARSED PAYLOAD:');
    console.log(JSON.stringify(payload, null, 2).substring(0, 500) + '...');
    
    console.log('\n✅ WEBHOOK PROCESSED SUCCESSFULLY');
    console.log('='.repeat(80) + '\n');
    
    res.status(200).send('OK');
    
  } catch (error) {
    console.error('\n❌ ERROR PROCESSING WEBHOOK:');
    console.error(error);
    console.log('='.repeat(80) + '\n');
    
    res.status(500).send('Internal error');
  }
});

function verifySignature(rawBody, signature, secret) {
  if (!signature) return false;
  
  const [algorithm, hash] = signature.split('=');
  const expectedHash = crypto
    .createHmac(algorithm, secret)
    .update(rawBody)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(expectedHash),
    Buffer.from(hash)
  );
}

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    secret: process.env.WEBHOOK_SECRET ? 'configured' : 'missing'
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`🚀 Debug webhook server running on port ${PORT}`);
  console.log(`📝 Logs being written to: webhook-debug.log`);
  console.log(`🔐 Webhook secret: ${process.env.WEBHOOK_SECRET || 'NOT SET'}`);
  console.log(`\n⏳ Waiting for webhooks...\n`);
});
```

**Run:**

```bash
export WEBHOOK_SECRET=your-webhook-secret
node debug-webhook-server.js
```

---

## Tracing Request Flow

### End-to-End Trace

```mermaid
sequenceDiagram
    participant FN as Field Nation
    participant LB as Load Balancer
    participant Proxy as Reverse Proxy
    participant App as Your App
    participant DB as Database
    
    FN->>LB: POST /webhooks
    Note over FN,LB: Check: DNS resolution
    
    LB->>Proxy: Forward request
    Note over LB,Proxy: Check: SSL termination
    
    Proxy->>App: Proxy pass
    Note over Proxy,App: Check: Proxy headers
    
    App->>App: Verify signature
    Note over App: Check: Secret match
    
    App->>App: Parse JSON
    Note over App: Check: Valid JSON
    
    App->>DB: Check idempotency
    Note over App,DB: Check: Event ID exists
    
    App->>FN: 200 OK
    Note over App,FN: Response < 30s
    
    activate App
    App->>App: Process async
    deactivate App
```

### Add Trace IDs

```javascript
const { v4: uuidv4 } = require('uuid');

app.post('/webhooks/fieldnation', (req, res) => {
  const traceId = uuidv4();
  const deliveryId = req.headers['x-fn-delivery-id'];
  
  console.log(`[${traceId}] Starting webhook processing`);
  console.log(`[${traceId}] Delivery ID: ${deliveryId}`);
  
  try {
    console.log(`[${traceId}] Verifying signature...`);
    verifySignature(req);
    
    console.log(`[${traceId}] Parsing payload...`);
    const payload = JSON.parse(req.body.toString());
    
    console.log(`[${traceId}] Event: ${payload.eventName}`);
    console.log(`[${traceId}] Work Order: ${payload.workOrderId}`);
    
    console.log(`[${traceId}] Responding 200 OK`);
    res.status(200).send('OK');
    
    console.log(`[${traceId}] Queuing for async processing`);
    queue.add({ ...payload, traceId });
    
  } catch (error) {
    console.error(`[${traceId}] Error: ${error.message}`);
    res.status(500).send('Internal error');
  }
});
```

---

## Network Debugging

### Test with curl

```bash
# Basic test
curl -X POST https://your-endpoint.com/webhooks \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}' \
  -v

# With signature
SECRET="your-secret"
PAYLOAD='{"test":"data"}'
SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$SECRET" | awk '{print $2}')

curl -X POST https://your-endpoint.com/webhooks \
  -H "Content-Type: application/json" \
  -H "x-fn-signature: sha256=$SIGNATURE" \
  -H "x-fn-webhook-id: wh_test" \
  -H "x-fn-event-name: test.event" \
  -H "x-fn-delivery-id: del_test" \
  -d "$PAYLOAD" \
  -v
```

### Check SSL/TLS

```bash
# Verify certificate
openssl s_client -connect your-domain.com:443 -servername your-domain.com

# Check certificate expiry
echo | openssl s_client -servername your-domain.com \
  -connect your-domain.com:443 2>/dev/null | \
  openssl x509 -noout -dates

# Test from specific IP (simulate Field Nation)
curl -X POST https://your-endpoint.com/webhooks \
  --resolve your-domain.com:443:YOUR_SERVER_IP \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}'
```

### Check DNS

```bash
# DNS lookup
dig your-domain.com

# Check propagation
nslookup your-domain.com

# Trace route
traceroute your-domain.com
```

---

## Signature Verification Debugging

### Compare Hashes

```javascript
function debugSignatureVerification(rawBody, signature, secret) {
  console.log('\n🔐 SIGNATURE VERIFICATION DEBUG');
  console.log('='.repeat(50));
  
  // Parse signature
  const [algorithm, providedHash] = signature.split('=');
  console.log(`Algorithm: ${algorithm}`);
  console.log(`Provided hash: ${providedHash}`);
  
  // Calculate expected hash
  const expectedHash = crypto
    .createHmac(algorithm, secret)
    .update(rawBody)
    .digest('hex');
  console.log(`Expected hash: ${expectedHash}`);
  
  // Compare
  const match = expectedHash === providedHash;
  console.log(`\nMatch: ${match ? '✅ YES' : '❌ NO'}`);
  
  if (!match) {
    console.log('\n❌ MISMATCH DETAILS:');
    console.log(`Secret used: ${secret}`);
    console.log(`Body length: ${rawBody.length} bytes`);
    console.log(`Body preview: ${rawBody.toString().substring(0, 100)}...`);
    
    // Try common issues
    console.log('\n🔍 TRYING COMMON ISSUES:');
    
    // Issue 1: Body already parsed
    try {
      const parsedBody = JSON.parse(rawBody.toString());
      const hashFromParsed = crypto
        .createHmac(algorithm, secret)
        .update(JSON.stringify(parsedBody))
        .digest('hex');
      console.log(`Hash from re-stringified JSON: ${hashFromParsed}`);
      console.log(`  Match: ${hashFromParsed === providedHash ? '✅' : '❌'}`);
    } catch (e) {}
    
    // Issue 2: Different secret
    const testSecrets = [
      secret.toUpperCase(),
      secret.toLowerCase(),
      secret.trim()
    ];
    
    testSecrets.forEach(testSecret => {
      const testHash = crypto
        .createHmac(algorithm, testSecret)
        .update(rawBody)
        .digest('hex');
      if (testHash === providedHash) {
        console.log(`  ✅ MATCH with modified secret: "${testSecret}"`);
      }
    });
  }
  
  console.log('='.repeat(50) + '\n');
  
  return match;
}
```

---

## Payload Debugging

### Inspect Payload Structure

```javascript
function debugPayload(payload) {
  console.log('\n📦 PAYLOAD DEBUGGING');
  console.log('='.repeat(50));
  
  // Type and size
  console.log(`Type: ${typeof payload}`);
  console.log(`Size: ${JSON.stringify(payload).length} bytes`);
  
  // Structure
  console.log('\nStructure:');
  console.log(`  eventId: ${payload.eventId}`);
  console.log(`  eventName: ${payload.eventName}`);
  console.log(`  workOrderId: ${payload.workOrderId}`);
  console.log(`  timestamp: ${payload.timestamp}`);
  console.log(`  data keys: ${Object.keys(payload.data || {}).join(', ')}`);
  
  // Validation
  console.log('\nValidation:');
  console.log(`  Has eventId: ${!!payload.eventId ? '✅' : '❌'}`);
  console.log(`  Has eventName: ${!!payload.eventName ? '✅' : '❌'}`);
  console.log(`  Has data: ${!!payload.data ? '✅' : '❌'}`);
  console.log(`  Valid timestamp: ${isValidDate(payload.timestamp) ? '✅' : '❌'}`);
  
  // Content preview
  console.log('\nFull payload:');
  console.log(JSON.stringify(payload, null, 2));
  
  console.log('='.repeat(50) + '\n');
}

function isValidDate(dateString) {
  const date = new Date(dateString);
  return date instanceof Date && !isNaN(date);
}
```

---

## Performance Debugging

### Measure Processing Time

```javascript
async function processWebhookWithTiming(payload) {
  const timings = {};
  
  const start = Date.now();
  timings.start = start;
  
  // Signature verification
  let checkpoint = Date.now();
  await verifySignature(payload);
  timings.signatureVerification = Date.now() - checkpoint;
  
  // Idempotency check
  checkpoint = Date.now();
  const isDuplicate = await checkIdempotency(payload.eventId);
  timings.idempotencyCheck = Date.now() - checkpoint;
  
  if (isDuplicate) {
    timings.total = Date.now() - start;
    console.log('Timings:', timings);
    return;
  }
  
  // Parse and validate
  checkpoint = Date.now();
  validatePayload(payload);
  timings.validation = Date.now() - checkpoint;
  
  // Process
  checkpoint = Date.now();
  await handleEvent(payload);
  timings.processing = Date.now() - checkpoint;
  
  // Total
  timings.total = Date.now() - start;
  
  console.log('\n⏱️  PERFORMANCE TIMINGS:');
  console.log(`  Signature verification: ${timings.signatureVerification}ms`);
  console.log(`  Idempotency check: ${timings.idempotencyCheck}ms`);
  console.log(`  Validation: ${timings.validation}ms`);
  console.log(`  Processing: ${timings.processing}ms`);
  console.log(`  TOTAL: ${timings.total}ms`);
  
  if (timings.total > 5000) {
    console.warn('⚠️  WARNING: Processing took > 5 seconds');
  }
  
  return timings;
}
```

---

## Common Debug Scenarios

### Scenario 1: Webhooks Work Locally, Fail in Production

**Debug Steps:**

```bash
# 1. Check environment variables
echo $WEBHOOK_SECRET

# 2. Test connectivity from production
curl -v https://your-production-endpoint.com/health

# 3. Check production logs
tail -f /var/log/your-app/webhook.log

# 4. Compare environments
diff local.env production.env
```

### Scenario 2: Intermittent Failures

**Debug with Detailed Logging:**

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'webhook-error.log', level: 'error' }),
    new winston.transports.File({ filename: 'webhook-debug.log' })
  ]
});

app.post('/webhooks', async (req, res) => {
  const context = {
    deliveryId: req.headers['x-fn-delivery-id'],
    timestamp: new Date().toISOString(),
    ip: req.ip
  };
  
  logger.debug('Webhook received', context);
  
  try {
    logger.debug('Verifying signature', context);
    await verifySignature(req);
    
    logger.debug('Parsing payload', context);
    const payload = JSON.parse(req.body.toString());
    
    logger.debug('Processing event', { ...context, eventName: payload.eventName });
    await processEvent(payload);
    
    logger.info('Webhook processed successfully', context);
    res.status(200).send('OK');
    
  } catch (error) {
    logger.error('Webhook processing failed', {
      ...context,
      error: error.message,
      stack: error.stack
    });
    res.status(500).send('Internal error');
  }
});
```

---

---

### undefined
URL: /docs/webhooks/troubleshooting/delivery-failures

# Webhooks: undefined
URL: /docs/webhooks/troubleshooting/delivery-failures
Source: content/docs/webhooks/troubleshooting/delivery-failures.mdx

---
title: Delivery Failures
description: Diagnose and resolve specific webhook delivery failure scenarios with detailed error analysis and solutions.
---

## Analyzing Delivery Logs

### Access Delivery Logs

```bash
curl -X GET "https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=wh_abc123&deliveryStatus=500" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Get Detailed Log

```bash
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/del_xyz789 \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

Response includes pre-signed URL to full log file with request/response details.

---

## Common Delivery Errors

### Connection Refused (ECONNREFUSED)

**Error Message:**
```
Error: connect ECONNREFUSED 192.168.1.100:443
```

**Causes:**
- Server not running
- Wrong port
- Firewall blocking connections

**Solutions:**

### Verify Server is Running

```bash
# Check if server is listening
netstat -tulpn | grep :3000

# Or
lsof -i :3000
```

### Test Local Connectivity

```bash
curl -X POST http://localhost:3000/webhooks \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}'
```

### Check Firewall Rules

```bash
# Allow incoming connections
sudo ufw allow 3000/tcp

# Or
sudo iptables -A INPUT -p tcp --dport 3000 -j ACCEPT
```

### Verify ngrok/Tunnel

```bash
# Restart ngrok
ngrok http 3000

# Use new URL in webhook configuration
```

---

### SSL Certificate Error

**Error Message:**
```
Error: self signed certificate
Error: unable to verify the first certificate
```

**Causes:**
- Self-signed certificate
- Expired certificate
- Certificate chain incomplete

**Solutions:**

  
    ```bash
    # Install certbot
    sudo apt-get install certbot python3-certbot-nginx
    
    # Generate certificate
    sudo certbot --nginx -d your-domain.com
    
    # Auto-renew
    sudo certbot renew --dry-run
    ```
  
  
    ```bash
    # Verify certificate
    openssl s_client -connect your-domain.com:443 -servername your-domain.com
    
    # Check expiry
    echo | openssl s_client -servername your-domain.com -connect your-domain.com:443 2>/dev/null | openssl x509 -noout -dates
    ```
  
  
    For local testing only, use ngrok which provides valid HTTPS:
    
    ```bash
    ngrok http 3000
    # Use provided HTTPS URL
    ```
    
    ⚠️ Never use self-signed certificates in production
  

---

### Timeout (30 seconds)

**Error Message:**
```
Error: Timeout of 30000ms exceeded
```

**Cause:** Endpoint takes too long to respond

**Solution:** Implement async processing

```javascript
// ❌ Wrong - slow synchronous processing
app.post('/webhooks', async (req, res) => {
  const result = await slowOperation(); // 35 seconds
  res.status(200).send('OK'); // Timeout already occurred!
});

// ✅ Correct - respond immediately
const queue = new Queue('webhooks');

app.post('/webhooks', async (req, res) => {
  // Quick validation
  if (!verifySignature(req)) {
    return res.status(401).send('Unauthorized');
  }
  
  const payload = JSON.parse(req.body.toString());
  
  // Queue for processing
  await queue.add(payload);
  
  // Respond within 1 second
  res.status(200).send('OK');
});

// Worker processes queue
queue.process(async (job) => {
  await slowOperation(job.data); // Can take as long as needed
});
```

---

### DNS Resolution Failed

**Error Message:**
```
Error: getaddrinfo ENOTFOUND your-domain.com
```

**Causes:**
- Domain doesn't exist
- DNS not propagated
- DNS server issues

**Solutions:**

```bash
# Check DNS resolution
dig your-domain.com

# Check DNS propagation
nslookup your-domain.com

# Test from Field Nation perspective
curl https://your-domain.com/webhooks
```

If domain is new, wait 24-48 hours for DNS propagation.

---

### 502 Bad Gateway

**Error Message:**
```
HTTP 502 Bad Gateway
```

**Causes:**
- Reverse proxy misconfiguration
- Backend server down
- Timeout at proxy level

**Solutions:**

  
    ```nginx
    # /etc/nginx/sites-available/your-site
    server {
      listen 443 ssl;
      server_name your-domain.com;
      
      location /webhooks {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        
        # Important timeout settings
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
        
        # Required headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
      }
    }
    
    # Test configuration
    sudo nginx -t
    
    # Reload
    sudo systemctl reload nginx
    ```
  
  
    ```apache
    # /etc/apache2/sites-available/your-site.conf
    <VirtualHost *:443>
      ServerName your-domain.com
      
      ProxyPreserveHost On
      ProxyTimeout 30
      
      ProxyPass /webhooks http://localhost:3000/webhooks
      ProxyPassReverse /webhooks http://localhost:3000/webhooks
      
      # SSL configuration
      SSLEngine on
      SSLCertificateFile /path/to/cert.pem
      SSLCertificateKeyFile /path/to/key.pem
    </VirtualHost>
    
    # Test configuration
    sudo apachectl configtest
    
    # Reload
    sudo systemctl reload apache2
    ```
  
  
    ```javascript
    // Ensure app is running and responsive
    const app = express();
    
    app.post('/webhooks', (req, res) => {
      console.log('Webhook received');
      res.status(200).send('OK');
    });
    
    const server = app.listen(3000, () => {
      console.log('Server running on port 3000');
    });
    
    // Health check endpoint
    app.get('/health', (req, res) => {
      res.status(200).send('OK');
    });
    
    // Graceful shutdown
    process.on('SIGTERM', () => {
      server.close(() => {
        console.log('Server closed');
      });
    });
    ```
  

---

### 500 Internal Server Error

**Error Message:**
```
HTTP 500 Internal Server Error
```

**Cause:** Unhandled exception in your webhook handler

**Solution:** Add comprehensive error handling

```javascript
app.post('/webhooks', async (req, res) => {
  try {
    // Verify signature
    if (!verifySignature(req)) {
      return res.status(401).send('Unauthorized');
    }
    
    // Parse payload
    const payload = JSON.parse(req.body.toString());
    
    // Process webhook
    await processWebhook(payload);
    
    res.status(200).send('OK');
    
  } catch (error) {
    console.error('Webhook processing error:', error);
    
    // Log error details
    await logError({
      error: error.message,
      stack: error.stack,
      payload: req.body.toString(),
      headers: req.headers
    });
    
    // Return 500 to trigger retry
    res.status(500).send('Internal error');
  }
});

// Global error handler
app.use((error, req, res, next) => {
  console.error('Unhandled error:', error);
  res.status(500).send('Internal error');
});
```

---

## Retry Patterns

### Manual Retry

```bash
curl -X PATCH https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/del_xyz789/retry \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Bulk Retry Failed Deliveries

```javascript
async function retryFailedDeliveries(webhookId, hours = 24) {
  // Get failed deliveries
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?` +
    `webhookId=${webhookId}&deliveryStatus=500`,
    {
      headers: { 'Authorization': `Bearer ${accessToken}` }
    }
  );
  
  const { result: logs } = await response.json();
  
  // Filter to recent failures
  const since = new Date(Date.now() - hours * 60 * 60 * 1000);
  const recentFailures = logs.filter(log =>
    new Date(log.createdAt) >= since
  );
  
  console.log(`Retrying ${recentFailures.length} failed deliveries...`);
  
  // Retry each
  for (const log of recentFailures) {
    try {
      await fetch(
        `https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs/${log.deliveryId}/retry`,
        {
          method: 'PATCH',
          headers: { 'Authorization': `Bearer ${accessToken}` }
        }
      );
      console.log(`✅ Retried ${log.deliveryId}`);
    } catch (error) {
      console.error(`❌ Failed to retry ${log.deliveryId}:`, error.message);
    }
  }
}

// Usage
await retryFailedDeliveries('wh_abc123', 24);
```

---

## Monitoring Delivery Health

```javascript
async function checkDeliveryHealth(webhookId) {
  const response = await fetch(
    `https://api-sandbox.fndev.net/api/v1/webhooks/delivery-logs?webhookId=${webhookId}&perPage=100`,
    {
      headers: { 'Authorization': `Bearer ${accessToken}` }
    }
  );
  
  const { result: logs } = await response.json();
  
  if (logs.length === 0) {
    return { status: 'no_data', message: 'No deliveries yet' };
  }
  
  const successful = logs.filter(log =>
    log.deliveryStatus >= 200 && log.deliveryStatus < 300
  ).length;
  
  const successRate = (successful / logs.length) * 100;
  
  const health = {
    total: logs.length,
    successful,
    failed: logs.length - successful,
    successRate: successRate.toFixed(2) + '%',
    status: successRate > 95 ? 'healthy' : successRate > 80 ? 'degraded' : 'unhealthy'
  };
  
  return health;
}
```

---

---

## Connectors (34)

### undefined
URL: /docs/connectors/getting-started

# Connectors: undefined
URL: /docs/connectors/getting-started
Source: content/docs/connectors/getting-started.mdx

---
title: Getting Started
description: Prerequisites and common setup steps for configuring Field Nation pre-built connectors.
icon: Rocket
---

## Prerequisites

### Field Nation Requirements

 Company Profile).",
      required: true
    },
    "Sandbox Access": {
      type: "Recommended",
      description: "Sandbox environment access for testing before production deployment.",
      required: false
    }
  }}
/>

[How to find your Company ID →](/docs/getting-started/prerequisites)

---

### External Platform Requirements

  
    You need administrative access in your external platform (Salesforce, ServiceNow, etc.) to:
    - Create API credentials or OAuth applications
    - Configure webhooks or outbound messages
    - Set up automation rules (Flows, Business Rules, etc.)
    - Grant API permissions to integration users
  
  
  
    Depending on the platform, you'll need:
    - **API Keys** - Unique identifiers for API access
    - **OAuth Tokens** - For OAuth 2.0 authenticated platforms
    - **Username & Password** - For Basic Authentication systems
    - **Security Tokens** - Platform-specific security credentials
    
    These are typically generated in the external platform's API or integration settings.
  
  
  
    Ensure your external platform can:
    - **Receive webhooks** from Field Nation's IP addresses
    - **Make outbound API calls** to Field Nation's endpoints
    - **Allow API access** (not blocked by firewalls or security policies)
    
    Some enterprise platforms require IP whitelisting or firewall rule adjustments.
  
  
  
    The integration user must have:
    - **Read access** to all fields you want to sync FROM the external system
    - **Write access** to all fields you want to update IN the external system
    - **API-enabled permissions** on custom objects and fields
    - **Create/Update permissions** for the object types being synchronized
  

---

## Common Setup Workflow

All pre-built connectors follow a similar configuration pattern:

### Gather Credentials

Collect required information from your external platform:
- API credentials (keys, tokens, username/password)
- Instance URLs or identifiers
- Object names or IDs you want to integrate
- Security tokens (if applicable)

### Configure in Field Nation

1. Navigate to Integration Settings in Field Nation
2. Select your connector from available integrations
3. Enter connection credentials
4. Specify the external object to integrate with
5. Configure optional settings (messaging, custom fields)
6. Test connection and save

### Configure External Platform

1. Set up webhook or outbound message
2. Configure automation rules (Flows, triggers, etc.)
3. Map Field Nation's trigger URL as the destination
4. Define conditions for when to send data to Field Nation
5. Test the trigger

### Map Fields

1. Field Nation automatically discovers available fields
2. Configure field mappings (source field → target field)
3. Set transformation actions (sync, static, date convert, etc.)
4. Add custom JSONNET transformations if needed
5. Save field mappings

### Test Integration

1. Create a test record in your external system
2. Trigger the automation (meet your Flow/rule conditions)
3. Verify Field Nation work order is created
4. Update the work order in Field Nation
5. Confirm updates sync back to external system

### Go Live

1. Monitor first few synchronizations
2. Review error logs for any issues
3. Adjust field mappings if needed
4. Document configuration for your team
5. Set up alerting for integration errors

---

## Integration Broker Access

All pre-built connectors are configured through Field Nation's **Integration Broker** interface:

**Sandbox**: [ui-sandbox.fndev.net/integrations](https://ui-sandbox.fndev.net/integrations)  
**Production**: [app.fieldnation.com/integrations](https://app.fieldnation.com/integrations)

> [INFO] **First Time Setup**: If you don't see the Integrations section, contact [Field Nation Support](https://app.fieldnation.com/support-cases) to enable connector access for your account.

---

## Understanding Field Mappings

Field mappings define how data translates between systems. Each mapping consists of:

### Mapping Components

### Common Transformation Actions

**Sync** - Direct field-to-field copy with no transformation

**Set Static** - Always use a specific value (e.g., always set priority to "High")

**Date Convert** - Transform date formats between systems

**Concat** - Combine multiple fields into one (e.g., FirstName + LastName → FullName)

**Array Map** - Transform array or list data

**Range Map** - Map value ranges (e.g., 1-3 → Low, 4-7 → Medium, 8-10 → High)

**Custom JSONNET** - Write custom transformation logic for complex scenarios

[Learn more about field mappings →](/docs/connectors/concepts/field-mappings)

---

## Data Flow Patterns

### Inbound: External System → Field Nation

```mermaid
graph LR
    A[Record Created/Updated] --> B[Webhook Triggered]
    B --> C[Integration Broker]
    C --> D[Fetch Full Record]
    D --> E[Apply Field Mappings]
    E --> F[Create/Update Work Order]
    F --> G[Log Success]
```

**Trigger**: Record change in external system  
**Result**: Field Nation work order created or updated

---

### Outbound: Field Nation → External System

```mermaid
graph LR
    A[Work Order Event] --> B[Integration Broker]
    B --> C[Apply Reverse Mappings]
    C --> D[Call External API]
    D --> E[Update Record]
    E --> F[Confirm Sync]
```

**Trigger**: Work order status change, assignment, completion, etc.  
**Result**: External system record updated

---

## Authentication Methods

Different platforms use different authentication approaches:

**Used by**: Freshdesk, some custom REST APIs

**Configuration**:
- Username
- Password
- Optional: Security Token

**Format**: `Authorization: Basic base64(username:password)`

**Used by**: Salesforce, ServiceNow (optional)

**Configuration**:
- Client ID
- Client Secret
- Authorization URL
- Token URL
- Scopes

**Flow**: Authorization Code or Client Credentials

**Used by**: Quickbase, Smartsheet

**Configuration**:
- API Key or Application Token
- Optional: API Secret

**Format**: Custom header (e.g., `X-API-Key: your-key`)

**Used by**: NetSuite, Autotask

**Configuration**:
- Account ID
- Integration Token
- Consumer Key/Secret
- Token Key/Secret

**Format**: Platform-specific SOAP authentication

---

## Best Practices

### Before Configuration

- ☐ Test in sandbox environment first
- ☐ Document current workflow and requirements
- ☐ Identify which fields need to sync
- ☐ Plan for error handling and monitoring
- ☐ Review external platform's API limits

### During Configuration

- ☐ Use descriptive names for field mappings
- ☐ Start with minimal field set, expand later
- ☐ Test each mapping individually
- ☐ Document transformation logic
- ☐ Keep track of credentials securely

### After Configuration

- ☐ Monitor first 24 hours closely
- ☐ Set up error notifications
- ☐ Create runbook for common issues
- ☐ Train team on monitoring dashboards
- ☐ Schedule regular health checks

---

## Common Pitfalls to Avoid

  
    **Problem**: Integration fails due to missing permissions
    
    **Solution**: Ensure integration user has full API access and permissions for all objects and fields being synchronized
  
  
  
    **Problem**: Data fails to sync due to type mismatches
    
    **Solution**: Use appropriate transformation actions (Date Convert, Range Map) to match field types between systems
  
  
  
    **Problem**: Work order creation fails due to missing required data
    
    **Solution**: Either map all required fields or set static default values for fields not available in source system
  
  
  
    **Problem**: No data flows to Field Nation
    
    **Solution**: Verify webhook configuration, check firewall rules, confirm trigger conditions are met
  
  
  
    **Problem**: Integration stops working after some time
    
    **Solution**: Refresh OAuth tokens, verify credentials haven't been reset, check for password policy changes
  

---

## Testing Your Configuration

### Create Test Scenarios

1. **Happy Path**: Standard work order creation and completion
2. **Required Fields**: Ensure all required fields are populated
3. **Optional Fields**: Verify optional fields sync correctly
4. **Status Changes**: Test bidirectional status synchronization
5. **Error Handling**: Intentionally trigger errors to verify error handling

### Test Checklist

- ☐ Work order created in Field Nation from external record
- ☐ All mapped fields populated correctly
- ☐ Status updates sync bidirectionally
- ☐ Comments/messages sync (if enabled)
- ☐ Error notifications received when sync fails
- ☐ Retry logic works for temporary failures
- ☐ Duplicate prevention works (same record not created twice)

---

## Getting Help

### Connector-Specific Guides

Each platform has detailed configuration instructions:

  
    Flows & Outbound Messages setup
  
  
    Business Rules & REST Messages
  
  
    OpenAPI spec configuration
  

[View all platform guides →](/docs/connectors/introduction)

### Support Resources

- **Support Cases**: [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases)
- **Phone**: +1 877-573-4353 (24/7)
- **Troubleshooting**: [Common issues and solutions](/docs/connectors/concepts/troubleshooting)

---

---

### undefined
URL: /docs/connectors/introduction

# Connectors: undefined
URL: /docs/connectors/introduction
Source: content/docs/connectors/introduction.mdx

---
title: Pre-built Connectors
description: Out-of-the-box integrations with leading field service management platforms - no code required for standard workflows.
icon: Plug
---

## What Are Pre-built Connectors?

Pre-built connectors are **configuration-driven integrations** managed by Field Nation's Integration Broker middleware. Instead of building custom API integrations, you configure field mappings and business rules through a web interface. Field Nation handles authentication, data transformation, retries, and error recovery automatically.

### Key Benefits

  
    Configure through UI - no API development needed for standard workflows
  
  
    Updates, security patches, and API changes handled automatically
  
  
    Automatic retries, dead letter queues, and detailed error logging
  
  
    Work orders flow both ways - create in either system, sync status automatically
  

---

## Supported Platforms

Field Nation provides pre-built connectors for 9 platforms:

### Professional Services Automation

**Autotask** - Datto Autotask PSA integration for ticket and work order synchronization

**ConnectWise** - ConnectWise Manage integration for service ticket management

**ServiceNow** - ServiceNow ITSM for incident and work order management

[View all PSA connectors →](#platform-guides)

### CRM & Support

**Salesforce** - Salesforce Service Cloud integration with Flows and Outbound Messages

**Freshdesk** - Freshdesk ticketing system integration

[View all CRM connectors →](#platform-guides)

### ERP & Project Management

**NetSuite** - NetSuite ERP integration for work order and service management

**Quickbase** - Bidirectional sync between Quickbase applications and Field Nation

**Smartsheet** - Smartsheet project management data synchronization

[View all platforms →](#platform-guides)

### Universal Integration

**REST Connector** - Connect **any system** with an OpenAPI specification

- Upload your OpenAPI spec file
- Configure endpoints (create, read, update)
- Map fields through UI
- Basic authentication support

Perfect for systems not covered by out-of-the-box connectors.

[Learn more about REST Connector →](/docs/connectors/platforms/rest-connector/overview)

---

## How Pre-built Connectors Work

```mermaid
sequenceDiagram
    participant Ext as External System
    participant Broker as Integration Broker
    participant FN as Field Nation
    
    Note over Ext,FN: Inbound: External System → Field Nation
    Ext->>Broker: Webhook/API Trigger
    Broker->>Ext: Fetch Full Record Data
    Broker->>Broker: Apply Field Mappings
    Broker->>Broker: Transform with JSONNET
    Broker->>FN: Create/Update Work Order
    
    Note over Ext,FN: Outbound: Field Nation → External System
    FN->>Broker: Work Order Event
    Broker->>Broker: Apply Reverse Mappings
    Broker->>Ext: Update Record via API
    Ext-->>Broker: Confirmation
```

### Configuration in Field Nation

Configure authentication credentials, specify the external object to integrate, and set up field mappings through the Integration Broker UI.

### External Platform Setup

Configure webhooks or triggers in your external system to notify Field Nation when records are created or updated.

### Automatic Synchronization

The Integration Broker handles bidirectional sync:
- Creates Field Nation work orders from external records
- Syncs status changes, assignments, and completions back to external system
- Maintains data consistency with automatic retries

---

## When to Use Pre-built Connectors

  
    - Your platform is supported (Salesforce, ServiceNow, etc.)
    - You need standard work order synchronization
    - You want minimal development effort
    - You prefer configuration over coding
    - You need Field Nation to manage updates and maintenance
  
  
  
    - You need highly custom workflows
    - Your platform isn't supported by pre-built connectors
    - You require advanced data transformations beyond JSONNET
    - You want complete control over integration logic
    - You have development resources available
    
    [REST API + Webhooks Guide →](/docs/getting-started/choosing-your-approach)
  
  
  
    - Your system has an OpenAPI specification
    - You need basic CRUD operations
    - You want configuration-driven approach
    - Your system isn't in the pre-built connector list
    
    [REST Connector Guide →](/docs/connectors/platforms/rest-connector/overview)
  

---

## Common Use Cases

### Dispatch from CRM
Automatically create Field Nation work orders when a Case, Ticket, or Opportunity reaches a specific status (e.g., "On-site Required").

### Status Synchronization
Reflect work order status changes (assigned, in progress, completed) back to your originating system in real-time.

### Provider Communication
Sync comments and messages between Field Nation technicians and your internal team through the external platform.

### Financial Tracking
Update work order costs, invoices, and payment status in your ERP or accounting system automatically.

---

## Feature Comparison

| Feature | Pre-built Connectors | REST API + Webhooks |
|---------|---------------------|---------------------|
| **Setup Time** | Hours to days | Days to weeks |
| **Development Required** | Configuration only | Full development |
| **Customization** | High (via JSONNET) | Unlimited |
| **Maintenance** | Field Nation | Your team |
| **Cost** | Lower | Higher (dev time) |
| **API Updates** | Handled automatically | Manual updates |
| **Error Handling** | Built-in | Custom implementation |
| **Best For** | Standard workflows | Custom workflows |

[Compare all approaches →](/docs/getting-started/choosing-your-approach)

---

## Architecture Overview

Pre-built connectors use Field Nation's **Integration Broker** - a microservices-based middleware that:

- **Authenticates** with external platforms (OAuth, API keys, Basic Auth)
- **Discovers Fields** automatically from external system metadata
- **Transforms Data** using configurable field mappings and JSONNET
- **Queues Messages** with Redis for reliable delivery and retries
- **Handles Errors** with automatic retries, dead letter queues, and alerting

[Learn more about broker architecture →](/docs/connectors/concepts/broker-architecture)

---

## Getting Started

  
    What you need before setting up a connector
  
  
    Select from 9 supported platforms
  
  
    Learn how to map fields and transform data
  
  
    Common issues and solutions
  

---

## Platform Guides

Select your platform to get started:

  
    Integrate with Salesforce Service Cloud
  
  
    Connect ServiceNow ITSM
  
  
    Sync with Datto Autotask PSA
  
  
    Integrate ConnectWise Manage
  
  
    Connect Freshdesk ticketing
  
  
    Integrate NetSuite ERP
  
  
    Sync Quickbase applications
  
  
    Connect Smartsheet projects
  
  
    Universal OpenAPI-based integration
  

---

## Support & Resources

- **Support Portal**: [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases)
- **Phone Support**: +1 877-573-4353 (24/7)
- **Status Page**: [status.fieldnation.com](https://status.fieldnation.com)

[Complete support resources →](/docs/resources/support)

---

---

### undefined
URL: /docs/connectors/concepts/broker-architecture

# Connectors: undefined
URL: /docs/connectors/concepts/broker-architecture
Source: content/docs/connectors/concepts/broker-architecture.mdx

---
title: Integration Broker Architecture
description: Understanding Field Nation's middleware system that powers all pre-built connectors with reliable, scalable data synchronization.
---

## System Overview

```mermaid
graph TB
    subgraph "External Systems"
        SF[Salesforce]
        SN[ServiceNow]
        AT[Autotask]
        OT[Other Platforms]
    end
    
    subgraph "Integration Broker"
        TRG[Trigger Handler]
        Q[Message Queues]
        WRK[Broker Workers]
        MAP[Field Mapping Engine]
        JSNT[JSONNET Processor]
    end
    
    subgraph "Field Nation"
        API[REST API]
        EVT[Event Stream]
        WO[Work Orders]
    end
    
    SF --> TRG
    SN --> TRG
    AT --> TRG
    OT --> TRG
    
    TRG --> Q
    Q --> WRK
    WRK --> MAP
    MAP --> JSNT
    JSNT --> API
    API --> WO
    
    EVT --> Q
    WRK --> SF
    WRK --> SN
    WRK --> AT
    WRK --> OT
```

---

## Core Components

### Broker Workers

The primary processing engine that:
- Consumes messages from Redis queues
- Executes field mappings and transformations
- Dispatches API calls to target systems
- Handles retries and error recovery

### Message Queues

Redis-based queue system providing:
- **Inbound Queue**: Webhook triggers from external systems
- **Processing Queue**: Active operations being executed
- **Retry Queue**: Failed operations with exponential backoff
- **Dead Letter Queue (DLQ)**: Operations exceeding max retries

### Field Mapping Engine

Dynamic mapping system that:
- Translates data schemas between systems
- Applies transformation actions (sync, static, date convert, etc.)
- Supports conditional logic and complex mappings
- Handles bidirectional field mapping

### Custom Action Processor

JSONNET-based transformation engine for:
- Complex data manipulation logic
- Conditional field population
- Custom business rules
- Advanced array and object transformations

[Learn more about JSONNET →](/docs/connectors/concepts/custom-actions)

---

## Data Flow

### Inbound: External System → Field Nation

### Trigger Reception

External system sends webhook notification when record is created/updated. Each connector has a unique trigger URL with embedded authentication token.

### Queue Processing

Broker worker retrieves message, validates token, fetches complete record data from external system using configured API credentials.

### Field Mapping

System applies configured mappings to transform external data into Field Nation work order schema. Includes static values, date conversions, JSONNET transformations.

### Work Order Creation

Transformed data is validated and submitted to Field Nation API. System stores correlation between external record ID and Field Nation work order ID.

### Error Handling

Failed operations are logged, retried with exponential backoff, and moved to DLQ if max retries exceeded. Email notifications sent for persistent failures.

---

### Outbound: Field Nation → External System

### Event Detection

Field Nation publishes work order lifecycle events (status changes, assignments, completions, messages) to integration event stream.

### Mapping Resolution

Broker identifies originating external system using correlation ID. Applies reverse field mappings to transform Field Nation data to external schema.

### API Dispatch

System constructs API request (REST, SOAP, or platform SDK) and submits update to external platform using configured authentication.

### Sync Confirmation

Successful updates logged, work order sync status updated. Failed updates trigger retry with exponential backoff.

---

## Message Processing

### Queue Processing Strategy

The broker uses a **poll-and-acknowledge pattern**:

1. Worker retrieves message from queue
2. Worker processes message completely
3. Worker acknowledges successful processing
4. If worker crashes, message remains unacknowledged and retries after timeout

### Rate Limiting

Each integration respects external API quotas:
- Maximum requests per minute
- Concurrent connection limits
- Burst allowances
- Per-platform rate limit configuration

### Retry Logic

Failed operations retry with exponential backoff:

| Attempt | Delay | Action |
|---------|-------|--------|
| 1 | 0s | Immediate |
| 2 | 30s | First retry |
| 3 | 60s | Second retry |
| 4 | 120s | Third retry |
| 5 | 240s | Fourth retry |
| 6+ | 480s | Final attempts |

After maximum retries, operation moves to Dead Letter Queue for manual review.

---

## Authentication & Security

### Credential Management

- **Encryption at Rest**: AES-256 encryption for all credentials
- **In-Memory Only**: Decrypted only during active use
- **No Logging**: Credentials never logged or exposed in errors
- **Token Refresh**: Automatic OAuth token refresh

### Authentication Methods Supported

```
Authorization: Basic base64(username:password)
```
Used by: Freshdesk, REST Connector

```
Authorization: Bearer {access_token}
```
Automatic token refresh with refresh tokens  
Used by: Salesforce, ServiceNow

```
X-API-Key: {api_key}
Authorization: Bearer {token}
```
Platform-specific header formats  
Used by: Quickbase, Smartsheet

```xml
<soap:Header>
  <TokenPassport>
    <account>{account_id}</account>
    <consumerKey>{consumer_key}</consumerKey>
    <token>{token}</token>
  </TokenPassport>
</soap:Header>
```
Used by: NetSuite, Autotask

### Request Authentication

Each trigger URL includes unique client token:

```
https://api.fieldnation.com/integrations/trigger/{client_token}
```

Broker validates token before processing any data.

---

## Error Handling

### Error Categories

**Authentication Errors**
- Invalid/expired credentials
- Insufficient permissions
- Token refresh failures
- **Action**: Manual intervention required

**Validation Errors**
- Missing required fields
- Invalid data types
- Schema validation failures
- **Action**: Fix field mappings or source data

**API Errors**
- Rate limit exceeded
- Network timeouts
- Service unavailable
- **Action**: Automatic retry with backoff

**Transformation Errors**
- JSONNET execution failures
- Field mapping exceptions
- Data type conversions
- **Action**: Review custom actions

### Error Notifications

Configure email alerts for:
- Failed operations
- Dead letter queue entries
- Authentication failures
- High error rates

---

## Performance Characteristics

### Processing Capacity

- **Throughput**: Thousands of work orders per minute
- **Scaling**: Horizontal scaling via additional worker instances
- **Concurrency**: Multiple workers process queue in parallel

### Latency

- **Typical**: 2-5 seconds end-to-end (trigger → work order created)
- **Factors**: External API response time, field mapping complexity, queue depth

### Reliability

- **Uptime**: 99.9% availability
- **Failover**: Automatic worker recovery
- **Circuit Breakers**: Isolate failing external systems
- **Health Checks**: Continuous monitoring

---

## Monitoring & Observability

### Integration Logs

All operations logged with:
- Timestamps
- User identifiers
- Operation types
- Outcomes (success/failure)
- Error details
- API request/response

### Health Dashboards

Track key metrics:
- Queue depths by type
- Processing rates
- Error frequencies by category
- API response times
- Sync success rates

### Audit Trail

Comprehensive audit records for:
- Compliance requirements
- Incident investigation
- Performance analysis
- Capacity planning

---

## Configuration

### Field Nation Settings

**Integration Broker UI**: [app.fieldnation.com/integrations](https://app.fieldnation.com/integrations)

Configure:
- Authentication credentials (encrypted)
- Field mappings (source → target)
- Event triggers (which events sync)
- Operation types (create only vs bidirectional)
- Email notifications

### External Platform Setup

**Required Configuration**:
- Webhook endpoints pointing to Field Nation trigger URL
- Automation rules (Flows, Business Rules, Workflows)
- API user with appropriate permissions
- Firewall/IP whitelist configuration (if applicable)

[Platform-specific guides →](/docs/connectors/introduction)

---

## Data Privacy

### Data Handling

- **In-Transit Processing**: Data processed in memory, not stored
- **Logging**: Error logs scrubbed of sensitive information
- **Retention**: Audit logs retained per compliance requirements
- **Encryption**: All API calls use TLS 1.2+

### Compliance

The Integration Broker supports:
- SOC 2 compliance
- GDPR data handling
- Audit trail requirements
- Data residency considerations

---

## Best Practices

### Configuration

- ✅ Test in sandbox before production
- ✅ Use service accounts (not personal credentials)
- ✅ Set up error notifications
- ✅ Monitor queue depths
- ✅ Document field mappings

### Security

- ✅ Rotate credentials periodically
- ✅ Use least-privilege API access
- ✅ Enable IP whitelisting where possible
- ✅ Review audit logs regularly
- ✅ Encrypt credentials in your documentation

### Performance

- ✅ Keep field mappings simple when possible
- ✅ Use custom actions only when necessary
- ✅ Batch updates where supported
- ✅ Monitor API rate limits
- ✅ Scale workers for high volume

---

## Troubleshooting

### Common Issues

  
    **Check:**
    - Webhook triggering correctly
    - Authentication credentials valid
    - All required fields mapped
    - Queue processing (not stuck)
    - External API accessible
  
  
  
    **Check:**
    - Event triggers configured
    - Outbound field mappings correct
    - External API permissions
    - Correlation ID stored correctly
    - Rate limits not exceeded
  
  
  
    **Check:**
    - External API status
    - Credential expiration
    - Field mapping issues
    - Data validation errors
    - Network connectivity
  

[Complete troubleshooting guide →](/docs/connectors/concepts/troubleshooting)

---

---

### undefined
URL: /docs/connectors/concepts/custom-actions

# Connectors: undefined
URL: /docs/connectors/concepts/custom-actions
Source: content/docs/connectors/concepts/custom-actions.mdx

---
title: Custom Actions with JSONNET
description: Write advanced data transformation logic using JSONNET for complex field mapping scenarios.
---

## JSONNET Overview

JSONNET is a data templating language developed by Google that generates JSON through programmable logic. It's designed for configuration management and data transformation.

### Key Features

**Functions** - Define reusable transformation logic with parameters

**Variables** - Store intermediate values using `local` bindings

**Conditionals** - Implement branching with `if-then-else`

**Standard Library** - Built-in functions for strings, arrays, objects, math

**Imports** - Include external libraries for code reuse

[Official JSONNET Documentation →](https://jsonnet.org/)

---

## Execution Context

Every custom action executes within a special context providing access to data and utilities:

---

## Basic Custom Action

The simplest custom action directly accesses input fields:

```jsonnet
{
  full_name: $.util.lookup_field($.input, 'assignee.user.first_name', '') + ' ' + 
             $.util.lookup_field($.input, 'assignee.user.last_name', '')
}
```

**Result**: Concatenates first and last name with space, using safe defaults for missing fields.

---

## Utility Library ($.util)

The Integration Broker provides comprehensive utility functions optimized for field mappings.

### Field Lookup Functions

#### lookup_field(obj, path, default, raw=false)

Safely retrieves nested values using dot notation.

```jsonnet
{
  work_order_id: $.util.lookup_field($.input, 'workorder.id', 0),
  company_name: $.util.lookup_field($.input, 'workorder.location.company.name', 'Unknown')
}
```

**Parameters:**
- `obj`: Source object to search
- `path`: Dot-notation path (e.g., `'user.email'`)
- `default`: Value if path doesn't exist
- `raw`: Treat path as literal property name (no dot parsing)

---

#### lookup_custom_field(id, obj, default="")

Retrieves Field Nation custom field values by ID.

```jsonnet
{
  po_number: $.util.lookup_custom_field('835', $.input, 'N/A'),
  site_contact: $.util.lookup_custom_field('912', $.input, '')
}
```

Field Nation custom fields have nested structure - this function handles it automatically.

---

### Mapping Functions

#### array_map(array_def, val, default)

Maps values using exact match comparisons.

```jsonnet
{
  payment_type: $.util.array_map(
    [
      { cmp: "fixed", val: "Fixed Price" },
      { cmp: "hourly", val: "Hourly Rate" },
      { cmp: "blended", val: "Blended Rate" }
    ],
    $.util.lookup_field($.input, 'pay.type', ''),
    "Unknown"
  )
}
```

---

#### range_map(range_def, val, default)

Maps numeric values to categories using range comparisons (right-to-left, less-than-or-equal).

```jsonnet
{
  duration_category: $.util.range_map(
    [
      { cmp: 0.5, val: "15-30 Minutes" },
      { cmp: 1, val: "31-60 Minutes" },
      { cmp: 2, val: "1-2 Hours" }
    ],
    $.util.lookup_field($.input, 'time_logs.hours', 0),
    "2+ Hours"
  )
}
```

**How it works:**
- `0.3` hours → "15-30 Minutes" (≤ 0.5)
- `1.5` hours → "1-2 Hours" (≤ 2)
- `3` hours → "2+ Hours" (default)

---

### Date Conversion Functions

#### date_convert(value, format_input, format_output, timezone_in='UTC', timezone_out='UTC')

Transforms dates between formats and timezones.

```jsonnet
{
  scheduled_date: $.util.date_convert(
    $.util.lookup_field($.input, 'schedule.service_window.start.utc', ''),
    $.util.date_time_format_fn_utc(),  // "YYYY-MM-DD HH:mm:ss"
    "MM/DD/YYYY h:mm:ss A",
    'UTC',
    'America/New_York'
  )
}
```

**Common Formats:**
- `YYYY-MM-DD HH:mm:ss` - Standard datetime
- `MM/DD/YYYY` - US date format
- `h:mm A` - 12-hour time
- `X` - Unix timestamp (seconds)
- `x` - Unix timestamp (milliseconds)

---

#### date_time_format_fn_utc()

Returns standard UTC format string: `"YYYY-MM-DD HH:mm:ss"`

---

#### date_add(value, format_input="")

Adds one day to a date value.

```jsonnet
{
  due_date: $.util.date_add(
    $.util.lookup_field($.input, 'schedule.service_window.start.utc', ''),
    $.util.date_time_format_fn_utc()
  )
}
```

---

### Array Processing Functions

#### array_sum(array)

Sums all numeric elements.

```jsonnet
{
  total_hours: $.util.array_sum([10, 22, 4])  // Returns 36
}
```

---

#### object_map_array(arr, map)

Transforms array of objects by mapping their fields.

```jsonnet
{
  mapped_expenses: $.util.object_map_array(
    $.input.pay.expense.results,
    {
      "amount": "expense_amount",
      "category.name": "expense_category",
      "description": "expense_desc"
    }
  )
}
```

**Input:**
```json
[
  { "amount": 50, "category": { "name": "Travel" }, "description": "Mileage" },
  { "amount": 25, "category": { "name": "Materials" }, "description": "Parts" }
]
```

**Output:**
```json
[
  { "expense_amount": 50, "expense_category": "Travel", "expense_desc": "Mileage" },
  { "expense_amount": 25, "expense_category": "Materials", "expense_desc": "Parts" }
]
```

---

#### results_values(results, field, default='', raw=false)

Extracts values for a specific field from array of objects.

```jsonnet
{
  all_categories: $.util.results_values(
    $.input.pay.expense.results,
    "category.name",
    'Unknown'
  )
  // Returns: ["Travel", "Materials", "Travel", "Lodging"]
}
```

---

#### results_values_unique(results, field, default='', raw=false)

Like `results_values` but returns only unique values.

```jsonnet
{
  unique_categories: $.util.results_values_unique(
    $.input.pay.expense.results,
    "category.name"
  )
  // Returns: ["Travel", "Materials", "Lodging"]
}
```

---

#### results_group_by(results, group_by_field, additional_filter, raw=false)

Groups array elements by field value with optional filtering.

```jsonnet
{
  expenses_by_category: $.util.results_group_by(
    $.input.pay.expense.results,
    "category.name",
    $.util.is_expense_approved_fn,
    false
  )
}
```

---

### Expense Aggregation Functions

#### is_expense_approved_fn(expense)

Filter function for approved expenses.

```jsonnet
local approved_expenses = std.filter(
  $.util.is_expense_approved_fn,
  $.input.pay.expense.results
);
```

---

#### sum_expense_field(expenses, field)

Sums a specific field across expense array.

```jsonnet
{
  total_expense_amount: $.util.sum_expense_field(
    $.input.pay.expense.results,
    "amount"
  )
}
```

---

## Common Patterns

### Conditional Logic

```jsonnet
{
  priority: 
    local hours = $.util.lookup_field($.input, 'time_logs.hours', 0);
    local is_urgent = $.util.lookup_field($.input, 'priority', '') == 'urgent';
    
    if is_urgent && hours > 2 then
      "Critical"
    else if is_urgent then
      "High"
    else if hours > 4 then
      "Medium"
    else
      "Low"
}
```

---

### String Manipulation

```jsonnet
{
  // Uppercase
  title_upper: std.asciiUpper($.util.lookup_field($.input, 'workorder.title', '')),
  
  // Extract email domain
  email_domain: 
    local email = $.util.lookup_field($.input, 'user.email', '');
    local parts = std.split(email, '@');
    if std.length(parts) > 1 then parts[1] else '',
  
  // Remove whitespace
  clean_text: std.stripChars($.util.lookup_field($.input, 'description', ''), ' \t\n')
}
```

---

### Array Transformations

```jsonnet
{
  // Filter array
  high_value_expenses: 
    local all_expenses = $.input.pay.expense.results;
    std.filter(function(e) e.amount > 100, all_expenses),
  
  // Map array
  expense_amounts: 
    std.map(
      function(e) e.amount,
      $.input.pay.expense.results
    ),
  
  // Find element
  first_travel_expense:
    local expenses = $.input.pay.expense.results;
    local travel = std.filter(
      function(e) e.category.name == 'Travel',
      expenses
    );
    if std.length(travel) > 0 then travel[0] else null
}
```

---

### Number Formatting

```jsonnet
{
  // Round to 2 decimal places
  rounded_cost: std.round($.input.pay.amount * 100) / 100,
  
  // Format as currency
  formatted_amount:
    local amount = $.util.lookup_field($.input, 'pay.amount', 0);
    "$" + std.toString(std.round(amount * 100) / 100),
  
  // Percentage calculation
  completion_rate:
    local completed = $.util.lookup_field($.input, 'tasks_completed', 0);
    local total = $.util.lookup_field($.input, 'tasks_total', 1);
    std.round((completed / total) * 100) + "%"
}
```

---

### Object Construction

```jsonnet
{
  // Build nested object
  contact_info: {
    name: $.util.lookup_field($.input, 'assignee.user.first_name', '') + ' ' +
          $.util.lookup_field($.input, 'assignee.user.last_name', ''),
    email: $.util.lookup_field($.input, 'assignee.user.email', ''),
    phone: $.util.lookup_field($.input, 'assignee.user.phone', ''),
    address: {
      street: $.util.lookup_field($.input, 'location.address1', ''),
      city: $.util.lookup_field($.input, 'location.city', ''),
      state: $.util.lookup_field($.input, 'location.state', ''),
      zip: $.util.lookup_field($.input, 'location.zip', '')
    }
  }
}
```

---

## Advanced Examples

### Complex Status Mapping

```jsonnet
{
  external_status:
    local fn_status = $.util.lookup_field($.input, 'status.name', '');
    local is_assigned = $.util.lookup_field($.input, 'assignee.user.id', 0) > 0;
    local is_completed = fn_status == 'work_done';
    local is_approved = fn_status == 'approved';
    
    if is_approved then
      "Closed - Approved"
    else if is_completed then
      "Closed - Completed"
    else if is_assigned then
      "In Progress"
    else if fn_status == 'published' then
      "Open - Available"
    else
      "Draft"
}
```

---

### Multi-Field Validation

```jsonnet
{
  validation_status:
    local title = $.util.lookup_field($.input, 'workorder.title', '');
    local amount = $.util.lookup_field($.input, 'pay.amount', 0);
    local start_date = $.util.lookup_field($.input, 'schedule.service_window.start.utc', '');
    
    local errors = [];
    local errors2 = if title == '' then errors + ["Missing title"] else errors;
    local errors3 = if amount <= 0 then errors2 + ["Invalid amount"] else errors2;
    local errors4 = if start_date == '' then errors3 + ["Missing schedule"] else errors3;
    
    if std.length(errors4) > 0 then
      { valid: false, errors: errors4 }
    else
      { valid: true, errors: [] }
}
```

---

### Dynamic Field Selection

```jsonnet
{
  primary_contact:
    local contacts = $.util.lookup_field($.input, 'workorder.contacts', []);
    local primary = std.filter(
      function(c) c.is_primary == true,
      contacts
    );
    
    if std.length(primary) > 0 then
      primary[0].email
    else if std.length(contacts) > 0 then
      contacts[0].email
    else
      ''
}
```

---

## Best Practices

### Code Organization

**Use Local Variables** for readability and performance:

```jsonnet
{
  result:
    // ✅ Good - reusable, clear
    local hours = $.util.lookup_field($.input, 'time_logs.hours', 0);
    local rate = $.util.lookup_field($.input, 'pay.hourly_rate', 0);
    local total = hours * rate;
    std.round(total * 100) / 100
}
```

```jsonnet
{
  result:
    // ❌ Bad - repeated lookups, hard to read
    std.round(($.util.lookup_field($.input, 'time_logs.hours', 0) * 
               $.util.lookup_field($.input, 'pay.hourly_rate', 0)) * 100) / 100
}
```

---

### Error Handling

**Always provide defaults** to prevent null pointer errors:

```jsonnet
{
  // ✅ Good - safe with defaults
  total: $.util.lookup_field($.input, 'amount', 0) + 
         $.util.lookup_field($.input, 'tax', 0),
  
  // ❌ Bad - may crash if fields missing
  total: $.input.amount + $.input.tax
}
```

---

### Performance Optimization

**Cache expensive operations:**

```jsonnet
{
  // ✅ Good - calculate once, use multiple times
  result:
    local all_expenses = $.input.pay.expense.results;
    local total = $.util.sum_expense_field(all_expenses, "amount");
    local count = std.length(all_expenses);
    {
      total: total,
      count: count,
      average: if count > 0 then total / count else 0
    }
}
```

---

### Type Safety

**Check types before operations:**

```jsonnet
{
  safe_division:
    local numerator = $.util.lookup_field($.input, 'completed', 0);
    local denominator = $.util.lookup_field($.input, 'total', 1);
    
    if std.isNumber(numerator) && std.isNumber(denominator) && denominator != 0 then
      numerator / denominator
    else
      0
}
```

---

## Testing Custom Actions

### Test in Isolation

Create a test payload and validate output:

```jsonnet
// Test payload
local test_input = {
  workorder: {
    id: 12345,
    title: "Test WO",
    pay: { amount: 150.50 }
  }
};

// Your transformation
local result = {
  id: test_input.workorder.id,
  formatted_amount: "$" + std.toString(test_input.workorder.pay.amount)
};

// Output for testing
result
```

---

### Debug with std.trace

Add trace statements to inspect values:

```jsonnet
{
  result:
    local value = $.util.lookup_field($.input, 'some.field', 'default');
    local traced = std.trace("Field value: " + std.toString(value), value);
    // Transformation continues with traced value
    traced
}
```

Trace output appears in integration logs.

---

## Troubleshooting

  
    **Common Issues:**
    - Missing commas between object properties
    - Unmatched brackets/braces
    - Missing semicolons in local bindings
    
    **Solution:** Use a JSONNET validator or linter before deploying.
  
  
  
    **Cause:** Accessing fields that don't exist
    
    **Solution:** Always use `lookup_field` with defaults instead of direct access:
    ```jsonnet
    // ✅ Good
    $.util.lookup_field($.input, 'field', 'default')
    
    // ❌ Bad
    $.input.field
    ```
  
  
  
    **Cause:** Operations on mismatched types (string + number)
    
    **Solution:** Use type checking and conversion:
    ```jsonnet
    local value = $.util.lookup_field($.input, 'field', '');
    if std.isNumber(value) then value else std.parseInt(value)
    ```
  

---

---

### undefined
URL: /docs/connectors/concepts/events-and-sync

# Connectors: undefined
URL: /docs/connectors/concepts/events-and-sync
Source: content/docs/connectors/concepts/events-and-sync.mdx

---
title: Events & Synchronization
description: Understanding work order events that trigger connector synchronization and how to configure event-based data flows.
---

## Event-Driven Architecture

When work orders change in Field Nation, events trigger outbound synchronization to external systems. When external records change, webhooks trigger inbound synchronization to Field Nation.

```mermaid
graph LR
    FN[Field Nation] -->|Event Stream| BROKER[Integration Broker]
    BROKER -->|Update| EXT[External System]
    
    EXT -->|Webhook| BROKER
    BROKER -->|Create/Update| FN
    
    style BROKER fill:#f9f,stroke:#333,stroke-width:2px
```

---

## Available Events

Field Nation publishes events for key work order lifecycle milestones. Configure which events trigger synchronization for each connector.

### Work Order Creation & Status

---

### Provider Assignment

---

### Work Execution

---

### Schedule & Timeline

---

### Updates & Changes

---

### Messages & Communication

---

### Financial Events

---

### Additional Events

---

## Configuring Event Triggers

### Selecting Events

In the Integration Broker UI, configure which events trigger synchronization:

### Navigate to Event Configuration

Go to your connector settings → Event Triggers section

### Select Events

Check the events you want to trigger outbound sync:
- ✅ `FN_WO_ASSIGNED` - Sync when provider assigned
- ✅ `FN_WO_DONE` - Sync when work completed
- ✅ `FN_WO_APPROVED` - Sync when work approved

### Configure Action

For each event, specify the action:
- **Update Record** - Update existing external record
- **Create Record** - Create new external record (typically for messages/notes)
- **Custom Script** - Run platform-specific logic

### Save Configuration

Test event triggers with sample work orders

---

### Common Event Configurations

**Minimal Sync (Status Only)**
- `FN_WO_ASSIGNED` - Provider assigned
- `FN_WO_DONE` - Work completed
- `FN_WO_APPROVED` - Work approved

**Standard Sync (Status + Communication)**
- All minimal sync events
- `FN_WO_MESSAGE_ADDED` - Sync messages
- `FN_WO_SCHEDULE_UPDATED` - Sync schedule changes
- `FN_WO_CUSTOM_FIELD_VALUE_UPDATED` - Sync custom fields

**Comprehensive Sync (Full Lifecycle)**
- All standard sync events
- `FN_WO_ON_MY_WAY` - Provider en route
- `FN_WO_PROVIDER_CHECKED_IN` - Check-in tracking
- `FN_WO_PROVIDER_CHECKED_OUT` - Check-out tracking
- `FN_WO_PAYMENT_APPROVED` - Financial tracking
- `FN_WO_ATTACHMENT_ADDED` - Document sync

---

## Synchronization Patterns

### Inbound: External System → Field Nation

External systems trigger synchronization via webhooks:

```mermaid
sequenceDiagram
    participant Ext as External System
    participant WH as Webhook/Flow
    participant Broker as Integration Broker
    participant FN as Field Nation
    
    Ext->>WH: Record Created/Updated
    WH->>Broker: POST /integrations/trigger/{token}
    Broker->>Ext: GET Full Record Data
    Broker->>Broker: Apply Field Mappings
    Broker->>FN: Create/Update Work Order
    FN-->>Broker: Success
    Broker->>Ext: Update Sync Status (optional)
```

**Triggers:**
- Record created in external system
- Record status changed
- Record field updated (specific fields)
- Manual "Sync to Field Nation" button

---

### Outbound: Field Nation → External System

Field Nation events trigger synchronization:

```mermaid
sequenceDiagram
    participant FN as Field Nation
    participant EVT as Event Stream
    participant Broker as Integration Broker
    participant Ext as External System
    
    FN->>EVT: Work Order Event
    EVT->>Broker: Event Notification
    Broker->>Broker: Check Event Config
    Broker->>Broker: Apply Field Mappings
    Broker->>Ext: API Call (Update Record)
    Ext-->>Broker: Success
    Broker->>FN: Update Sync Status
```

**Triggers:**
- Configured Field Nation events
- Status changes
- Custom field updates
- Message additions

---

## Event Payloads

Events include complete work order context:

```json
{
  "event_type": "FN_WO_ASSIGNED",
  "event_timestamp": "2025-01-15T14:30:00Z",
  "workorder": {
    "id": 12345678,
    "title": "On-site Network Installation",
    "status": {
      "id": 2,
      "name": "assigned"
    },
    "assignee": {
      "user": {
        "id": 987654,
        "first_name": "John",
        "last_name": "Technician",
        "email": "john@example.com",
        "phone": "+1-555-0100"
      }
    },
    "schedule": {
      "service_window": {
        "start": {
          "utc": "2025-01-20 09:00:00"
        },
        "end": {
          "utc": "2025-01-20 12:00:00"
        }
      }
    },
    "pay": {
      "type": "fixed",
      "amount": 250.00
    },
    "custom_fields": [ /* ... */ ]
  },
  "correlation_id": "ext-record-456"
}
```

---

## Best Practices

### Event Selection

  
    Begin with minimal sync (assigned, done, approved). Add more events after core sync is stable.
    
    **Phase 1**: Status changes only  
    **Phase 2**: Add messages and schedule updates  
    **Phase 3**: Add comprehensive tracking (check-in, expenses, etc.)
  
  
  
    Some events overlap. Choose the most specific event for your use case:
    
    - Use `FN_WO_STATUS_ROUTED` (once) instead of `FN_WO_ROUTED` (per provider) if you only need to know routing occurred
    - Use `FN_WO_ASSIGNED` if you don't need separate confirmation tracking
  
  
  
    High-frequency events can overwhelm external APIs:
    
    - `FN_WO_MESSAGE_ADDED` - Can fire frequently
    - `FN_WO_PROVIDER_CHECKED_IN/OUT` - Multiple per work order
    - `FN_WO_UPDATED` - May fire for many field changes
    
    Ensure your external system can handle the volume or implement batching.
  

---

### Synchronization Strategy

**Bidirectional Consistency**
- Map statuses bidirectionally (FN → External and External → FN)
- Use correlation IDs to track related records
- Handle sync conflicts (last-write-wins or manual resolution)

**Idempotency**
- Ensure same event processed multiple times produces same result
- Check correlation ID before creating new records
- Use upsert logic (create if not exists, update if exists)

**Error Handling**
- Configure retries for temporary failures
- Set up dead letter queue monitoring
- Alert on persistent sync failures

---

## Monitoring Event Sync

### Integration Logs

Track event processing in Integration Broker logs:

- Event received timestamp
- Field mappings applied
- API call made to external system
- Success/failure status
- Error details (if failed)

### Health Metrics

Monitor key indicators:

- **Event Processing Rate**: Events/minute
- **Success Rate**: % successful syncs
- **Average Latency**: Time from event to external update
- **Error Rate**: % failed syncs
- **Queue Depth**: Pending events in queue

---

## Troubleshooting Events

  
    **Check:**
    - Event enabled in connector configuration
    - Work order status actually changed to trigger event
    - Integration not paused/disabled
    - Event filters not excluding work order
    
    **Debug:**
    Review Integration Broker logs for event received confirmation
  
  
  
    **Causes:**
    - Some events naturally fire multiple times (ROUTED per provider, CHECK_IN per check-in)
    - Retry logic if external API failed
    - Webhook configured multiple times
    
    **Solution:**
    Implement idempotency in external system using correlation ID
  
  
  
    **Check:**
    - Field mappings configured for outbound sync
    - External API credentials valid
    - Correlation ID linking FN work order to external record
    - External API not rate limiting
    
    **Debug:**
    Check Integration Broker logs for API call details and response
  

[Complete troubleshooting guide →](/docs/connectors/concepts/troubleshooting)

---

---

### undefined
URL: /docs/connectors/concepts/field-mappings

# Connectors: undefined
URL: /docs/connectors/concepts/field-mappings
Source: content/docs/connectors/concepts/field-mappings.mdx

---
title: Field Mappings
description: Configure how data transforms between Field Nation and external platforms using flexible mapping actions.
---

## Mapping Fundamentals

Every field mapping consists of:

---

## Transformation Actions

### Sync (ACTION_TYPE_SYNC)

**Direct field-to-field copy with optional type conversion.**

The simplest mapping action - copies the source field value directly to the target field.

```jsonnet
{
  // Field Nation → External System
  "source": "workorder.title",
  "target": "external_system.job_name",
  "action": "sync"
}
```

**Use Cases:**
- Simple field copies (title → name, id → external_id)
- Numeric values (amount → cost)
- Boolean flags (is_active → active_status)

---

### Set Static (ACTION_TYPE_SET_STATIC)

**Assign a predetermined static value regardless of source data.**

Always sets the target field to a specific value.

```jsonnet
{
  "target": "priority",
  "action": "set_static",
  "value": "High"
}
```

**Use Cases:**
- Default priority levels
- Fixed category assignments
- Constant flags (e.g., `source_system: "Field Nation"`)
- Required fields without source data

**Example: Always set status to "New"**
```jsonnet
{
  "target": "status",
  "action": "set_static",
  "value": "New"
}
```

---

### Array Map (ACTION_TYPE_ARRAY_MAP)

**Map source values to target values using exact match lookups.**

Performs equality checks and returns corresponding mapped values.

```jsonnet
{
  "source": "pay.type",
  "target": "payment_type",
  "action": "array_map",
  "mappings": [
    { "compare": "fixed", "value": "Fixed Price" },
    { "compare": "hourly", "value": "Hourly Rate" },
    { "compare": "blended", "value": "Blended Rate" }
  ],
  "default": "Unknown"
}
```

**Use Cases:**
- Status code mapping (draft → New, assigned → Assigned)
- Priority levels (1 → Low, 2 → Medium, 3 → High)
- Category translation (service → Service Call, install → Installation)
- Enum value conversion

**Example: Work Order Status Mapping**
```jsonnet
{
  "source": "status.name",
  "target": "external_status",
  "action": "array_map",
  "mappings": [
    { "compare": "draft", "value": "New" },
    { "compare": "assigned", "value": "Assigned" },
    { "compare": "work_done", "value": "Completed" },
    { "compare": "approved", "value": "Approved" }
  ],
  "default": "Unknown"
}
```

---

### Range Map (ACTION_TYPE_RANGE_MAP)

**Map numeric values to categories based on range comparisons.**

Uses less-than-or-equal comparisons from right to left.

```jsonnet
{
  "source": "time_logs.hours",
  "target": "duration_category",
  "action": "range_map",
  "ranges": [
    { "compare": 0.5, "value": "15-30 Minutes" },
    { "compare": 1, "value": "31-60 Minutes" },
    { "compare": 2, "value": "1-2 Hours" },
    { "compare": 4, "value": "2-4 Hours" }
  ],
  "default": "4+ Hours"
}
```

**How it works:**
- Value `0.3` → "15-30 Minutes" (≤ 0.5)
- Value `1.5` → "1-2 Hours" (≤ 2)
- Value `5` → "4+ Hours" (default, exceeds all ranges)

**Use Cases:**
- Duration categorization
- Cost tiers (0-100 → Low, 101-500 → Medium, 501+ → High)
- Severity levels based on numeric scores
- SLA priority based on response time

---

### Date Convert (ACTION_TYPE_DATE_CONVERT)

**Transform date values between formats and timezones.**

```jsonnet
{
  "source": "schedule.service_window.start.utc",
  "target": "scheduled_date",
  "action": "date_convert",
  "input_format": "YYYY-MM-DD HH:mm:ss",
  "output_format": "MM/DD/YYYY h:mm:ss A",
  "timezone_in": "UTC",
  "timezone_out": "America/New_York"
}
```

**Common Date Formats:**
- ISO 8601: `YYYY-MM-DDTHH:mm:ssZ`
- US Format: `MM/DD/YYYY`
- Full DateTime: `YYYY-MM-DD HH:mm:ss`
- Unix Timestamp: `X` (seconds) or `x` (milliseconds)

**Use Cases:**
- UTC → Local timezone conversion
- Format standardization (ISO → US format)
- Date-only extraction from datetime fields
- Adding/subtracting time offsets

**Example: UTC to Local Business Hours**
```jsonnet
{
  "source": "created_at",
  "target": "created_local",
  "action": "date_convert",
  "input_format": "YYYY-MM-DD HH:mm:ss",
  "output_format": "MM/DD/YYYY hh:mm A",
  "timezone_in": "UTC",
  "timezone_out": "America/Chicago"
}
```

---

### Concat (ACTION_TYPE_CONCAT)

**Combine multiple fields into a single target field.**

```jsonnet
{
  "target": "full_name",
  "action": "concat",
  "parts": [
    { "type": "field", "value": "assignee.user.first_name" },
    { "type": "static", "value": " " },
    { "type": "field", "value": "assignee.user.last_name" }
  ]
}
```

**Use Cases:**
- Full names from first/last names
- Address lines (street, city, state, zip)
- Composite identifiers (prefix + ID + suffix)
- Description building from multiple fields

**Example: Full Address**
```jsonnet
{
  "target": "full_address",
  "action": "concat",
  "parts": [
    { "type": "field", "value": "location.address1" },
    { "type": "static", "value": ", " },
    { "type": "field", "value": "location.city" },
    { "type": "static", "value": ", " },
    { "type": "field", "value": "location.state" },
    { "type": "static", "value": " " },
    { "type": "field", "value": "location.zip" }
  ]
}
```

---

### Custom (ACTION_TYPE_CUSTOM)

**Execute custom JSONNET code for complex transformations.**

For logic that can't be expressed through standard actions, write custom JSONNET.

```jsonnet
{
  "target": "priority_level",
  "action": "custom",
  "script": |||
    local hours = $.util.lookup_field($.input, 'time_logs.hours', 0);
    local is_urgent = $.util.lookup_field($.input, 'priority', '') == 'urgent';
    
    if is_urgent && hours > 2 then
      "Critical"
    else if is_urgent then
      "High"
    else if hours > 4 then
      "Medium"
    else
      "Low"
  |||
}
```

[Learn more about custom actions →](/docs/connectors/concepts/custom-actions)

---

## Mapping Patterns

### Bidirectional Mappings

Configure separate mappings for each direction:

**Inbound (External → Field Nation)**
```jsonnet
{
  "source": "external_system.job_title",
  "target": "workorder.title",
  "action": "sync"
}
```

**Outbound (Field Nation → External)**
```jsonnet
{
  "source": "workorder.status.name",
  "target": "external_system.status",
  "action": "array_map",
  "mappings": [...]
}
```

---

### Nested Field Access

Use dot notation to access nested objects:

```jsonnet
{
  "source": "workorder.location.company.name",
  "target": "company_name",
  "action": "sync"
}
```

Access array elements:
```jsonnet
{
  "source": "workorder.contacts[0].email",
  "target": "primary_contact_email",
  "action": "sync"
}
```

---

### Custom Field Mappings

Field Nation custom fields require special handling:

**Mapping Custom Fields:**
```jsonnet
{
  "action": "custom",
  "target": "external_field",
  "script": |||
    $.util.lookup_custom_field('835', $.input, 'Default Value')
  |||
}
```

The `lookup_custom_field` function handles Field Nation's custom field structure automatically.

[Learn about custom field IDs →](/docs/rest-api/introduction)

---

## Best Practices

### Field Mapping Strategy

  
    Begin with essential fields using Sync actions. Add complex transformations only after core synchronization works.
    
    **Phase 1**: Required fields (title, description, dates)  
    **Phase 2**: Status and assignment mapping  
    **Phase 3**: Custom fields and advanced logic
  
  
  
    Always provide default values for optional fields to prevent sync failures from missing data.
    
    ```jsonnet
    {
      "source": "optional_field",
      "target": "required_field",
      "action": "sync",
      "default": "N/A"
    }
    ```
  
  
  
    Add comments to JSONNET scripts explaining business logic:
    
    ```jsonnet
    // Priority calculation:
    // - Urgent + >2 hours = Critical
    // - Urgent only = High
    // - >4 hours = Medium
    // - Otherwise = Low
    ```
  
  
  
    When adding new mappings:
    1. Test the mapping in isolation
    2. Verify source data availability
    3. Confirm target field accepts the value
    4. Check edge cases (null, empty, unexpected values)
  

### Performance Considerations

**Keep Mappings Efficient:**
- ✅ Use native actions (Sync, Array Map) when possible
- ✅ Minimize custom JSONNET complexity
- ✅ Cache repeated calculations in local variables
- ⚠️ Avoid nested loops in custom actions
- ⚠️ Limit external API calls within mappings

---

## Common Mapping Scenarios

### Status Synchronization

Map bidirectional status values:

```jsonnet
// Inbound: External → Field Nation
{
  "source": "status",
  "target": "status_id",
  "action": "array_map",
  "mappings": [
    { "compare": "New", "value": "1" },
    { "compare": "Assigned", "value": "2" },
    { "compare": "Completed", "value": "5" }
  ]
}

// Outbound: Field Nation → External
{
  "source": "status.id",
  "target": "external_status",
  "action": "array_map",
  "mappings": [
    { "compare": "1", "value": "Open" },
    { "compare": "2", "value": "In Progress" },
    { "compare": "5", "value": "Closed" }
  ]
}
```

### Contact Information

Combine or split contact fields:

```jsonnet
// Combine first + last name
{
  "target": "full_name",
  "action": "concat",
  "parts": [
    { "type": "field", "value": "user.first_name" },
    { "type": "static", "value": " " },
    { "type": "field", "value": "user.last_name" }
  ]
}

// Extract email domain
{
  "action": "custom",
  "target": "email_domain",
  "script": |||
    local email = $.util.lookup_field($.input, 'user.email', '');
    local parts = std.split(email, '@');
    if std.length(parts) > 1 then parts[1] else ''
  |||
}
```

### Financial Data

Handle currency and decimal precision:

```jsonnet
{
  "source": "pay.amount",
  "target": "cost",
  "action": "custom",
  "script": |||
    local amount = $.util.lookup_field($.input, 'pay.amount', 0);
    std.round(amount * 100) / 100  // Round to 2 decimal places
  |||
}
```

---

## Field Discovery

The Integration Broker automatically discovers available fields from external systems.

### Automatic Field Discovery

1. Navigate to Integration Settings
2. Select your connector
3. Click "Refresh Fields"
4. System queries external API metadata
5. Available fields populate in dropdown menus

### Field Types Discovered

- **Standard Fields**: Built-in platform fields
- **Custom Fields**: User-defined fields
- **Related Objects**: Parent/child relationships
- **Picklist Values**: Available enum values
- **Required Fields**: Marked for validation

---

## Troubleshooting

  
    **Possible Causes:**
    - Source field path incorrect (check dot notation)
    - Source field empty/null (add default value)
    - Target field not writable (check permissions)
    - Data type mismatch (add conversion logic)
    
    **Debug:**
    ```jsonnet
    // Log the source value
    {
      "action": "custom",
      "target": "debug_output",
      "script": |||
        local value = $.util.lookup_field($.input, 'source.path', 'NOT_FOUND');
        std.trace("Source value: " + std.toString(value), value)
      |||
    }
    ```
  
  
  
    **Possible Causes:**
    - Case sensitivity (compare: "new" vs "New")
    - Extra whitespace in source value
    - Numeric vs string comparison
    - Missing default value
    
    **Solution:**
    ```jsonnet
    {
      "action": "custom",
      "target": "status",
      "script": |||
        local raw = $.util.lookup_field($.input, 'status', '');
        local normalized = std.asciiLower(std.stripChars(raw, ' '));
        $.util.array_map([...], normalized, 'Unknown')
      |||
    }
    ```
  
  
  
    **Possible Causes:**
    - Input format doesn't match actual data format
    - Timezone string invalid
    - Null/empty date value
    
    **Solution:**
    Add validation before conversion:
    ```jsonnet
    {
      "action": "custom",
      "target": "converted_date",
      "script": |||
        local date_str = $.util.lookup_field($.input, 'date_field', '');
        if date_str != '' then
          $.util.date_convert(date_str, 'YYYY-MM-DD', 'MM/DD/YYYY')
        else
          ''
      |||
    }
    ```
  

---

---

### undefined
URL: /docs/connectors/concepts/troubleshooting

# Connectors: undefined
URL: /docs/connectors/concepts/troubleshooting
Source: content/docs/connectors/concepts/troubleshooting.mdx

---
title: Troubleshooting
description: Common issues with pre-built connectors and step-by-step solutions to debug integration problems.
---

## Quick Diagnosis

**Work orders not creating or updating?**

### Check Webhook

Verify webhook triggering in external system:
- Check webhook configuration
- Review webhook logs/history
- Test webhook manually

### Verify Authentication

Confirm credentials are valid:
- API keys not expired
- OAuth tokens refreshed
- Correct instance/account ID
- Sufficient permissions

### Review Logs

Check Integration Broker logs:
- Navigate to Integrations → Logs
- Filter by date/time of expected sync
- Look for authentication or validation errors

### Test Manually

Trigger a test sync:
- Create a simple test record
- Verify it meets trigger conditions
- Monitor logs for processing

**Some fields syncing, others not?**

### Check Field Mappings

Review configured mappings:
- Is the field mapped?
- Is the mapping action correct?
- Does source field exist in payload?

### Verify Permissions

Ensure API user can access fields:
- Read permission on source fields
- Write permission on target fields
- Custom field API access enabled

### Test Field Values

Inspect actual data:
- Check source field contains value
- Verify data type matches expectation
- Test transformation logic with sample data

### Review Logs

Look for field-specific errors:
- Validation failures
- Type conversion errors
- JSONNET execution errors

**Seeing errors in logs?**

### Identify Error Category

Determine error type:
- Authentication (401, 403)
- Validation (400, 422)
- Rate Limiting (429)
- Server Error (500, 502, 503)

### Check Error Details

Review error message and context:
- Which API endpoint failed?
- What data was being sent?
- Is error consistent or intermittent?

### Apply Solution

Follow category-specific fix:
- Authentication → Refresh credentials
- Validation → Fix field mappings
- Rate Limit → Add delays/batching
- Server Error → Retry, contact support

### Monitor Resolution

Verify fix resolves issue:
- Trigger test sync
- Watch for successful processing
- Confirm no new errors

**Syncs are slow or delayed?**

### Check Queue Depth

Review message queue status:
- Navigate to Integrations → Metrics
- Check pending message count
- Identify bottlenecks

### Monitor API Response Times

Review external API performance:
- Check Integration Broker logs for latency
- Test external API directly
- Verify no rate limiting

### Optimize Mappings

Reduce transformation complexity:
- Simplify custom JSONNET
- Remove unnecessary field mappings
- Batch operations where possible

### Scale Resources

If consistently slow:
- Contact Field Nation Support
- Request additional worker instances
- Review architecture with support team

---

## Common Issues & Solutions

### Authentication Problems

  
    **Symptoms**: All sync attempts fail with 401 error
    
    **Causes:**
    - API credentials invalid or expired
    - Wrong username/password
    - OAuth token expired
    - API key revoked
    
    **Solutions:**
    1. Regenerate API credentials in external system
    2. Update credentials in Integration Broker
    3. For OAuth: Reauthorize integration
    4. Verify account is active in external platform
    
    **Test:**
    ```bash
    # Test API credentials directly
    curl -H "Authorization: Bearer YOUR_TOKEN" \
         https://external-api.com/api/test
    ```
  
  
  
    **Symptoms**: Authentication succeeds but API calls fail
    
    **Causes:**
    - Insufficient API permissions
    - User not assigned required role
    - IP whitelisting blocking requests
    - API feature not enabled for account
    
    **Solutions:**
    1. Review API user permissions in external system
    2. Grant required roles/permissions
    3. Whitelist Field Nation IP addresses
    4. Enable API access features
    
    **Field Nation IPs to Whitelist:**
    - Sandbox: Check [Environments](/docs/resources/environments)
    - Production: Check [Environments](/docs/resources/environments)
  
  
  
    **Symptoms**: Integration works initially, then stops
    
    **Causes:**
    - Refresh token expired
    - OAuth app configuration changed
    - User revoked access
    
    **Solutions:**
    1. Reauthorize integration in Integration Broker
    2. Verify OAuth app still exists in external system
    3. Check OAuth app client ID/secret unchanged
    4. Ensure refresh token URL correct
  

---

### Data Validation Errors

  
    **Symptoms**: 400 error - "Required field missing"
    
    **Causes:**
    - Required field not mapped
    - Source field empty/null
    - Field mapping action incorrect
    
    **Solutions:**
    1. Identify missing field from error message
    2. Add field mapping for required field
    3. Set default value if source may be empty
    4. Use Set Static action for constant values
    
    **Example:**
    ```jsonnet
    {
      "target": "required_field",
      "action": "set_static",
      "value": "Default Value"
    }
    ```
  
  
  
    **Symptoms**: 422 error - "Invalid value for field"
    
    **Causes:**
    - String sent to numeric field
    - Invalid date format
    - Boolean as string ("true" vs true)
    - Value outside allowed range
    
    **Solutions:**
    1. Check target field expected type
    2. Add type conversion in custom action:
    
    ```jsonnet
    {
      "action": "custom",
      "target": "numeric_field",
      "script": |||
        local value = $.util.lookup_field($.input, 'source', '0');
        std.parseInt(value)
      |||
    }
    ```
    
    3. Use Date Convert action for dates
    4. Use Range Map for numeric categories
  
  
  
    **Symptoms**: Field not accepting value - "Invalid option"
    
    **Causes:**
    - Mapped value not in picklist
    - Case sensitivity mismatch
    - Picklist values changed in external system
    
    **Solutions:**
    1. Refresh field metadata in Integration Broker
    2. Review valid picklist values
    3. Update array map definitions
    4. Use exact case matching
    
    **Example:**
    ```jsonnet
    {
      "action": "array_map",
      "mappings": [
        { "compare": "high", "value": "High" },  // External expects "High"
        { "compare": "low", "value": "Low" }
      ],
      "default": "Medium"
    }
    ```
  

---

### Webhook & Trigger Issues

  
    **Symptoms**: No events reaching Integration Broker
    
    **Causes:**
    - Webhook not configured in external system
    - Trigger conditions not met
    - Webhook URL incorrect
    - Firewall blocking outbound requests
    
    **Solutions:**
    1. Verify webhook exists in external system
    2. Check webhook URL matches Integration Broker trigger URL
    3. Test webhook with manual trigger
    4. Review external system webhook logs
    5. Check network/firewall rules
  
  
  
    **Symptoms**: External system reports webhook timeout
    
    **Causes:**
    - Integration Broker slow to respond
    - High queue depth
    - External API calls taking too long
    
    **Solutions:**
    1. Integration Broker responds quickly (
  
  
    **Symptoms**: Same external record creates multiple work orders
    
    **Causes:**
    - Webhook triggering multiple times
    - No correlation ID check
    - Retry logic creating duplicates
    
    **Solutions:**
    1. Implement idempotency using correlation ID
    2. Check Integration Broker logs for duplicate triggers
    3. Review webhook configuration (should trigger once per record)
    4. Enable duplicate detection in Integration Broker
  

---

### Field Mapping Problems

  
    **Symptoms**: Transformation fails, JSONNET syntax error
    
    **Common Errors:**
    - Syntax error: Missing comma, bracket mismatch
    - Runtime error: Null pointer, type mismatch
    - Logic error: Wrong output, unexpected value
    
    **Debug Steps:**
    1. Test JSONNET in isolation with sample payload
    2. Add `std.trace()` statements to inspect values
    3. Use local variables to break down complex logic
    4. Check Integration Broker logs for error details
    
    **Debug Example:**
    ```jsonnet
    {
      result:
        local value = $.util.lookup_field($.input, 'field', 'default');
        local traced = std.trace("Value: " + std.toString(value), value);
        // Continue with traced value
        traced
    }
    ```
  
  
  
    **Symptoms**: lookup_field returns default value
    
    **Causes:**
    - Incorrect path syntax
    - Field doesn't exist in payload
    - Array access incorrect
    
    **Solutions:**
    1. Check payload structure in logs
    2. Verify dot notation path correct
    3. Use array index for array fields:
    
    ```jsonnet
    // Correct
    $.util.lookup_field($.input, 'contacts[0].email', '')
    
    // Incorrect
    $.util.lookup_field($.input, 'contacts.email', '')
    ```
  
  
  
    **Symptoms**: Date field empty or error
    
    **Causes:**
    - Input format doesn't match actual format
    - Timezone string invalid
    - Source date null/empty
    
    **Solutions:**
    1. Validate date format in source data
    2. Add null check before conversion:
    
    ```jsonnet
    {
      "action": "custom",
      "target": "converted_date",
      "script": |||
        local date = $.util.lookup_field($.input, 'date_field', '');
        if date != '' then
          $.util.date_convert(date, 'YYYY-MM-DD', 'MM/DD/YYYY')
        else
          ''
      |||
    }
    ```
    
    3. Use try-catch pattern for robust handling
  

---

### Performance Issues

  
    **Symptoms**: Messages backing up in queue
    
    **Causes:**
    - External API slow
    - Complex field mappings
    - High volume of events
    - Worker instances insufficient
    
    **Solutions:**
    1. Review external API performance
    2. Simplify field mappings where possible
    3. Batch operations if supported
    4. Contact Field Nation Support for scaling
  
  
  
    **Symptoms**: 429 errors from external API
    
    **Causes:**
    - Too many API calls per minute
    - Burst limit exceeded
    - Per-user limits hit
    
    **Solutions:**
    1. Configure rate limits in Integration Broker
    2. Reduce sync frequency
    3. Batch updates where possible
    4. Request rate limit increase from external platform
  
  
  
    **Symptoms**: Long delay between trigger and sync
    
    **Causes:**
    - Queue backed up
    - External API latency
    - Complex transformations
    - Network issues
    
    **Debug:**
    1. Check Integration Broker metrics for bottleneck
    2. Review logs for timing breakdown
    3. Test external API directly for response time
    4. Simplify field mappings as test
  

---

## Debugging Checklist

Use this systematic approach for any integration issue:

### 1. Gather Information

- ☐ When did the issue start?
- ☐ Is it affecting all syncs or specific records?
- ☐ What changed recently? (configuration, external system, Field Nation)
- ☐ Can you reproduce the issue?

### 2. Check Logs

- ☐ Integration Broker logs for error messages
- ☐ External system webhook logs
- ☐ Field Nation work order history
- ☐ Network/firewall logs if connectivity suspected

### 3. Test Components

- ☐ Test authentication (API credentials work?)
- ☐ Test webhook (manual trigger works?)
- ☐ Test field mappings (with sample data)
- ☐ Test external API directly (outside integration)

### 4. Isolate Problem

- ☐ Is it authentication, validation, or transformation?
- ☐ Is it specific field or all fields?
- ☐ Is it inbound, outbound, or both?
- ☐ Is it consistent or intermittent?

### 5. Apply Fix

- ☐ Update configuration based on findings
- ☐ Test fix with sample sync
- ☐ Monitor for successful processing
- ☐ Document solution for future reference

---

## Getting Help

### Before Contacting Support

Gather this information to expedite support:

1. **Integration Details**
   - Connector name (Salesforce, ServiceNow, etc.)
   - Company ID
   - Environment (Sandbox or Production)

2. **Issue Description**
   - What you expected to happen
   - What actually happened
   - When the issue started
   - Frequency (always, sometimes, once)

3. **Relevant IDs**
   - Work Order ID(s) affected
   - External Record ID(s)
   - Correlation ID(s)
   - Error message timestamps

4. **Troubleshooting Attempted**
   - Steps you've already tried
   - Results of each attempt
   - Any temporary workarounds

### Contact Support

**Field Nation Support:**
- **Portal**: [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases)
- **Phone**: +1 877-573-4353 (24/7)

**Priority Levels:**
- **P1 (Critical)**: Integration completely down, business impact
- **P2 (High)**: Partial failure, workaround available
- **P3 (Medium)**: Minor issue, low impact
- **P4 (Low)**: Question, enhancement request

[Complete support resources →](/docs/resources/support)

---

## Platform-Specific Troubleshooting

Each platform has unique considerations:

  
    Flow and Outbound Message issues
  
  
    Business Rule and REST Message debugging
  
  
    OpenAPI spec and endpoint configuration
  

[View all platforms →](/docs/connectors/introduction)

---

## Preventive Measures

### Monitoring

- ✅ Set up error email notifications
- ✅ Monitor queue depths daily
- ✅ Review sync success rates weekly
- ✅ Check external API health

### Maintenance

- ✅ Test integrations after external system upgrades
- ✅ Rotate API credentials periodically
- ✅ Review and update field mappings
- ✅ Document configuration changes

### Best Practices

- ✅ Start simple, add complexity gradually
- ✅ Test thoroughly in sandbox before production
- ✅ Keep transformation logic simple
- ✅ Use descriptive names for mappings
- ✅ Document business logic in JSONNET comments

---

---

### undefined
URL: /docs/connectors/platforms/freshdesk/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/freshdesk/configuration
Source: content/docs/connectors/platforms/freshdesk/configuration.mdx

---
title: Configuration
description: Configure the Freshdesk connector in Field Nation with API key and field mappings.
---

## Prerequisites

- ☐ Freshdesk API key
- ☐ Freshdesk subdomain (e.g., `company.freshdesk.com`)
- ☐ Admin access to Field Nation

---

## Step 1: Get Freshdesk API Key

### Log into Freshdesk

Use admin account

### Navigate to Profile

Click profile icon → Profile Settings

### Copy API Key

Right sidebar → "Your API Key"  
Click to reveal and copy

---

## Step 2: Configure in Field Nation

Access Integration Broker and select "Freshdesk"

### Freshdesk Subdomain

**Format:** `company` (from `company.freshdesk.com`)

Example: If URL is `acme.freshdesk.com`, enter `acme`

---

### API Key

Paste API key from Step 1

**Authentication Format:**
```
Username: {your_api_key}
Password: X
```

Field Nation handles formatting automatically.

---

## Step 3: Test Connection

Click "Test Connection" → Verify success

---

## Step 4: Refresh Fields & Map

Click "Refresh Fields" → Configure mappings:

**Inbound:**
```
subject → title
description → description
status → status_id (Array Map)
priority → priority (Array Map)
requester.name → contact.name
due_by → schedule.start (Date Convert)
```

**Outbound:**
```
status.name → status (Array Map)
completion_notes → private_note
```

**Status Mapping:**
```
Freshdesk: Open, Pending, Resolved, Closed
Field Nation: Draft, Assigned, Work Done, Approved
```

---

## Step 5: Save & Get Trigger URL

Save → Copy trigger URL for Freshdesk webhook

---

## Troubleshooting

  
    - Verify API key correct
    - Check subdomain spelling
    - Ensure API access enabled
  
  
  
    - Check API key permissions
    - Verify custom fields accessible
    - Try "Refresh Fields" again
  

---

---

### undefined
URL: /docs/connectors/platforms/freshdesk/overview

# Connectors: undefined
URL: /docs/connectors/platforms/freshdesk/overview
Source: content/docs/connectors/platforms/freshdesk/overview.mdx

---
title: Freshdesk Connector
description: Integrate Freshdesk helpdesk with Field Nation for automated field service dispatch from support tickets.
---

## Overview

The Freshdesk connector enables seamless integration between Freshdesk and Field Nation:
- **Ticket-based dispatch**: Create work orders from Freshdesk tickets
- **REST API integration**: Simple authentication via API key
- **Webhook triggers**: Real-time notifications
- **Bidirectional sync**: Status and notes flow both directions
- **Custom fields support**: Map Freshdesk custom fields

---

## At a Glance

  
    API Key (Basic Auth)
  
  
    Tickets
  
  
    Webhooks (automation rules)
  
  
    Bidirectional (create, update, notes)
  

---

## How It Works

### Configure Automation

Set up automation rule in Freshdesk that triggers on ticket status/tag changes

### Webhook Fires

Freshdesk sends ticket ID to Field Nation when conditions met

### Fetch Ticket Data

Integration Broker retrieves complete ticket from Freshdesk REST API

### Apply Mappings

Transform Freshdesk ticket into Field Nation work order

### Create Work Order

Work order created with correlation ID for bidirectional sync

---

## Common Use Cases

### Dispatch from Support Ticket

```
Ticket Status = "Field Service Required"
  → Webhook triggers
  → Work order created
```

### Tag-Based Dispatch

```
Tag = "on-site"
  → Automation rule fires
  → Field technician dispatched
```

### Status Sync Back

```
FN Work Order = "Completed"
  → Freshdesk Ticket Status = "Resolved"
  → Private note added
```

---

## Features

### Field Mapping Capabilities

- **Standard Fields**: Subject, Description, Status, Priority, Due By
- **Custom Fields**: All custom ticket fields
- **Requester Info**: Name, email, phone, company
- **Attachments**: Optional file sync
- **Tags**: Map Freshdesk tags

### Supported Operations

---

## Prerequisites

### Freshdesk Requirements

  
    Generate in Freshdesk:
    1. Profile Settings → View Profile
    2. Your API Key (right sidebar)
    3. Copy key for Field Nation
  
  
  
    - Admin or account admin role
    - Ability to create automation rules
    - Ability to configure webhooks
  
  
  
    API key must have:
    - Read access to tickets
    - Write access for status updates
    - Access to custom fields
  

---

## Authentication

Freshdesk uses **Basic Authentication** with API key:

```
Format: username:password
Username: API Key
Password: X (literal "X")
```

**Example:**
```
Authorization: Basic base64(your_api_key:X)
```

> [INFO] **Simple Setup**: Freshdesk uses API key as username, literal "X" as password for Basic Auth.

---

## Best Practices

- ✅ Use automation rules for triggering (not manual webhooks)
- ✅ Test in sandbox Freshdesk account first
- ✅ Map priority/status correctly
- ✅ Use tags for workflow control
- ✅ Monitor webhook delivery

---

---

### undefined
URL: /docs/connectors/platforms/freshdesk/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/freshdesk/workflow
Source: content/docs/connectors/platforms/freshdesk/workflow.mdx

---
title: Workflow Setup
description: Configure Freshdesk automation rules to trigger Field Nation work order creation.
---

## Prerequisites

- ☐ [Field Nation configuration complete](/docs/connectors/platforms/freshdesk/configuration)
- ☐ Trigger URL copied
- ☐ Freshdesk admin access

---

## Configure Automation in Freshdesk

### Navigate to Automations

Admin → Workflows → Automations

### Create Ticket Update Rule

Click "+ New Rule" → Select "Ticket Updates"

### Configure Trigger

**Rule Name**: `Send to Field Nation`

**Description**: Auto-dispatch tickets requiring field service

**When an action performed by**: Agent or Requester

**Involves any of these events:**
- ☑ Status is changed
- ☑ Tag is added

**On tickets with these properties:**
```
Status is "Field Service Required"
OR
Tags contains "on-site"
```

### Configure Action

**Perform these actions:**
- Trigger webhook

**Webhook URL**: Paste Field Nation trigger URL

**Method**: POST

**Content**: JSON

**Request Body:**
```json
{
  "ticket_id": "{{ticket.id}}",
  "status": "{{ticket.status}}",
  "priority": "{{ticket.priority}}"
}
```

**Encoding**: JSON

### Save & Activate

Save rule → Toggle to "Active"

---

## Test Integration

### Create Test Ticket

1. Create new ticket in Freshdesk
2. Set status to "Field Service Required"
3. Or add "on-site" tag
4. Save

### Verify Automation

Check Admin → Audit Logs:
- Look for automation execution
- Verify webhook sent

### Check Field Nation

Verify work order created with correct data

---

## Troubleshooting

  
    - Check rule is Active
    - Verify ticket meets conditions
    - Review Audit Logs for execution
    - Test with simple conditions first
  
  
  
    - Verify trigger URL correct
    - Check Freshdesk can reach URL
    - Review webhook response in logs
    - Test URL with curl/Postman
  
  
  
    - Check Field Nation config valid
    - Verify all required fields mapped
    - Review Integration Broker logs
    - Test with minimal ticket data
  

---

## Advanced Configuration

### Multiple Automation Rules

**Rule 1**: Urgent Tickets
```
Priority = Urgent
→ Immediate dispatch
```

**Rule 2**: Standard Tickets
```
Status = "Field Service Required"
Priority != Urgent
→ Normal dispatch
```

### Prevent Duplicate Sends

Add custom field:
```
Field: "Synced to FN"
Type: Checkbox
```

Update rule conditions:
```
Status = "Field Service Required"
AND "Synced to FN" is NOT true
```

After sync, set checkbox to true.

---

---

### undefined
URL: /docs/connectors/platforms/netsuite/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/netsuite/configuration
Source: content/docs/connectors/platforms/netsuite/configuration.mdx

---
title: Configuration
description: Configure the NetSuite connector with Token-Based Authentication and SuiteTalk SOAP API credentials.
---

## Prerequisites

- ☐ NetSuite Account ID
- ☐ Consumer Key & Secret (from Integration Record)
- ☐ Token ID & Secret (from Access Token)
- ☐ NetSuite instance URL
- ☐ Admin access to Field Nation

---

## Step 1: Enable Token-Based Authentication

### Navigate to Features

Setup → Company → Enable Features

### Enable TBA

**SuiteCloud** tab → Check "Token-Based Authentication" ✅

### Save

Click "Save" to enable feature

---

## Step 2: Create Integration Record

### Navigate to Integrations

Setup → Integration → Manage Integrations → New

### Configure Integration

**Name**: `Field Nation Integration`

**State**: Enabled ✅

**Concurrency Limit**: Leave default

### Save & Copy Credentials

After save, copy:
- **Consumer Key** (shown once)
- **Consumer Secret** (shown once)

Store securely immediately!

---

## Step 3: Generate Access Token

### Navigate to Access Tokens

Setup → Users/Roles → Access Tokens → New

### Configure Token

**Application Name**: Select "Field Nation Integration" (from Step 2)

**User**: Select integration user (or create dedicated user)

**Role**: Administrator or custom integration role

**Token Name**: `Field Nation API Token`

### Save & Copy Credentials

After save, copy:
- **Token ID**
- **Token Secret** (shown once!)

> **Critical**: Token Secret displayed ONCE. Save immediately to secure password manager.

---

## Step 4: Get Account ID

**Setup → Company → Company Information**

**Account ID** field → Copy value

Example: `1234567` or `1234567_SB1` (sandbox)

---

## Step 5: Configure in Field Nation

Access Integration Broker → Select "NetSuite"

### Enter Credentials

**Account ID**: From Step 4

**Consumer Key**: From Integration Record (Step 2)

**Consumer Secret**: From Integration Record (Step 2)

**Token ID**: From Access Token (Step 3)

**Token Secret**: From Access Token (Step 3)

---

### Instance URL

**Format:**
```
https://{account_id}.suitetalk.api.netsuite.com/services/NetSuitePort_2021_2
```

**Sandbox:**
```
https://{account_id}_SB1.suitetalk.api.netsuite.com/services/NetSuitePort_2021_2
```

Field Nation may auto-construct this from Account ID.

---

### Record Type

**Supported:**
- `serviceOrder` - Service orders (most common)
- `supportCase` - Support cases
- `customRecord_*` - Custom records

---

## Step 6: Test Connection

Click "Test Connection"

**Success** ✅: Credentials valid, SuiteTalk API accessible

**Failure** ❌: Review error:

  
    - Verify all 5 credentials correct
    - Ensure Token not expired/revoked
    - Check Account ID includes sandbox suffix if applicable
  
  
  
    - Grant integration role full access to target records
    - Check user has role assigned
    - Verify TBA enabled
  

---

## Step 7: Refresh Fields & Map

Click "Refresh Fields" → Configure mappings:

**Inbound:**
```
title → title
message → description
status → status_id (Array Map)
subsidiary.name → location.company.name
```

**Outbound:**
```
status.name → status (Array Map)
approved_amount → actualCost
```

---

## Step 8: Save Configuration

Review settings → Save → Copy trigger URL

---

## Troubleshooting

  
    - Verify TBA enabled in features
    - Check all 5 credentials correct
    - Ensure token not revoked
    - Test with NetSuite REST API explorer
  
  
  
    - Verify record type exists
    - Check API name (camelCase)
    - For custom records: Use `customRecord_{id}`
  

---

---

### undefined
URL: /docs/connectors/platforms/netsuite/overview

# Connectors: undefined
URL: /docs/connectors/platforms/netsuite/overview
Source: content/docs/connectors/platforms/netsuite/overview.mdx

---
title: NetSuite Connector
description: Integrate NetSuite ERP with Field Nation for automated work order creation and service management synchronization.
---

## Overview

The NetSuite connector enables seamless integration between NetSuite ERP and Field Nation:
- **Service order dispatch**: Create work orders from NetSuite service records
- **SuiteTalk SOAP API**: Token-based authentication (TBA)
- **SuiteScript integration**: Custom triggers via SuiteScripts
- **Bidirectional sync**: Status, costs, and completion data flow both ways
- **Custom fields support**: Map NetSuite custom fields

---

## At a Glance

  
    Token-Based Authentication (TBA) - Account ID + Consumer Key/Secret + Token Key/Secret
  
  
    Service Orders, Cases, Custom Records
  
  
    SuiteScript + Webhooks
  
  
    Bidirectional (create, update, financial)
  

---

## How It Works

### Deploy SuiteScript

Deploy custom SuiteScript in NetSuite that monitors service records

### Script Triggers

SuiteScript evaluates conditions (status change, custom field) and sends webhook

### Field Nation Receives

Integration Broker receives notification with NetSuite record ID

### Fetch Record Data

Broker retrieves complete record via SuiteTalk SOAP API

### Create Work Order

Transformed data creates Field Nation work order

---

## Common Use Cases

### Service Order Dispatch

```
Service Order Status = "Ready for Dispatch"
  → SuiteScript triggers
  → Work order created
  → Service order updated
```

### Case-Based Dispatch

```
Case Type = "On-Site Service"
AND Status = "Escalated"
  → Webhook fires
  → Field technician dispatched
```

### Financial Tracking

```
FN Work Order = "Approved"
  → NetSuite Service Order updated
  → Costs synchronized
  → Invoice generated
```

---

## Features

### Field Mapping Capabilities

- **Standard Fields**: Title, Message, Status, Sales Order Number
- **Custom Fields**: All custom fields on target record type
- **Related Records**: Customer, Contact, Location, Item
- **Financial Fields**: Cost, revenue, billing codes
- **Sublists**: Line items, time entries, expenses

### Supported Operations

---

## Prerequisites

### NetSuite Requirements

  
    Enable TBA in NetSuite:
    1. Setup → Company → Enable Features
    2. SuiteCloud → Token-Based Authentication ✅
    3. Save
  
  
  
    Create integration record:
    1. Setup → Integration → Manage Integrations → New
    2. Name: "Field Nation Integration"
    3. State: Enabled
    4. Copy: Consumer Key, Consumer Secret
  
  
  
    Generate access token:
    1. Setup → Users/Roles → Access Tokens → New
    2. Application Name: Field Nation Integration (from above)
    3. User: Integration user
    4. Role: Administrator or custom integration role
    5. Copy: Token ID, Token Secret
  
  
  
    - Ability to deploy SuiteScripts
    - Admin or developer role
    - Access to target record types
  

---

## Authentication

NetSuite uses **Token-Based Authentication (TBA)** with OAuth 1.0:

```
Account ID: {account_id}
Consumer Key: {consumer_key}
Consumer Secret: {consumer_secret}
Token ID: {token_id}
Token Secret: {token_secret}
```

**Generate Credentials:**
1. Enable TBA in NetSuite Features
2. Create Integration Record → Get Consumer Key/Secret
3. Generate Access Token → Get Token ID/Secret
4. Note Account ID (found in Setup → Company Information)

> **Security**: Token Secret shown ONCE during generation. Save immediately to secure location.

---

## Best Practices

- ✅ Use dedicated integration role
- ✅ Test SuiteScripts in sandbox account
- ✅ Monitor SuiteTalk API usage
- ✅ Handle NetSuite's complex data model carefully
- ✅ Document SuiteScript logic thoroughly

---

## Limitations

- SOAP-based API (more complex than REST)
- Token rotation required periodically
- SuiteScript deployment requires technical expertise
- Sublist/line item mapping can be complex

---

---

### undefined
URL: /docs/connectors/platforms/netsuite/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/netsuite/workflow
Source: content/docs/connectors/platforms/netsuite/workflow.mdx

---
title: Workflow Setup
description: Deploy SuiteScripts and configure NetSuite workflows to trigger Field Nation work order creation.
---

## Prerequisites

- ☐ [Field Nation configuration complete](/docs/connectors/platforms/netsuite/configuration)
- ☐ Trigger URL copied
- ☐ NetSuite admin/developer access
- ☐ SuiteScript knowledge (or developer available)

---

## NetSuite Integration Approach

NetSuite integration requires **SuiteScript deployment** to trigger webhooks:

```mermaid
graph LR
    A[Record Created/Updated] --> B[User Event Script]
    B --> C{Conditions Met?}
    C -->|Yes| D[Send HTTPS Request]
    D --> E[Field Nation]
    C -->|No| F[No Action]
```

---

## Step 1: Create SuiteScript

Deploy User Event Script to trigger on record changes:

### Sample SuiteScript 2.0

```javascript
/**
 * @NApiVersion 2.1
 * @NScriptType UserEventScript
 */
define(['N/https', 'N/record'], (https, record) => {
    
    const afterSubmit = (context) => {
        try {
            const newRecord = context.newRecord;
            const status = newRecord.getValue({ fieldId: 'status' });
            
            // Only trigger if status = "Ready for Dispatch"
            if (status === 'Ready for Dispatch') {
                
                const recordId = newRecord.id;
                const recordType = newRecord.type;
                
                // Field Nation trigger URL
                const fnUrl = 'https://api.fieldnation.com/integrations/trigger/{YOUR_CLIENT_TOKEN}';
                
                const payload = {
                    recordId: recordId,
                    recordType: recordType,
                    timestamp: new Date().toISOString()
                };
                
                const response = https.post({
                    url: fnUrl,
                    body: JSON.stringify(payload),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                log.audit({
                    title: 'Field Nation Trigger Sent',
                    details: 'Record ID: ' + recordId + ', Response: ' + response.code
                });
                
                // Optional: Update custom field to track sync
                // record.submitFields({
                //     type: recordType,
                //     id: recordId,
                //     values: { custbody_fn_synced: true }
                // });
            }
            
        } catch (e) {
            log.error({
                title: 'Field Nation Trigger Error',
                details: e.message
            });
        }
    };
    
    return {
        afterSubmit: afterSubmit
    };
});
```

---

## Step 2: Upload & Deploy Script

### Create Script File

Save the script as `fieldnation_trigger_ue.js`

### Upload to File Cabinet

Customization → Scripting → Scripts → Files → SuiteScripts → Upload

### Create Script Record

Customization → Scripting → Scripts → New

**Name**: Field Nation Trigger  
**ID**: `customscript_fn_trigger`  
**Script File**: Select uploaded file  
**Function**: `afterSubmit`

### Create Script Deployment

**Applied To**: Select record type (Service Order, Case, etc.)  
**Status**: Testing (initially)  
**Execute As Role**: Administrator  
**Log Level**: Debug (for testing)

**Audience**: All Roles

### Save Deployment

Click "Save"

---

## Step 3: Test Integration

### Create Test Record

1. Create Service Order in NetSuite
2. Set status to "Ready for Dispatch"
3. Save record

### Verify Script Execution

Customization → Scripting → Script Execution Log

Look for "Field Nation Trigger Sent" log entry

### Check Field Nation

Verify work order created with correct data

### Review Logs

Check for any errors in execution log

---

## Advanced Configuration

### Conditional Triggering

Add complex logic to SuiteScript:

```javascript
// Only trigger for specific subsidiaries
const subsidiary = newRecord.getValue({ fieldId: 'subsidiary' });
if (subsidiary !== 'US Operations') return;

// Only for high-priority orders
const priority = newRecord.getValue({ fieldId: 'priority' });
if (priority < 3) return;

// Check custom field
const sendToFN = newRecord.getValue({ fieldId: 'custbody_send_to_fn' });
if (!sendToFN) return;
```

---

### Prevent Duplicate Sends

```javascript
// Check if already synced
const fnSynced = newRecord.getValue({ fieldId: 'custbody_fn_synced' });
if (fnSynced) {
    log.audit('Already synced', 'Skipping');
    return;
}

// Send webhook...

// Mark as synced
record.submitFields({
    type: newRecord.type,
    id: newRecord.id,
    values: { custbody_fn_synced: true },
    options: { enableSourcing: false, ignoreMandatoryFields: true }
});
```

---

## Troubleshooting

  
    - Check deployment status = "Released"
    - Verify record type matches deployment
    - Check audience includes current user
    - Review script execution log for errors
  
  
  
    - Verify trigger URL correct
    - Check NetSuite outbound HTTPS enabled
    - Review Governance limits (10 HTTPS requests per script)
    - Test URL externally (curl/Postman)
  
  
  
    - Check Field Nation credentials valid
    - Verify SuiteTalk API accessible
    - Review Integration Broker logs
    - Test with minimal field set
  

---

## Production Deployment

### Test in Sandbox

Deploy and test in NetSuite sandbox account

### Update Script Status

Change deployment status to "Released"

### Monitor Execution

Watch script execution logs for first week

### Optimize

Adjust conditions, improve performance, reduce API calls

---

---

### undefined
URL: /docs/connectors/platforms/connectwise/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/connectwise/configuration
Source: content/docs/connectors/platforms/connectwise/configuration.mdx

---
title: Configuration
description: Configure the ConnectWise connector in Field Nation with REST API keys and field mappings.
---

## Prerequisites Checklist

- ☐ ConnectWise Company ID
- ☐ Public Key (generated in ConnectWise)
- ☐ Private Key (generated in ConnectWise)
- ☐ Member ID (API member)
- ☐ ConnectWise instance URL
- ☐ Admin access to Field Nation integrations

---

## Step 1: Generate ConnectWise API Keys

### Log into ConnectWise

Use admin account

### Navigate to API Member

System → Members → Select API member (or create new dedicated member)

### Generate API Keys

**API Keys** tab → Click "Generate New Key Pair"

**Copy immediately:**
- Company ID
- Public Key
- Private Key

> **Important**: Private Key shown ONCE. Save securely immediately.

### Note Member ID

Copy Member ID from member profile (needed for authentication)

---

## Step 2: Access Integration Broker

**Sandbox**: [ui-sandbox.fndev.net/integrations](https://ui-sandbox.fndev.net/integrations)  
**Production**: [app.fieldnation.com/integrations](https://app.fieldnation.com/integrations)

Select "ConnectWise" connector

---

## Step 3: Configure Connection

### Instance URL

**Format:**
```
https://api-{region}.myconnectwise.net/v4_6_release/apis/3.0
```

**Regions:**
- `na` - North America
- `eu` - Europe
- `au` - Australia
- `staging` - Staging environment

**Example:** `https://api-na.myconnectwise.net/v4_6_release/apis/3.0`

---

### Authentication Credentials

**Company ID**: Your ConnectWise company identifier

**Public Key**: API public key from Step 1

**Private Key**: API private key from Step 1

**Member ID**: API member's ID for impersonation

**Client ID** (optional): `FieldNationIntegration`

---

### Entity Configuration

**Table**: `service/tickets` (most common)

Other options:
- `project/tickets`
- `sales/opportunities`

---

## Step 4: Test Connection

Click "Test Connection" → Verify success

**Common Errors:**

  
    **Solution:**
    - Regenerate keys in ConnectWise
    - Ensure Private Key copied correctly
    - Check Company ID matches
  
  
  
    **Solution:**
    - Grant API member access to Service Desk
    - Enable "Read" and "Write" permissions
    - Check security role assignments
  

---

## Step 5: Refresh Fields & Configure Mappings

Click "Refresh Fields" → Map fields:

**Inbound:**
```
summary → title
initialDescription → description
status.name → status_id (Array Map)
priority.name → priority (Array Map)
company.name → location.company.name
```

**Outbound:**
```
status.name → status (Array Map)
completion_notes → internalAnalysis
```

[Field mapping guide →](/docs/connectors/concepts/field-mappings)

---

## Step 6: Save & Get Trigger URL

Save configuration → Copy trigger URL for ConnectWise callback setup

---

---

### undefined
URL: /docs/connectors/platforms/connectwise/overview

# Connectors: undefined
URL: /docs/connectors/platforms/connectwise/overview
Source: content/docs/connectors/platforms/connectwise/overview.mdx

---
title: ConnectWise Connector
description: Integrate ConnectWise Manage with Field Nation for automated field service dispatch from service tickets and project tasks.
---

## Overview

The ConnectWise connector enables seamless integration between ConnectWise Manage and Field Nation:
- **Service ticket dispatch**: Automatically create work orders from ConnectWise Service Tickets
- **REST API integration**: Modern API with member impersonation
- **Callback-based triggers**: Real-time notifications via callbacks
- **Bidirectional sync**: Status and notes flow both directions
- **Custom fields support**: Map ConnectWise custom fields

---

## At a Glance

  
    API Keys (Company ID + Public/Private Key + Member ID)
  
  
    Service Tickets, Project Tickets, Opportunities
  
  
    Callbacks (webhooks) + API polling
  
  
    Bidirectional (create, update, notes)
  

---

## How It Works

### Configure Callback

Set up callback in ConnectWise that triggers on ticket status changes

### Callback Notification

ConnectWise sends ticket ID to Field Nation when conditions met

### Field Nation Fetches Data

Integration Broker retrieves complete ticket data from ConnectWise REST API

### Apply Mappings

Broker transforms ConnectWise data into Field Nation work order format

### Create Work Order

Work order created with correlation ID stored for bidirectional sync

---

## Common Use Cases

### Dispatch from Service Ticket

Automatically create Field Nation work order when Service Ticket requires on-site technician

```
Service Ticket Status = "Dispatch"
AND Board = "Field Services"
  → Callback triggers
  → Field Nation Work Order Created
```

### Project-Based Dispatch

Create work orders from ConnectWise Project tickets

```
Project Ticket Type = "On-Site"
AND Status = "Scheduled"
  → Work order created
  → Project ticket updated
```

### Status Synchronization

Reflect Field Nation completion back to ConnectWise

```
FN Work Order = "Completed"
  → Integration Broker
  → CW Ticket Status = "Completed"
  → Internal Note added
```

---

## Architecture

```mermaid
sequenceDiagram
    participant CW as ConnectWise
    participant CB as Callback
    participant Broker as Integration Broker
    participant FN as Field Nation
    
    CW->>CB: Ticket Status Changed
    CB->>Broker: POST Trigger URL (Ticket ID)
    Broker->>CW: GET /service/tickets/{id}
    CW-->>Broker: Ticket Data
    Broker->>Broker: Apply Field Mappings
    Broker->>FN: Create/Update Work Order
    FN-->>Broker: Success + WO ID
    Broker->>CW: POST /service/tickets/{id}/notes
```

---

## Features

### Field Mapping Capabilities

- **Standard Fields**: Summary, Initial Description, Status, Priority, Date Resolved
- **Custom Fields**: Access any custom field on Service Ticket
- **Related Objects**: Company, Contact, Member (resource), Board
- **Service Location**: Site address information
- **Time Entries**: Integration with ConnectWise time tracking

### Supported Operations

---

## Prerequisites

### ConnectWise Requirements

  
    - ConnectWise Manage license with API access
    - Admin or API-enabled member account
    - API keys generated (Public + Private)
    - Member impersonation configured
  
  
  
    Generate in ConnectWise:
    1. System → Members → Select API member
    2. API Keys tab → Generate New Keys
    3. Copy Company ID, Public Key, Private Key
    4. Note Member ID for impersonation
  
  
  
    - Ability to configure ConnectWise callbacks
    - Callback endpoint URL from Field Nation
    - Network access to send callbacks
    - Optional: IP whitelisting for Field Nation
  
  
  
    API member must have:
    - Read access to Service Tickets and all fields
    - Write access for status/note updates
    - Access to related objects (Company, Contact, Site)
    - Permission to view custom fields
  

### Field Nation Requirements

- Active buyer account with admin access
- Integration settings access
- Sandbox environment (recommended for testing)

[Complete prerequisites →](/docs/connectors/getting-started)

---

## Authentication

ConnectWise connector uses **API Key Authentication** with member impersonation:

```
Company ID: {company_id}
Public Key: {public_key}
Private Key: {private_key}
Member ID: {member_id}
Client ID: Field Nation Integration
```

**Components:**
- **Company ID**: Your ConnectWise company identifier
- **Public Key**: API public key (generated)
- **Private Key**: API private key (generated, keep secure)
- **Member ID**: API member's ID for impersonation
- **Client ID**: Integration identifier (optional)

**Authentication Header Format:**
```
Authorization: Basic base64(CompanyID+PublicKey+PrivateKey:MemberID)
Client-Id: FieldNationIntegration
```

> **Security Best Practice**: Use dedicated API member (not personal account). Store Private Key securely - it's equivalent to a password.

---

## Data Flow Patterns

### Inbound: ConnectWise → Field Nation

**Trigger**: Callback fired on ticket status/board change  
**Action**: Callback sends Ticket ID to Field Nation  
**Result**: Field Nation work order created/updated

**Example Callback Triggers:**
- Ticket Status changed to "Dispatch"
- Board changed to "Field Services"
- Custom field "Send to FN" = true
- Priority set to "Priority 1"

---

### Outbound: Field Nation → ConnectWise

**Trigger**: Field Nation work order event  
**Action**: Integration Broker calls ConnectWise REST API  
**Result**: ConnectWise ticket updated with status/notes

**Configurable Events:**
- Work order assigned → Update ticket status
- Work order completed → Add internal note
- Provider checked in → Update custom field
- Work order approved → Update status to "Completed"

---

## Best Practices

### Callback Design

- ✅ Use specific status/board values
- ✅ Configure for relevant ticket types only
- ✅ Add safeguards to prevent duplicates
- ✅ Test in staging ConnectWise instance
- ✅ Monitor callback delivery logs

### Field Mappings

- ✅ Map all required Field Nation fields
- ✅ Use custom fields for additional data
- ✅ Handle ConnectWise status boards correctly
- ✅ Test service location address mapping
- ✅ Document custom field IDs

### Security

- ✅ Use dedicated API member
- ✅ Rotate API keys annually
- ✅ Grant minimum required permissions
- ✅ Monitor API usage in ConnectWise
- ✅ Enable IP whitelisting if required

---

## Limitations & Considerations

### API Limits

ConnectWise enforces rate limits:
- Typically 1,000 requests per 5 minutes
- Monitor via System → API Usage

Each work order sync consumes **2-3 API calls**.

### REST API Versioning

- ConnectWise API versions periodically
- Test after ConnectWise upgrades
- Review release notes for breaking changes

### Related Object Depth

Can access:
- ✅ Fields on Service Ticket
- ✅ Fields from Company, Contact, Board, Site
- ❌ Deep nested relationships (custom JSONNET needed)

---

---

### undefined
URL: /docs/connectors/platforms/connectwise/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/connectwise/workflow
Source: content/docs/connectors/platforms/connectwise/workflow.mdx

---
title: Workflow Setup
description: Configure ConnectWise callbacks to automatically send service ticket data to Field Nation.
---

## Prerequisites

- ☐ [Field Nation configuration complete](/docs/connectors/platforms/connectwise/configuration)
- ☐ Trigger URL copied
- ☐ ConnectWise admin access

---

## Configure Callback in ConnectWise

### Navigate to Callbacks

System → Setup Tables → Callbacks

### Create New Callback

Click "+" to add new callback

### Configure Callback

**Description**: `Field Nation Integration`

**URL**: Paste Field Nation trigger URL

**Object Type**: `Service Ticket`

**Level**: `Owner Level` or `All Levels`

**Trigger Events:**
- ☑ Added
- ☑ Changed
- ☐ Deleted (optional)

**Inactive Members**: Unchecked

---

## Define Trigger Conditions

**Option 1: Status-Based**
```
Status changed to "Dispatch"
```

**Option 2: Board-Based**
```
Board = "Field Services"
```

**Option 3: Custom Field**
```
Custom Field "Send to FN" = true
```

Use ConnectWise workflow rules or automation to set these conditions.

---

## Test Integration

1. Create test service ticket
2. Update to trigger callback conditions
3. Verify webhook fires (System → Callback Log)
4. Check Field Nation for work order

---

## Troubleshooting

  
    Check:
    - Callback active
    - Trigger events selected
    - Level permissions correct
    - URL accessible
  
  
  
    Check:
    - Field Nation credentials valid
    - All required fields mapped
    - Callback log for errors
    - Integration Broker logs
  

---

---

### undefined
URL: /docs/connectors/platforms/quickbase/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/quickbase/configuration
Source: content/docs/connectors/platforms/quickbase/configuration.mdx

---
title: Configuration
description: Configure the Quickbase connector in Field Nation with user token and table mappings.
---

## Prerequisites

- ☐ Quickbase User Token
- ☐ Quickbase Realm (subdomain)
- ☐ App ID and Table ID
- ☐ Admin access to Field Nation

---

## Step 1: Generate Quickbase User Token

### Log into Quickbase

Use admin or dedicated integration user account

### Navigate to User Tokens

Profile → My Preferences → Manage User Tokens

### Create New Token

Click "+ New User Token"

**Name**: `Field Nation Integration`

**Description**: Integration between Quickbase and Field Nation

**Applications**: Select apps that need access

**Token**: Copy immediately (shown once!)

---

## Step 2: Get App & Table Information

### Find App ID

Open your Quickbase app → URL shows App ID:
```
https://realm.quickbase.com/db/{app_id}
```

Example: `br5k3a4mn`

### Find Table ID

Open table → URL shows Table ID:
```
https://realm.quickbase.com/db/{table_id}
```

Example: `bskt8r3fn`

### Note Realm

Your Quickbase subdomain:
```
https://{realm}.quickbase.com
```

Example: If URL is `acme.quickbase.com`, realm is `acme`

---

## Step 3: Configure in Field Nation

Access Integration Broker → Select "Quickbase"

### Realm

Enter your Quickbase realm (subdomain)

Example: `acme` (from `acme.quickbase.com`)

---

### User Token

Paste user token from Step 1

**Authentication Header:**
```
QB-USER-TOKEN {your_user_token}
```

---

### App ID

Enter App ID from Step 2

Example: `br5k3a4mn`

---

### Table ID

Enter Table ID from Step 2

Example: `bskt8r3fn`

---

## Step 4: Test Connection

Click "Test Connection"

**Success** ✅: Token valid, app & table accessible

**Failure** ❌: Check:

  
    - Verify token copied correctly
    - Ensure token not revoked/expired
    - Check token has access to app
  
  
  
    - Verify App ID correct
    - Check Table ID correct
    - Ensure token user has table access
  
  
  
    - Grant token access to app
    - Check user has table read/write permissions
    - Verify field-level permissions
  

---

## Step 5: Refresh Fields & Map

Click "Refresh Fields" → Quickbase API queries table schema

**Inbound Mappings:**
```
Field 6 (Title) → title
Field 7 (Description) → description
Field 11 (Status) → status_id (Array Map)
Field 12 (Customer Name) → location.company.name
Field 14 (Due Date) → schedule.start (Date Convert)
```

**Field IDs**: Quickbase uses numeric field IDs (Field 6, Field 7, etc.)

**Outbound Mappings:**
```
status.name → Field 11 (Array Map)
completion_notes → Field 20
completion_date → Field 21 (Date Convert)
```

[Field mapping guide →](/docs/connectors/concepts/field-mappings)

---

## Step 6: Save Configuration

Review → Save → Copy trigger URL for Quickbase automation

---

## Troubleshooting

  
    - Verify token has table access
    - Check Table ID correct
    - Try "Refresh Fields" again
    - Review API response in logs
  
  
  
    - Check field IDs correct
    - Verify data type compatibility
    - Use proper transformation actions
    - Test with sample data
  

---

---

### undefined
URL: /docs/connectors/platforms/quickbase/overview

# Connectors: undefined
URL: /docs/connectors/platforms/quickbase/overview
Source: content/docs/connectors/platforms/quickbase/overview.mdx

---
title: Quickbase Connector
description: Integrate Quickbase applications with Field Nation for automated work order creation and bidirectional data synchronization.
---

## Overview

The Quickbase connector enables seamless integration between Quickbase applications and Field Nation:
- **Table-based sync**: Create work orders from any Quickbase table
- **REST API integration**: Modern JSON API with user tokens
- **Webhook triggers**: Real-time notifications via Quickbase automations
- **Bidirectional sync**: Data flows both directions automatically
- **Custom fields support**: Map any Quickbase field

---

## At a Glance

  
    User Token (Bearer token)
  
  
    Any Quickbase table in your apps
  
  
    Quickbase Automations (webhooks)
  
  
    Bidirectional (create, update)
  

---

## How It Works

### Configure Automation

Create Quickbase automation that triggers on record changes

### Webhook Fires

Quickbase sends record ID to Field Nation when conditions met

### Fetch Record Data

Integration Broker retrieves complete record from Quickbase REST API

### Apply Mappings

Transform Quickbase record into Field Nation work order

### Create Work Order

Work order created with correlation ID for bidirectional sync

---

## Common Use Cases

### Service Request Dispatch

```
Table: Service Requests
Trigger: Status = "Approved"
  → Work order created in Field Nation
```

### Work Order Tracking

```
Table: Field Work Orders
Trigger: New record added
  → Automatic Field Nation dispatch
```

### Status Synchronization

```
FN Work Order = "Completed"
  → Quickbase record Status = "Complete"
  → Completion date updated
```

---

## Features

### Field Mapping Capabilities

- **All Field Types**: Text, numeric, date, checkbox, user, relationship
- **Formula Fields**: Access calculated values
- **Related Tables**: Map fields from related tables via relationships
- **Multi-select fields**: Handle comma-separated values
- **File Attachments**: Optional file sync

### Supported Operations

---

## Prerequisites

### Quickbase Requirements

  
    Generate in Quickbase:
    1. Profile → Manage User Tokens
    2. "+ New User Token"
    3. Name: "Field Nation Integration"
    4. Assign all apps needed
    5. Copy token (shown once)
  
  
  
    - Admin access to Quickbase app
    - Table must have webhook automation capabilities
    - User token must have access to table
  
  
  
    - Read access to all fields to sync
    - Write access for status updates
    - Access to related tables
  

---

## Authentication

Quickbase uses **User Token** (Bearer token):

```
Authorization: QB-USER-TOKEN {user_token}
```

**Generate Token:**
1. Quickbase → Profile → Manage User Tokens
2. New User Token
3. Select applications to grant access
4. Copy token immediately (shown once)

> **Security**: User tokens have same permissions as user. Create dedicated integration user with minimum required access.

---

## Best Practices

- ✅ Use dedicated integration user
- ✅ Grant minimum table access needed
- ✅ Test in sandbox app first
- ✅ Use Quickbase automations (not external webhooks)
- ✅ Monitor API usage limits

---

## Limitations

- API rate limits: 10 requests/second per user token
- Each sync consumes 2-3 API calls
- Complex relationships may require custom JSONNET
- Formula fields are read-only

---

---

### undefined
URL: /docs/connectors/platforms/quickbase/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/quickbase/workflow
Source: content/docs/connectors/platforms/quickbase/workflow.mdx

---
title: Workflow Setup
description: Configure Quickbase automations to trigger Field Nation work order creation when records change.
---

## Prerequisites

- ☐ [Field Nation configuration complete](/docs/connectors/platforms/quickbase/configuration)
- ☐ Trigger URL copied
- ☐ Quickbase app admin access

---

## Configure Automation in Quickbase

### Navigate to Automations

Open your Quickbase app → Settings (gear icon) → Automations

### Create New Automation

Click "+ Create a new automation"

### Configure Trigger

**Name**: `Send to Field Nation`

**Trigger**: "When a record is created or updated"

**Table**: Select your table (e.g., Service Requests)

**Conditions**:
```
Status is "Approved"
OR
Send to FN checkbox is checked
```

### Add Webhook Action

**Action Type**: "Make a request to a webhook"

**Method**: POST

**URL**: Paste Field Nation trigger URL

**Headers**:
```
Content-Type: application/json
```

**Body**:
```json
{
  "record_id": "[Record ID#]",
  "table_id": "[Table ID]",
  "app_id": "[App ID]"
}
```

Use Quickbase merge fields (buttons in automation builder) to insert dynamic values.

### Save & Activate

Save automation → Toggle to "Active"

---

## Test Integration

### Create Test Record

1. Open your Quickbase table
2. Add new record
3. Set status to "Approved" (or check trigger field)
4. Save

### Verify Automation

Quickbase → Settings → Automations → View your automation  
Check "Recent runs" for execution

### Check Field Nation

Verify work order created with correct data

---

## Advanced Configuration

### Conditional Logic

Add complex conditions:

```
Status = "Approved"
AND Priority ≥ High
AND NOT(Customer Name is blank)
AND Scheduled Date is not in the past
```

---

### Prevent Duplicate Sends

Add checkbox field: "Synced to FN"

**Automation Conditions:**
```
Status = "Approved"
AND "Synced to FN" is NOT checked
```

**Add Second Action:**
Update record → Set "Synced to FN" = checked

---

### Multiple Automations

**Automation 1**: Urgent Requests
```
Priority = "Urgent"
→ Immediate dispatch
```

**Automation 2**: Standard Requests
```
Status = "Approved"
AND Priority != "Urgent"
→ Normal dispatch
```

---

## Troubleshooting

  
    - Check automation is "Active"
    - Verify record meets conditions
    - Review "Recent runs" for errors
    - Test with simple condition first
  
  
  
    - Verify trigger URL correct
    - Check webhook response in automation log
    - Test URL with external tool
    - Review Field Nation logs
  
  
  
    - Verify Field Nation credentials valid
    - Check all required fields mapped
    - Review Integration Broker logs
    - Test with minimal record data
  

---

## Monitoring

### Automation Logs

Quickbase → Automations → Your automation → "Recent runs"

Review:
- Execution timestamps
- Conditions met/not met
- Webhook responses
- Error messages

---

---

### undefined
URL: /docs/connectors/platforms/rest-connector/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/rest-connector/configuration
Source: content/docs/connectors/platforms/rest-connector/configuration.mdx

---
title: Configuration
description: Configure the REST Connector by uploading your OpenAPI spec, selecting endpoints, and setting up authentication.
---

## Prerequisites

Before starting, gather:

- ☐ OpenAPI specification file (JSON or YAML)
- ☐ API credentials (username and password for Basic Auth)
- ☐ API base URL
- ☐ Endpoint paths for:
  - Record metadata (schema/fields)
  - Record fetch (get by ID)
  - Record create
  - Record update
  - Attachments upload (optional)
- ☐ Admin access to Field Nation integrations

---

## Step 1: Access REST Connector

Navigate to Field Nation's Integration Broker:

**Sandbox**: [ui-sandbox.fndev.net/integrations](https://ui-sandbox.fndev.net/integrations)  
**Production**: [app.fieldnation.com/integrations](https://app.fieldnation.com/integrations)

### Log In

Use your Field Nation buyer account credentials

### Select REST Connector

Find "REST Connector" in the list of available connectors

### Click Configure

Open the REST Connector configuration form

---

## Step 2: Upload OpenAPI Specification

The OpenAPI spec enables automatic endpoint discovery and field mapping.

### Prepare Your Spec File

**Supported Formats:**
- OpenAPI 3.x (JSON or YAML)
- OpenAPI 2.x / Swagger 2.0 (JSON or YAML)

**Where to Get It:**
- API documentation portal
- `/swagger.json` or `/api-docs` endpoint
- API provider's developer resources
- Tools: Postman, Swagger UI, Stoplight

**Validate Before Upload:**
```bash
# Using Swagger Editor (online or local)
https://editor.swagger.io/

# Or CLI tools
swagger-cli validate openapi.json
```

---

### Upload Process

### Click "Upload OpenAPI Spec"

In the REST Connector configuration form

### Select File

Choose your OpenAPI spec file (`.json` or `.yaml`/`.yml`)

### Validate

Integration Broker parses and validates the specification

### Confirm Success

Green confirmation message: "OpenAPI specification uploaded successfully"

**What Happens:**
- Broker parses spec to discover endpoints
- Extracts request/response schemas
- Populates endpoint dropdown menus
- Enables field discovery

---

## Step 3: Configure Endpoints

Select which API endpoints to use for each operation.

### Record Metadata Endpoint

**Purpose**: Get field definitions and schema information

**Required**: Yes - enables field mapping UI

**Example Endpoints:**
- `GET /api/v1/tickets/metadata`
- `GET /api/v1/schema/ticket`
- `OPTIONS /api/v1/tickets` (if returns schema)

**Configuration:**
1. Click "Record Metadata" dropdown
2. Select endpoint from list (populated from OpenAPI spec)
3. Select HTTP method (usually `GET`)

**Dropdown Contents:**
- All endpoints from uploaded OpenAPI spec
- Filtered to relevant operations
- Shows path + method (e.g., `GET /api/v1/metadata`)

---

### Record Fetch Endpoint

**Purpose**: Retrieve single record by ID

**Required**: Yes - fetches data for inbound sync

**Example Endpoints:**
- `GET /api/v1/tickets/{id}`
- `GET /api/v1/records/{ticket_id}`
- `GET /api/v1/workorders/{wo_id}`

**Configuration:**
1. Click "Record Fetch" dropdown
2. Select endpoint with ID parameter
3. Method: `GET`

**ID Parameter:**
- Endpoint must accept ID parameter (path or query)
- Example: `/tickets/{id}` or `/tickets?id={id}`
- Broker substitutes actual ID at runtime

---

### Record Create Endpoint

**Purpose**: Create new records in external system

**Required**: Yes - core functionality

**Example Endpoints:**
- `POST /api/v1/tickets`
- `POST /api/v1/workorders/create`
- `PUT /api/v1/records` (if PUT creates)

**Configuration:**
1. Click "Record Create" dropdown
2. Select creation endpoint
3. Method: usually `POST` (sometimes `PUT`)

**Request Body:**
- Broker constructs body from field mappings
- Format determined by OpenAPI spec (JSON, XML, etc.)
- Uses schema defined in spec for validation

---

### Record Update Endpoint

**Purpose**: Update existing records

**Required**: Recommended (enables bidirectional sync)

**Example Endpoints:**
- `PUT /api/v1/tickets/{id}`
- `PATCH /api/v1/tickets/{id}`
- `POST /api/v1/tickets/{id}/update`

**Configuration:**
1. Click "Record Update" dropdown
2. Select update endpoint
3. Method: `PUT`, `PATCH`, or `POST`

**PUT vs PATCH:**
- `PUT`: Full record replacement
- `PATCH`: Partial update (only changed fields)
- Check your API's behavior - configure accordingly

---

### Attachments Upload Endpoint

**Purpose**: Upload files/documents to records

**Required**: Optional - only if file sync needed

**Example Endpoints:**
- `POST /api/v1/tickets/{id}/attachments`
- `POST /api/v1/files/upload`
- `PUT /api/v1/records/{id}/documents`

**Configuration:**
1. Click "Attachments Upload" dropdown
2. Select file upload endpoint
3. Method: usually `POST`

**File Handling:**
- Multipart/form-data or base64 encoding
- Determined by OpenAPI spec
- Broker handles encoding automatically

---

## Step 4: Set Authentication

REST Connector supports **Basic Authentication** only.

### Enter Credentials

**Format**: `username:password`

**Examples:**
```
api_user:secure_password_123
integration@company.com:MyP@ssw0rd!
client_12345:abc123xyz789
```

**Configuration:**
1. Locate "Authentication" section
2. Enter credentials in format: `username:password`
3. Broker encodes automatically to `Authorization: Basic base64(username:password)`

---

### Security Best Practices

  
    Don't use personal account credentials.
    
    **Benefits:**
    - Better audit trails
    - Easier credential rotation
    - Integration doesn't break if personal account deactivated
    - Granular permission control
  
  
  
    Grant only required API access:
    - Read: Metadata, record fetch
    - Write: Record create, update
    - Upload: Attachments (if needed)
    
    **Don't grant:**
    - Admin privileges
    - Delete permissions (unless required)
    - Access to unrelated resources
  
  
  
    **Schedule:**
    - Every 90 days (recommended)
    - Immediately if compromise suspected
    - When team member with access leaves
    
    **Process:**
    1. Generate new credentials in external system
    2. Update Field Nation configuration
    3. Test connection
    4. Deactivate old credentials
  
  
  
    Field Nation handles storage securely:
    - Encrypted at rest (AES-256)
    - Never logged or exposed in errors
    - Transmitted over TLS 1.2+
    
    **Your responsibility:**
    - Don't share credentials
    - Use strong, unique passwords
    - Document access in secure location
  

---

## Step 5: Test Connection

Verify REST Connector can communicate with your API.

### Click "Test Connection"

Button near authentication section

### Broker Validates

- Sends request to Record Metadata endpoint
- Authenticates using provided credentials
- Parses response

### Review Result

**Success**: ✅ Green confirmation
- Connection successful
- Endpoints reachable
- Authentication valid

**Failure**: ❌ Error message
- Authentication failed: Check credentials
- Endpoint not found: Verify URLs
- Network error: Check firewall/VPN
- SSL error: Verify certificate validity

---

### Common Connection Errors

  
    **Cause**: Invalid credentials
    
    **Solution:**
    1. Verify username:password format correct
    2. Check credentials valid in external system
    3. Ensure API user has API access enabled
    4. Test credentials with `curl`:
    
    ```bash
    curl -u "username:password" \
         https://your-api.com/api/v1/metadata
    ```
  
  
  
    **Cause**: Endpoint doesn't exist or wrong URL
    
    **Solution:**
    1. Verify endpoint paths in OpenAPI spec
    2. Check API base URL correct
    3. Ensure endpoint actually exists in external system
    4. Test endpoint directly with API client (Postman)
  
  
  
    **Cause**: Cannot reach external API
    
    **Solution:**
    1. Verify API is publicly accessible (or VPN configured)
    2. Check firewall rules
    3. Whitelist Field Nation IP addresses
    4. Verify SSL certificate valid (not expired)
    
    [Field Nation IPs →](/docs/resources/environments)
  
  
  
    **Cause**: Invalid or self-signed SSL certificate
    
    **Solution:**
    1. Use valid, CA-signed certificate
    2. Update certificate if expired
    3. Ensure certificate matches domain
    4. For testing: Use non-production environment with valid cert
  

---

## Step 6: Refresh Fields

Discover available fields for mapping.

### Click "Refresh Fields"

Button in field mapping section

### Broker Queries API

- Calls Record Metadata endpoint
- Retrieves field definitions
- Parses schema from response

### Fields Populate

Available fields appear in dropdown menus:
- Standard fields
- Custom fields
- Required vs optional
- Data types

**Field Discovery Includes:**
- Field names and API keys
- Data types (string, integer, boolean, etc.)
- Required/optional status
- Enum values for picklists
- Nested object structures

---

## Step 7: Configure Field Mappings

Map data between Field Nation and your external system.

### Inbound Mappings (External → Field Nation)

Map external system fields to Field Nation work order fields:

**Example:**
```
External Field → Field Nation Field
──────────────────────────────────
ticket_title → title
ticket_description → description
priority_level → priority (with Array Map)
customer_name → location.company.name
scheduled_date → schedule.start (with Date Convert)
```

### Outbound Mappings (Field Nation → External)

Map Field Nation fields to external system updates:

**Example:**
```
Field Nation Field → External Field
────────────────────────────────────
status.name → ticket_status (with Array Map)
assignee.user.email → technician_email
completion_notes → resolution_notes
approved_amount → final_cost
```

[Complete field mapping guide →](/docs/connectors/concepts/field-mappings)

---

### Field Mapping Actions

Use standard transformation actions:

**Sync**: Direct copy
```jsonnet
{
  "source": "external_field",
  "target": "fn_field",
  "action": "sync"
}
```

**Array Map**: Status mapping
```jsonnet
{
  "source": "status",
  "target": "fn_status",
  "action": "array_map",
  "mappings": [
    { "compare": "open", "value": "1" },
    { "compare": "in_progress", "value": "2" },
    { "compare": "completed", "value": "5" }
  ]
}
```

**Date Convert**: Date formatting
```jsonnet
{
  "source": "scheduled_date",
  "target": "schedule.start",
  "action": "date_convert",
  "input_format": "YYYY-MM-DD",
  "output_format": "YYYY-MM-DD HH:mm:ss"
}
```

[All transformation actions →](/docs/connectors/concepts/field-mappings)

---

## Step 8: Save & Test

### Review Configuration

Verify all settings:
- ☐ OpenAPI spec uploaded
- ☐ All required endpoints selected
- ☐ Authentication configured
- ☐ Connection test passed
- ☐ Fields refreshed
- ☐ Inbound mappings configured
- ☐ Outbound mappings configured (if needed)

### Save Configuration

Click "Save" to persist settings

### Test with Sample Data

Create a test work order in Field Nation:
1. Trigger should sync to external system
2. Check Integration Broker logs
3. Verify record created in external system
4. Confirm field values correct

### Monitor Initial Syncs

Watch first few synchronizations:
- Check for errors
- Verify field mappings working
- Adjust as needed

---

## Troubleshooting

  
    **Issue**: Dropdown menus empty or missing expected fields
    
    **Solution:**
    1. Click "Refresh Fields" again
    2. Check Record Metadata endpoint returns field schema
    3. Verify OpenAPI spec includes response schemas
    4. Test metadata endpoint directly with API client
    5. Review Integration Broker logs for parsing errors
  
  
  
    **Issue**: No endpoints showing in dropdown menus
    
    **Solution:**
    1. Re-upload OpenAPI spec (may have failed to parse)
    2. Validate spec with Swagger Editor
    3. Ensure spec includes all required endpoints
    4. Check spec version supported (OpenAPI 2.x/3.x)
  
  
  
    **Issue**: Cannot save mappings
    
    **Solution:**
    1. Ensure all required FN fields mapped
    2. Check data type compatibility
    3. Add default values for optional fields
    4. Review error message for specific field
  

---

---

### undefined
URL: /docs/connectors/platforms/rest-connector/overview

# Connectors: undefined
URL: /docs/connectors/platforms/rest-connector/overview
Source: content/docs/connectors/platforms/rest-connector/overview.mdx

---
title: REST Connector
description: Universal OpenAPI-based connector to integrate Field Nation with any system that provides an OpenAPI specification.
---

## Overview

The REST Connector enables integration with **any REST API** that has an OpenAPI specification:
- **Upload OpenAPI spec**: System automatically discovers endpoints and data models
- **Configure endpoints**: Select CRUD operations from dropdown menus
- **Map fields**: Use standard field mapping UI populated from spec
- **Basic Authentication**: Simple username:password credentials
- **No code required**: Configuration-driven setup

---

## Key Features

  
    Works with ANY system that has an OpenAPI spec
  
  
    Automatically reads endpoints and models from spec
  
  
    Select endpoints from dropdowns, no coding needed
  
  
    Use familiar field mapping UI and transformations
  

---

## How It Works

### Upload OpenAPI Spec

Upload your system's OpenAPI (Swagger) specification file (JSON or YAML)

### Configure Endpoints

Select endpoints for each operation from dropdown menus:
- **Record Metadata**: Get field definitions
- **Record Fetch**: Retrieve single record
- **Record Create**: Create new records
- **Record Update**: Update existing records
- **Attachments Upload**: Upload files (optional)

### Set Authentication

Provide Basic Auth credentials (username:password format)

### Refresh Fields

Click "Refresh Fields" to fetch field definitions from your API

### Map Fields

Configure standard field mappings using discovered fields

### Test & Deploy

Test with sample data, then activate for production use

---

## Architecture

```mermaid
sequenceDiagram
    participant User as User/Admin
    participant Broker as Integration Broker
    participant Spec as OpenAPI Spec
    participant External as External API
    participant FN as Field Nation
    
    User->>Broker: Upload OpenAPI Spec
    Broker->>Spec: Parse Spec
    Spec-->>Broker: Endpoints & Models
    Broker->>User: Populate Dropdown Menus
    
    User->>Broker: Select Endpoints
    User->>Broker: Configure Auth
    User->>Broker: Click "Refresh Fields"
    
    Broker->>External: GET /metadata (or configured endpoint)
    External-->>Broker: Field Definitions
    Broker->>User: Populate Field Mapping UI
    
    Note over User,FN: Integration Active
    
    FN->>Broker: Work Order Event
    Broker->>Broker: Apply Field Mappings
    Broker->>External: POST /create (configured endpoint)
    External-->>Broker: Success + Record ID
```

---

## When to Use REST Connector

### ✅ Use REST Connector When

  
    Your platform doesn't have a pre-built connector but has an OpenAPI spec.
    
    **Examples:**
    - Custom internal systems
    - Niche vertical applications
    - Proprietary FSM platforms
    - Industry-specific tools
  
  
  
    Your system provides an OpenAPI/Swagger specification file.
    
    **Formats Supported:**
    - OpenAPI 3.x (JSON or YAML)
    - OpenAPI 2.x / Swagger 2.0
    - Most API documentation tools generate these automatically
  
  
  
    You need standard create/read/update operations without complex workflows.
    
    **Supported:**
    - Create work orders → Create records in your system
    - Update work orders → Update records in your system
    - Fetch record data → Query your system's API
    - Upload attachments → Send files to your system
    
    **Not Supported (use REST API + Webhooks instead):**
    - Complex multi-step workflows
    - Advanced business logic
    - Custom validation rules
    - Real-time bidirectional sync requirements beyond standard operations
  
  
  
    You prefer UI configuration over custom code development.
    
    **Benefits:**
    - No development required
    - Faster deployment than custom integration
    - Maintained by Field Nation
    - Standard field mapping UI
  

---

### ⚠️ Limitations

The REST Connector is built for **standard CRUD operations**. It may not support:

> [INFO] **Extensibility**: The REST Connector was built for specific use cases and can be extended with additional functionality as needed. Contact [Field Nation Support](https://app.fieldnation.com/support-cases) to discuss feature requirements.

---

## Common Use Cases

### Custom FSM Platform Integration

Your company uses a proprietary Field Service Management system with REST API and OpenAPI spec.

**Configuration:**
- Upload system's OpenAPI spec
- Select `/api/v1/tickets` (create) endpoint
- Select `/api/v1/tickets/{id}` (fetch/update) endpoints
- Map Field Nation work order fields to ticket fields
- Enable bidirectional sync for status updates

---

### ERP System Integration

Integrate with mid-market ERP without pre-built connector.

**Configuration:**
- Upload ERP's API specification
- Select `/work_orders/create` endpoint
- Select `/work_orders/{id}/update` endpoint
- Map financial fields (cost, budget, billing codes)
- Sync completion status back to ERP

---

### Vertical-Specific Application

Industry-specific platform (healthcare, retail, manufacturing) with custom data models.

**Configuration:**
- Upload application's OpenAPI spec
- Map custom fields to application's unique data structures
- Use JSONNET for industry-specific transformations
- Sync status and completion data bidirectionally

---

## Prerequisites

### External System Requirements

  
    **Required**: Valid OpenAPI/Swagger specification file
    
    **Format:**
    - OpenAPI 3.x (JSON or YAML)
    - OpenAPI 2.x / Swagger 2.0 (JSON or YAML)
    
    **Must Include:**
    - Endpoint paths and HTTP methods
    - Request/response schemas
    - Authentication schemes
    - Parameter definitions
    
    **How to Get:**
    - Most modern APIs provide this automatically
    - Check API documentation portal
    - Tools: Swagger UI, Postman, Stoplight
    - May be available at `/swagger.json` or `/api-docs`
  
  
  
    **Minimum Required Endpoints:**
    
    **Record Create** (Required)
    - Creates new records in your system
    - Example: `POST /api/v1/tickets`
    
    **Record Fetch** (Required)
    - Retrieves single record by ID
    - Example: `GET /api/v1/tickets/{id}`
    
    **Record Metadata** (Required)
    - Returns field definitions/schema
    - Example: `GET /api/v1/tickets/metadata` or included in spec
    
    **Record Update** (Recommended)
    - Updates existing records
    - Example: `PUT /api/v1/tickets/{id}` or `PATCH /api/v1/tickets/{id}`
    
    **Attachments Upload** (Optional)
    - Uploads files/attachments
    - Example: `POST /api/v1/tickets/{id}/attachments`
  
  
  
    **Required**: REST API must support Basic Auth
    
    **Format**: `Authorization: Basic base64(username:password)`
    
    **Other Auth Methods Not Supported:**
    - ❌ OAuth 2.0 (use REST API integration)
    - ❌ API Keys in headers (use REST API integration)
    - ❌ Custom authentication schemes
    - ❌ JWT/Bearer tokens (unless wrapped in Basic Auth)
    
    If your API doesn't support Basic Auth, consider:
    - Adding Basic Auth layer via API gateway
    - Using REST API + Webhooks integration instead
  
  
  
    **Outbound from External System** (Inbound sync)
    - System can send webhooks to Field Nation
    - Not blocked by firewall
    - HTTPS/TLS support
    
    **Inbound to External System** (Outbound sync)
    - Field Nation can reach your API endpoints
    - Public internet or VPN access
    - IP whitelisting configured (if required)
    
    [Field Nation IP addresses →](/docs/resources/environments)
  

### Field Nation Requirements

- Active buyer account with admin access
- Integration settings access
- Sandbox environment (recommended for testing)

---

## Authentication

REST Connector uses **Basic Authentication** only:

```
Authorization: Basic base64(username:password)
```

**Configuration:**
- Enter credentials in `username:password` format
- Example: `api_user:my_secure_password123`
- Field Nation encodes credentials automatically
- Credentials encrypted at rest (AES-256)

**Best Practices:**
- Use dedicated API user (not personal account)
- Grant minimum required permissions
- Rotate credentials periodically
- Use strong, unique passwords

---

## Supported Functionality

### ✅ What REST Connector Can Do

- **Create Records**: Create records in external system when FN work order created/updated
- **Update Records**: Update external records when FN work order status changes
- **Fetch Data**: Retrieve field values from external system for field mapping
- **Field Mapping**: Standard field mappings with all transformation actions
- **Custom Actions**: JSONNET transformations for complex data manipulation
- **Attachments**: Upload files to external system (if endpoint configured)
- **Bidirectional Sync**: Status updates flow both directions
- **Correlation IDs**: Track linked records across systems

### ⚠️ What REST Connector May Not Support

- OAuth or API key authentication
- Complex multi-step workflows
- Real-time streaming data
- GraphQL queries (REST only)
- SOAP web services (REST only)
- Custom headers or authentication schemes
- Advanced error recovery beyond standard retries

For these requirements, consider [REST API + Webhooks integration](/docs/getting-started/choosing-your-approach).

---

## Comparison: REST Connector vs REST API

| Feature | REST Connector | REST API + Webhooks |
|---------|----------------|---------------------|
| **Setup Time** | Hours | Days to weeks |
| **Development** | None (config only) | Full custom development |
| **Authentication** | Basic Auth only | All methods supported |
| **OpenAPI Spec** | Required | Optional (helpful) |
| **Customization** | Standard field mappings + JSONNET | Unlimited |
| **Maintenance** | Field Nation | Your team |
| **Complex Workflows** | Limited | Full control |
| **Best For** | Standard CRUD operations | Custom/complex integrations |

---

---

### undefined
URL: /docs/connectors/platforms/rest-connector/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/rest-connector/workflow
Source: content/docs/connectors/platforms/rest-connector/workflow.mdx

---
title: Workflow Setup
description: End-to-end guide for setting up REST Connector integration from OpenAPI spec to production deployment.
---

## Workflow Overview

```mermaid
graph TD
    A[Prepare OpenAPI Spec] --> B[Upload to Field Nation]
    B --> C[Configure Endpoints]
    C --> D[Set Authentication]
    D --> E[Test Connection]
    E --> F[Refresh Fields]
    F --> G[Configure Mappings]
    G --> H[Test Integration]
    H --> I{Success?}
    I -->|Yes| J[Deploy to Production]
    I -->|No| K[Debug & Fix]
    K --> H
```

---

## Phase 1: Preparation

### Gather API Documentation

### Obtain OpenAPI Spec

**Sources:**
- API documentation portal (often `/docs`)
- Developer resources section
- API provider's GitHub repository
- Generate from Postman collection
- Export from API gateway

**Direct URLs to Check:**
```
https://your-api.com/swagger.json
https://your-api.com/api-docs
https://your-api.com/openapi.yaml
https://your-api.com/v1/openapi.json
```

### Validate Specification

Use online or CLI tools:

```bash
# Swagger Editor (online)
https://editor.swagger.io/

# CLI Validation
npm install -g swagger-cli
swagger-cli validate openapi.json

# Or using Docker
docker run --rm -v $(pwd):/spec openapitools/openapi-generator-cli validate -i /spec/openapi.json
```

**Check For:**
- ☐ Valid JSON/YAML syntax
- ☐ All required endpoints defined
- ☐ Request/response schemas present
- ☐ Parameter definitions complete
- ☐ Authentication schemes documented

### Identify Required Endpoints

Map your business flow to API endpoints:

| Field Nation Event | External API Endpoint | Purpose |
|--------------------|----------------------|---------|
| Work order created | `POST /tickets` | Create record |
| Work order updated | `PATCH /tickets/{id}` | Update record |
| Need field schema | `GET /tickets/metadata` | Get fields |
| Query record data | `GET /tickets/{id}` | Fetch record |
| Attachment added | `POST /tickets/{id}/files` | Upload file |

---

### Prepare Test Credentials

### Create API User

In your external system:
1. Create dedicated integration user
2. Generate API credentials
3. Grant minimum required permissions

### Document Credentials

Store securely:
```
Username: api_integration_user
Password: [secure password]
Format for Field Nation: username:password
Base URL: https://api.example.com/v1
```

### Test Credentials

Verify with `curl`:

```bash
# Test authentication
curl -u "username:password" \
     https://api.example.com/v1/metadata

# Test endpoint access
curl -u "username:password" \
     https://api.example.com/v1/tickets

# Test record creation (optional)
curl -u "username:password" \
     -X POST \
     -H "Content-Type: application/json" \
     -d '{"title":"Test","description":"Integration test"}' \
     https://api.example.com/v1/tickets
```

---

## Phase 2: Field Nation Configuration

### Upload & Configure

### Access REST Connector

Navigate to Integration Broker:
- **Sandbox**: [ui-sandbox.fndev.net/integrations](https://ui-sandbox.fndev.net/integrations)
- **Production**: [app.fieldnation.com/integrations](https://app.fieldnation.com/integrations)

Select "REST Connector"

### Upload OpenAPI Spec

1. Click "Upload OpenAPI Spec"
2. Select your spec file (`.json` or `.yaml`)
3. Wait for validation
4. Confirm success message

### Select Endpoints

**Record Metadata:**
- Select endpoint that returns field schema
- Example: `GET /api/v1/metadata`

**Record Fetch:**
- Select endpoint to get single record by ID
- Example: `GET /api/v1/tickets/{id}`

**Record Create:**
- Select endpoint to create new records
- Example: `POST /api/v1/tickets`

**Record Update:**
- Select endpoint to update records
- Example: `PATCH /api/v1/tickets/{id}`

**Attachments Upload (optional):**
- Select file upload endpoint
- Example: `POST /api/v1/tickets/{id}/files`

### Enter Authentication

Format: `username:password`

Example: `integration_user:securePass123!`

### Test Connection

Click "Test Connection" button
- ✅ Success: Green confirmation
- ❌ Failure: Review error, fix, retry

---

## Phase 3: Field Mapping

### Discover & Map Fields

### Refresh Fields

1. Click "Refresh Fields" button
2. Broker calls metadata endpoint
3. Fields populate in dropdown menus

### Map Inbound Fields

**External System → Field Nation**

Configure how external records become FN work orders:

**Required Fields:**
```
External Field          → FN Field               Action
──────────────────────────────────────────────────────────
ticket_title           → title                  Sync
ticket_description     → description            Sync
customer_name          → location.company.name  Sync
scheduled_date         → schedule.start         Date Convert
priority_code          → priority               Array Map
```

**Optional Fields:**
```
contact_email          → contact.email          Sync
service_address        → location.address1      Sync
special_instructions   → instructions           Sync
estimated_duration     → time_estimate          Sync
```

### Map Outbound Fields

**Field Nation → External System**

Configure how FN events update external records:

**Status Updates:**
```
FN Field               → External Field         Action
──────────────────────────────────────────────────────────
status.name            → ticket_status          Array Map
assignee.user.name     → technician_name        Sync
completion_notes       → resolution             Sync
completion_date        → completed_at           Date Convert
```

### Configure Transformations

**Status Mapping (Array Map):**
```jsonnet
{
  "source": "status_code",
  "target": "priority",
  "action": "array_map",
  "mappings": [
    { "compare": "1", "value": "Low" },
    { "compare": "2", "value": "Medium" },
    { "compare": "3", "value": "High" },
    { "compare": "4", "value": "Critical" }
  ],
  "default": "Medium"
}
```

**Date Conversion:**
```jsonnet
{
  "source": "created_date",
  "target": "schedule.start",
  "action": "date_convert",
  "input_format": "YYYY-MM-DD",
  "output_format": "YYYY-MM-DD HH:mm:ss",
  "timezone_in": "UTC",
  "timezone_out": "America/New_York"
}
```

**Custom Logic (JSONNET):**
```jsonnet
{
  "target": "custom_priority",
  "action": "custom",
  "script": |||
    local status = $.util.lookup_field($.input, 'status', '');
    local amount = $.util.lookup_field($.input, 'amount', 0);
    
    if status == 'urgent' && amount > 500 then
      "P1-Critical"
    else if status == 'urgent' then
      "P2-High"
    else if amount > 1000 then
      "P2-High"
    else
      "P3-Normal"
  |||
}
```

### Save Mappings

Click "Save" to persist field mapping configuration

---

## Phase 4: Testing

### Test Scenarios

### Create Test Record in Field Nation

**Scenario 1: Basic Work Order Creation**

1. Create simple work order in Field Nation
2. Fill in all required fields
3. Include fields mapped to external system
4. Save work order

**Expected Result:**
- Integration Broker processes event
- Calls external API create endpoint
- Record created in external system
- Correlation ID stored

### Verify External System

1. Log into external system
2. Find newly created record
3. Verify field values match:
   - Title/subject
   - Description
   - Priority/status
   - Customer/company info
   - Scheduled date

### Test Status Update (Outbound)

**Scenario 2: Bidirectional Sync**

1. Update work order status in Field Nation
2. Add completion notes
3. Save changes

**Expected Result:**
- Broker processes status change event
- Calls external API update endpoint
- External record status updated
- Notes synced to external system

### Test Inbound Sync (if configured)

**Scenario 3: External → Field Nation**

1. Update record in external system
2. Trigger webhook (if configured)
3. Check Field Nation for updated data

**Expected Result:**
- Webhook received by Broker
- Field Nation work order updated
- Field changes reflected

### Test Edge Cases

**Scenario 4: Error Handling**

- Missing required fields
- Invalid data types
- Network failures
- Authentication errors

**Check:**
- Errors logged properly
- Retry logic works
- Dead letter queue captures failures

---

### Review Integration Logs

### Access Logs

Field Nation → Integrations → Logs

### Filter by Date/Time

Set range covering your test period

### Review Entries

**Success Logs:**
- Event received
- API called successfully
- Record created/updated
- Response logged

**Error Logs:**
- Error type and message
- Request details
- Response details
- Retry attempts

### Common Issues

**401 Unauthorized:**
```
Error: Authentication failed
Solution: Verify credentials correct
```

**400 Bad Request:**
```
Error: Invalid field value for 'priority'
Solution: Check Array Map values match API expectations
```

**404 Not Found:**
```
Error: Endpoint /api/v1/ticket not found
Solution: Verify endpoint URL, check for typos
```

---

## Phase 5: Production Deployment

### Pre-Launch Checklist

- ☐ All sandbox tests passed
- ☐ Field mappings validated
- ☐ Error handling tested
- ☐ Team training complete
- ☐ Documentation updated
- ☐ Rollback plan prepared

---

### Deploy to Production

### Recreate Configuration in Production

If tested in sandbox:

1. Access production Integration Broker
2. Select REST Connector
3. Upload same OpenAPI spec
4. Configure same endpoints
5. Update credentials (production API user)
6. Test connection
7. Refresh fields
8. **Copy field mappings** from sandbox config
9. Save configuration

### Update External System Configuration

If using webhooks:
1. Update webhook URL to production Field Nation
2. Verify IP whitelisting (production IPs)
3. Test webhook delivery

### Soft Launch

**Start Small:**
1. Enable for single team/department
2. Monitor closely for first week
3. Collect feedback
4. Adjust configuration as needed

### Full Rollout

After successful soft launch:
1. Enable for all teams
2. Communicate to stakeholders
3. Provide user training
4. Set up monitoring/alerts

---

## Monitoring & Maintenance

### Daily Monitoring

- ☐ Check Integration Broker logs for errors
- ☐ Review sync success rate
- ☐ Monitor queue depth
- ☐ Verify no authentication failures

### Weekly Tasks

- ☐ Review error patterns
- ☐ Test sample synchronization
- ☐ Check external API status
- ☐ Verify field mappings still valid

### Monthly Maintenance

- ☐ Review and optimize field mappings
- ☐ Update OpenAPI spec if API changed
- ☐ Audit API user permissions
- ☐ Test disaster recovery process

### Quarterly Reviews

- ☐ Rotate API credentials
- ☐ Review integration architecture
- ☐ Assess performance metrics
- ☐ Plan enhancements

---

## Troubleshooting Common Issues

  
    **Check:**
    1. Integration active and not paused
    2. Field Nation events triggering
    3. External API reachable
    4. Credentials valid
    5. No rate limiting
    
    **Debug:**
    - Review Integration Broker logs
    - Test API endpoints with `curl`
    - Verify field mappings complete
    - Check for validation errors
  
  
  
    **Check:**
    1. Field mappings configured correctly
    2. Data type transformations applied
    3. Array Map values match API expectations
    4. Date formats compatible
    
    **Fix:**
    - Review and update field mappings
    - Add transformations (Array Map, Date Convert)
    - Use custom JSONNET for complex logic
    - Test with sample data
  
  
  
    **Check:**
    1. Credentials format: `username:password`
    2. Password hasn't changed
    3. API user still active
    4. Permissions not revoked
    
    **Solution:**
    - Generate new credentials
    - Update Field Nation configuration
    - Test connection
    - Document new credentials securely
  

---

---

### undefined
URL: /docs/connectors/platforms/salesforce/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/salesforce/configuration
Source: content/docs/connectors/platforms/salesforce/configuration.mdx

---
title: Configuration
description: Configure the Salesforce connector in Field Nation's Integration Broker to establish API connection and field mappings.
---

## Prerequisites Checklist

Before starting, gather this information:

- ☐ Salesforce username (email address)
- ☐ Salesforce password
- ☐ Salesforce security token ([how to generate](#security-token))
- ☐ Salesforce object API name (e.g., `Case`, `Service_Ticket__c`)
- ☐ Instance type (production vs sandbox)
- ☐ Admin access to Field Nation integrations

---

## Step 1: Access Integration Broker

Navigate to Field Nation's Integration Broker interface:

**Sandbox**: [ui-sandbox.fndev.net/integrations](https://ui-sandbox.fndev.net/integrations)  
**Production**: [app.fieldnation.com/integrations](https://app.fieldnation.com/integrations)

### Log In

Use your Field Nation buyer account credentials

### Select Salesforce

Find "Salesforce" in the list of available connectors

### Click Configure

Open the Salesforce configuration form

---

## Step 2: Basic Settings

![Salesforce Settings](/docs/integrations/salesforce/salesforce_settings.png)

### Instance Name

**Optional but recommended** - Descriptive name to identify this integration.

**Examples:**
- "Production Salesforce"
- "Service Cloud - NA"
- "Customer Service Sandbox"

**Use Case**: Helpful when managing multiple Salesforce integrations or distinguishing between sandbox and production.

---

### Instance Type

**Required** - Specifies which Salesforce environment to connect to.

**Value**: `production`

**Connects to**: `login.salesforce.com`

**When to use:**
- Live Salesforce organization
- Go-live / production deployment
- Real customer data

**Value**: `test`

**Connects to**: `test.salesforce.com`

**When to use:**
- Salesforce sandbox environments
- Development and testing
- UAT (User Acceptance Testing)
- Training environments

> **Critical**: Incorrect instance type causes authentication failures. Verify your Salesforce environment type before configuring.

---

### Object Name

**Required** - The Salesforce object API name for integration.

**Standard Objects:**
- `Case` - Service cases
- `Opportunity` - Sales opportunities
- `Account` - Customer accounts
- `Contact` - Individual contacts

**Custom Objects:**
- `Service_Ticket__c` - Custom service ticket
- `Field_Service_Request__c` - Custom FSM object
- `Work_Request__c` - Custom work request

**Format Rules:**
- Use API name, not label
- Standard objects: Same as label (`Case`)
- Custom objects: End with `__c` (`My_Object__c`)

**Field Access:**
- All fields on the base object
- Fields from directly related parent objects
- Example: If object = `Case`, you can access `Case.Account.Name`, `Case.Contact.Email`, etc.

---

## Step 3: Messaging Configuration

**Optional** - Enable bidirectional comment synchronization.

  
    Enable if you want:
    - Field Nation technician messages to appear in Salesforce
    - Salesforce user comments to sync to Field Nation
    - Bidirectional communication between platforms
    
    **Common Use Cases:**
    - Dispatchers adding notes for technicians
    - Technicians providing status updates
    - Customer service tracking all communications
  
  
  
    **Message Object**: API name of Salesforce comment object
    
    **Common Values:**
    - `CaseComment` - For Case objects
    - `FeedComment` - For Chatter-enabled objects
    - Consult Salesforce docs for other standard objects
    
    **Limitations**: Field Nation can only connect to Salesforce's standard comment objects (custom comment objects not supported)
  
  
  
    **Object Body Field**: Field containing comment text
    
    **Common Values:**
    - `CommentBody` - For CaseComment
    - `Body` - For FeedComment
    
    This field stores the actual message text content.
  

**Example Configuration:**
```
Message Object: CaseComment
Object Body Field: CommentBody
```

---

## Step 4: Credentials

Salesforce authentication requires three components:

### Username

Your Salesforce user's email address.

**Format**: Full email (e.g., `integration@company.com`)

**Best Practice**: Use dedicated integration user, not personal account
- Better security and audit trails
- Integration won't break if personal account deactivated
- Easier permission management

---

### Password

Your Salesforce user's password.

**Security Notes:**
- Field Nation encrypts passwords at rest (AES-256)
- Never logged or exposed in error messages
- Rotate periodically for security

---

### Security Token

System-generated key from Salesforce for API authentication.

#### How to Generate Security Token

### Log into Salesforce

Use the account you're configuring for integration

### Navigate to Personal Settings

Click your profile icon → Settings (or Setup → My Personal Information)

### Reset Security Token

Find "Reset My Security Token" and click it

### Check Email

Salesforce emails the token to your registered email address

### Copy Token

Copy the token from the email (entire string)

### Enter in Field Nation

Paste token in the Token field (do NOT append to password)

**Token Behavior:**
- Token is appended to password during API authentication
- Field Nation handles this automatically
- Enter as separate field, not concatenated with password

**When Token Resets:**
- Password change resets token automatically
- Manual reset via "Reset My Security Token"
- You'll need to update Field Nation configuration

---

## Step 5: Test Connection

After entering all configuration details:

### Save Configuration

Click "Save" or "Test Connection" button

### Authentication Test

Integration Broker attempts to authenticate with Salesforce

### Review Result

- **Success**: Green confirmation, trigger URL generated
- **Failure**: Error message with details

### Common Authentication Errors

  
    **Error**: `INVALID_LOGIN: Invalid username, password, security token`
    
    **Causes:**
    - Wrong username/password
    - Outdated security token
    - Password recently changed (resets token)
    
    **Solution:**
    1. Verify credentials correct
    2. Generate new security token
    3. Update configuration
    4. Test again
  
  
  
    **Error**: Connection timeout or authentication failure
    
    **Causes:**
    - Instance type doesn't match Salesforce environment
    - Trying to auth against `login.salesforce.com` with sandbox credentials
    
    **Solution:**
    1. Verify Salesforce environment type
    2. Update Instance Type setting
    3. Test connection
  
  
  
    **Error**: `API_DISABLED_FOR_ORG`
    
    **Causes:**
    - Salesforce org doesn't have API access
    - User doesn't have "API Enabled" permission
    
    **Solution:**
    1. Verify Salesforce license includes API access
    2. Check user Profile has "API Enabled" permission
    3. Contact Salesforce admin if needed
  
  
  
    **Error**: `LOGIN_MUST_USE_SECURITY_TOKEN` or login failure
    
    **Causes:**
    - Salesforce org has IP restrictions
    - Field Nation IP not whitelisted
    
    **Solution:**
    1. Add Field Nation IPs to Salesforce trusted IP ranges
    2. Or disable IP restrictions for integration user
    3. See [Network Access](/docs/resources/environments)
  

---

## Step 6: Get Trigger URL

Once authentication succeeds, Field Nation generates your unique trigger URL.

![Trigger Information](/docs/integrations/trigger_information.png)

### Trigger URL Components

```
https://api.fieldnation.com/integrations/trigger/{CLIENT_TOKEN}
```

- **Base URL**: Field Nation API endpoint
- **Client Token**: Unique authentication token for your integration

### Using the Trigger URL

**Purpose**: Destination for Salesforce Outbound Messages

**You'll need this URL when:**
- Configuring Salesforce Outbound Message
- Setting up Flow actions
- Testing webhook connectivity

**Copy the URL** - You'll paste this into Salesforce in the next step.

> [INFO] **Security**: The client token in the URL authenticates incoming webhooks. Keep this URL secure (don't share publicly).

---

## Step 7: Field Mappings

Configure how data maps between Salesforce and Field Nation.

### Access Field Mapping UI

1. From Salesforce connector settings
2. Click "Field Mappings" tab
3. Click "Refresh Fields" to discover Salesforce fields

### Discover Available Fields

**Automatic Discovery:**
- Integration Broker queries Salesforce metadata API
- Retrieves all fields on base object
- Discovers related object fields
- Populates mapping dropdown menus

**Includes:**
- Standard fields (Subject, Description, Status)
- Custom fields (My_Custom_Field__c)
- Related fields (Account.Name, Contact.Email)
- Formula fields (calculated values)
- Picklist fields (enum values)

### Configure Mappings

**Inbound (Salesforce → Field Nation):**

Map Salesforce fields to Field Nation work order fields:
- `Case.Subject` → `title`
- `Case.Description` → `description`
- `Case.Account.Name` → `location.company.name`
- `Case.Priority` → `priority` (with array map)

**Outbound (Field Nation → Salesforce):**

Map Field Nation events to Salesforce updates:
- Work order status → Case Status
- Completion notes → Case Comments
- Technician name → Custom field

[Complete field mapping guide →](/docs/connectors/concepts/field-mappings)

---

## Step 8: Save & Test

### Final Configuration Steps

### Review Settings

Verify all configuration values correct:
- Instance type matches environment
- Object name correct
- Credentials valid
- Field mappings complete

### Save Configuration

Click "Save" to persist settings

### Test with Sample Record

Create a test record in Salesforce:
1. Create a simple Case/record
2. Update to meet Flow trigger conditions
3. Check Integration Broker logs
4. Verify work order created in Field Nation

### Monitor Initial Syncs

Watch first few synchronizations:
- Check for errors in logs
- Verify field values correct
- Confirm bidirectional sync works
- Adjust mappings if needed

---

## Configuration Checklist

Use this checklist to verify complete setup:

### Field Nation Configuration
- ☐ Instance name configured (optional)
- ☐ Instance type matches Salesforce environment
- ☐ Object name is correct API name
- ☐ Messaging configured (if needed)
- ☐ Credentials entered (username, password, token)
- ☐ Connection tested successfully
- ☐ Trigger URL copied
- ☐ Fields refreshed and discovered
- ☐ Inbound field mappings configured
- ☐ Outbound field mappings configured (if needed)
- ☐ Configuration saved

### Salesforce Configuration (Next Steps)
- ☐ Outbound Message created
- ☐ Record-Triggered Flow created
- ☐ Flow conditions defined
- ☐ Flow activatedFlow tested with sample record

[Salesforce workflow setup →](/docs/connectors/platforms/salesforce/workflow)

---

## Troubleshooting

  
    **Issue**: Expected fields not showing in mapping dropdowns
    
    **Solution:**
    1. Click "Refresh Fields" to re-query Salesforce
    2. Verify field exists on object (check API name)
    3. Ensure API user has read permission on field
    4. For related fields, confirm relationship exists
  
  
  
    **Issue**: Integration stops working after configuration
    
    **Solution:**
    1. Check if password or token changed
    2. Verify Salesforce user still active
    3. Review Salesforce security settings (IP whitelist)
    4. Test connection again, update credentials if needed
  
  
  
    **Issue**: Cannot save field mappings
    
    **Solution:**
    1. Ensure all required FN fields mapped
    2. Check data type compatibility
    3. Add default values for optional fields
    4. Review error messages for specific field issues
  

---

---

### undefined
URL: /docs/connectors/platforms/salesforce/overview

# Connectors: undefined
URL: /docs/connectors/platforms/salesforce/overview
Source: content/docs/connectors/platforms/salesforce/overview.mdx

---
title: Salesforce Connector
description: Integrate Salesforce CRM with Field Nation for automated work order creation and bidirectional status synchronization.
---

## Overview

The Salesforce connector enables seamless integration between Salesforce CRM and Field Nation:
- **Trigger-based creation**: Use Salesforce Flows to automatically create Field Nation work orders
- **Real-time sync**: Instant notification via Outbound Messages
- **Bidirectional messaging**: Sync comments between platforms
- **Flexible object support**: Works with standard or custom Salesforce objects
- **Related field access**: Map fields from parent/related objects

---

## At a Glance

  
    Username + Password + Security Token
  
  
    Any standard or custom object (Case, Opportunity, etc.)
  
  
    Record-Triggered Flows + Outbound Messages
  
  
    Bidirectional (create, update, messages)
  

---

## How It Works

### Configure Flow

Create record-triggered Flow in Salesforce that evaluates conditions (status change, checkbox, etc.)

### Call Outbound Message

Flow invokes Outbound Message to send record ID to Field Nation trigger URL

### Field Nation Fetches Data

Integration Broker retrieves complete record data from Salesforce API using configured credentials

### Apply Mappings

Broker applies field mappings and transformations to convert Salesforce data into Field Nation work order format

### Create Work Order

Transformed data creates or updates Field Nation work order with correlation ID stored for bidirectional sync

---

## Common Use Cases

### Dispatch from Case

Automatically create Field Nation work order when Case status changes to "On-site Required"

```
Case Status = "Dispatch Required" 
  → Flow triggers 
  → Outbound Message 
  → Field Nation Work Order Created
```

### Controlled Send via Checkbox

Use custom checkbox field to give users control over when to dispatch to Field Nation

```
"Send to Field Nation" checkbox = True
  → Flow triggers
  → Work order created
  → Checkbox reset or status updated
```

### Status Synchronization

Reflect Field Nation work order status and completion back to Salesforce Case

```
FN Work Order Status = "Completed"
  → Integration Broker
  → Salesforce Case Status = "Resolved"
  → Case Comment added with completion details
```

### Bidirectional Messaging

Sync comments and messages between Salesforce users and Field Nation technicians

```
Technician adds message in FN
  → Broker creates CaseComment in Salesforce
  
Salesforce user adds CaseComment
  → Flow triggers Outbound Message
  → Message appears in FN work order
```

---

## Architecture

```mermaid
sequenceDiagram
    participant SF as Salesforce
    participant Flow as Record-Triggered Flow
    participant OM as Outbound Message
    participant Broker as Integration Broker
    participant FN as Field Nation
    
    SF->>Flow: Record Created/Updated
    Flow->>Flow: Evaluate Conditions
    Flow->>OM: Call Outbound Message
    OM->>Broker: POST Trigger URL (Record ID)
    Broker->>SF: GET Record Data (API)
    SF-->>Broker: Full Record + Related Fields
    Broker->>Broker: Apply Field Mappings
    Broker->>FN: Create/Update Work Order
    FN-->>Broker: Success + WO ID
    Broker->>SF: Update Sync Status (optional)
```

---

## Features

### Field Mapping Capabilities

- **Standard Fields**: Case Subject, Description, Priority
- **Custom Fields**: Access any custom field on base object
- **Related Objects**: Map fields from Account, Contact, Owner, etc.
- **Lookup Fields**: Access related record data (e.g., Account.Name)
- **Formula Fields**: Use calculated field values
- **Picklist Values**: Map Salesforce picklists to Field Nation enums

### Supported Operations

---

## Prerequisites

### Salesforce Requirements

  
    - Create and modify Flows
    - Configure Outbound Messages
    - Manage API users and permissions
    - Access Setup menu
  
  
  
    - Salesforce user with API access enabled
    - Read permissions on all fields to sync FROM Salesforce
    - Write permissions on all fields to sync TO Salesforce
    - Access to base object and related objects
  
  
  
    - Generate security token from Salesforce personal settings
    - Select "Reset My Security Token"
    - Token will be emailed to registered email address
    - Keep token secure (treat like a password)
  
  
  
    - Allow API access (not blocked by Profile/Permission Set)
    - Whitelist Field Nation IP addresses if using IP restrictions
    - Enable "API Enabled" permission for integration user
  

### Field Nation Requirements

- Active buyer account with admin access
- Integration settings access
- Sandbox environment (recommended for testing)

[Complete prerequisites →](/docs/connectors/getting-started)

---

## Authentication

The Salesforce connector uses **Username-Password flow** with security token:

```
Authentication = Username + Password + SecurityToken
Instance = production | test (sandbox)
```

**Format:**
- **Username**: Full email address (e.g., `integration@company.com`)
- **Password**: Salesforce password
- **Security Token**: System-generated key from Salesforce

**Instance Types:**
- **production**: Connect to live Salesforce org (`login.salesforce.com`)
- **test**: Connect to sandbox environment (`test.salesforce.com`)

> **Security Best Practice**: Create dedicated integration user instead of using personal account. This provides better security, audit trails, and prevents integration breakage if personal account is deactivated.

---

## Data Flow Patterns

### Inbound: Salesforce → Field Nation

**Trigger**: Record-Triggered Flow evaluates conditions  
**Action**: Outbound Message sends record ID to Field Nation  
**Result**: Field Nation work order created/updated

**Example Flow Conditions:**
- Case Status = "Dispatch Required"
- Custom Checkbox "Send to FN" = True
- Priority = "High" AND Type = "On-site"
- Record Type = "Field Service"

---

### Outbound: Field Nation → Salesforce

**Trigger**: Field Nation work order event (assigned, completed, etc.)  
**Action**: Integration Broker calls Salesforce API  
**Result**: Salesforce Case/record updated with status/comments

**Configurable Events:**
- Work order assigned → Update Case Status
- Work order completed → Add CaseComment with details
- Provider checked in → Update custom field "Technician Arrived"
- Work order approved → Update Case Status to "Resolved"

---

## Best Practices

### Flow Design

- ✅ Use specific trigger conditions (avoid "any field changed")
- ✅ Add safeguards to prevent duplicate sending
- ✅ Test with sandbox Salesforce and Field Nation environments
- ✅ Handle failures gracefully (don't block record saves)
- ✅ Log Flow execution for debugging

### Field Mappings

- ✅ Map all required Field Nation fields
- ✅ Use default values for optional fields
- ✅ Test with various Salesforce record states
- ✅ Handle null/empty values appropriately
- ✅ Document mapping logic for maintenance

### Security

- ✅ Use dedicated integration user (not personal account)
- ✅ Rotate security token periodically
- ✅ Grant minimum required permissions
- ✅ Monitor API usage and limits
- ✅ Enable IP whitelisting if security policy requires

---

## Limitations & Considerations

### API Limits

Salesforce enforces API call limits based on license type:
- **Enterprise**: 1,000 calls/day (min)
- **Unlimited**: 5,000 calls/day (min)
- **Additional**: Available for purchase

Each work order sync consumes **2-3 API calls** (authentication + data retrieval + optional status update).

[Monitor API usage in Salesforce Setup → System Overview]

### Related Object Depth

The connector can access:
- ✅ Fields on base object (Case, Opportunity, etc.)
- ✅ Fields on directly related parent objects (Account, Contact, Owner)
- ❌ Grand-parent or distant relationships (requires custom JSONNET)

**Example Access:**
- ✅ `Case.Account.Name` - Direct parent
- ✅ `Case.Contact.Email` - Direct relationship
- ❌ `Case.Account.Parent.Name` - Two levels up (not automatic)

### Outbound Message Behavior

- Salesforce retries failed Outbound Messages for 24 hours
- Integration Broker responds within seconds to prevent retries
- If Broker is down, Salesforce will retry (may cause duplicates)
- Implement idempotency using correlation IDs

---

---

### undefined
URL: /docs/connectors/platforms/salesforce/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/salesforce/workflow
Source: content/docs/connectors/platforms/salesforce/workflow.mdx

---
title: Workflow Setup
description: Create Salesforce Flows and Outbound Messages to automatically send work order data to Field Nation.
---

## Prerequisites

Before starting, ensure you have:

- ☐ Completed [Field Nation configuration](/docs/connectors/platforms/salesforce/configuration)
- ☐ Field Nation trigger URL copied
- ☐ Salesforce admin access (Setup permissions)
- ☐ Permission to create Flows and Outbound Messages
- ☐ Trigger field on your object (checkbox or status)

---

## Architecture Overview

The Salesforce workflow consists of two components:

```mermaid
graph LR
    A[Record Created/Updated] --> B{Flow Evaluates<br/>Conditions}
    B -->|Conditions Met| C[Outbound Message]
    C --> D[Field Nation Trigger URL]
    D --> E[Work Order Created]
    B -->|Conditions Not Met| F[No Action]
```

**Flow**: Monitors records and evaluates conditions  
**Outbound Message**: Sends record ID to Field Nation  
**Field Nation**: Fetches full record data and creates work order

---

## Step 1: Create Outbound Message

Outbound Messages send record IDs to Field Nation's trigger URL.

### Navigate to Setup

Salesforce Setup → Quick Find → "Outbound Messages"

### Create New Message

Click "New Outbound Message"

![Outbound Message](/docs/integrations/salesforce/outbound_message.png)

### Select Object

Choose the same object you configured in Field Nation (e.g., `Case`)

### Configure Message

**Name**: Descriptive name (e.g., "Send to Field Nation")  
**Unique Name**: Auto-populated (can customize)  
**Endpoint URL**: Paste Field Nation trigger URL

```
https://api.fieldnation.com/integrations/trigger/{YOUR_CLIENT_TOKEN}
```

### Select Fields

**Important**: Only select the **ID field**

Field Nation retrieves all other fields via API using the ID.

**Why only ID?**
- Reduces message size
- Ensures latest data (fetched at processing time)
- Prevents stale data if record updates between trigger and processing

### Additional Settings

- ☐ **Send Session ID**: Leave **unchecked** (not needed)
- ☐ **Protected Component**: Leave **unchecked** (unless in managed package)

### Save Message

Click "Save" - Salesforce generates WSDL and endpoint configuration

---

## Step 2: Prepare Trigger Field

Create or identify the field that will trigger work order creation.

### Option A: Create Checkbox Field

Most common approach - gives users explicit control.

### Navigate to Object Manager

Setup → Object Manager → Your Object (e.g., Case)

### Fields & Relationships

Click "Fields & Relationships" → "New"

### Select Checkbox

Field Type: Checkbox

### Configure Field

**Field Label**: "Send to Field Nation"  
**Field Name**: Auto-populated (e.g., `Send_to_Field_Nation__c`)  
**Default Value**: Unchecked  
**Description**: "Check to create Field Nation work order"

![Trigger Field Example](/docs/integrations/salesforce/flows7.png)

### Field-Level Security

Grant access to appropriate profiles

### Page Layouts

Add field to relevant page layouts so users can see/modify it

---

### Option B: Use Existing Status/Picklist

Alternative approach - trigger based on status change.

**Example Configurations:**
- Case Status = "Dispatch Required"
- Priority = "High" AND Status = "Approved"
- Record Type = "Field Service" AND Stage = "Scheduled"

> [INFO] **Best Practice**: Checkbox provides better control and prevents accidental triggers. Status-based triggering requires careful condition design to prevent unwanted work order creation.

---

## Step 3: Create Record-Triggered Flow

Flows provide the automation logic to trigger outbound messages.

### Open Flow Builder

Setup → Quick Find → "Flows" → "New Flow"

![Flows Page](/docs/integrations/salesforce/flows1.png)

### Select Flow Type

Choose **"Record-Triggered Flow"**

![New Flow](/docs/integrations/salesforce/flows2.png)

![Record-Triggered Flow](/docs/integrations/salesforce/flows3.png)

---

### Configure Trigger Settings

![Flow Trigger Configuration](/docs/integrations/salesforce/flows4.png)

#### Object

Select the Salesforce object (must match Field Nation configuration and Outbound Message)

**Example**: `Case`

---

#### Trigger Event

Choose when the Flow should run:

**A record is created or updated** (Most common)
- Creates work order for new records
- Updates work order when record changes
- Flexible for various scenarios

**A record is created** (Initial dispatch only)
- Only triggers on new records
- Subsequent updates don't trigger
- Use when you want one-time creation

**A record is updated** (Updates only)
- Only triggers on updates to existing records
- Won't create work orders for new records

**A record is deleted** (Rare)
- Triggers when record deleted
- Use for cleanup scenarios

---

#### Entry Conditions

Define exactly when the Flow should run.

**Option 1: Simple Condition (AND logic)**

Select **"All Conditions Are Met (AND)"**

Add condition:
- **Field**: `Send to Field Nation` (your trigger checkbox)
- **Operator**: `Equals`
- **Value**: `True`

**Option 2: Complex Conditions (Custom logic)**

Select **"Custom Condition Logic (Advanced)"**

**Examples:**
```
1. Send_to_Field_Nation__c = TRUE AND Status = "Approved"

2. (Status = "Dispatch Required" OR Priority = "High") 
   AND RecordType.Name = "Field Service"

3. Send_to_Field_Nation__c = TRUE 
   AND Account.Type = "Customer" 
   AND NOT(ISBLANK(Description))
```

---

#### Additional Conditions (Optional)

Add filters to control when work orders are created:

**By Status:**
```
Status = "Approved"
Status != "Cancelled"
Status IN ("New", "Assigned", "In Progress")
```

**By Record Type:**
```
RecordType.Name = "Field Service"
RecordType.DeveloperName = "On_Site_Service"
```

**By Owner/Assignment:**
```
Owner.Department = "Field Operations"
Owner.UserRole.Name CONTAINS "Service"
```

**By Field Validation:**
```
NOT(ISBLANK(Account.Name))
NOT(ISBLANK(Priority))
Amount > 0
```

---

#### Optimize the Flow For

Select **"Actions and Related Records"**

This enables:
- Calling Outbound Messages
- Accessing related object data
- Better performance for this use case

---

#### Click Done

Save the trigger configuration

---

### Add Outbound Message Action

![Add Action](/docs/integrations/salesforce/flows5.png)

### Add Action Element

Click the **+** icon after the Start element → Select **"Action"**

### Find Outbound Message

In the left panel, scroll to **"Outbound Message"** category → Expand it

### Select Your Message

Choose the Outbound Message you created earlier

![Select Outbound Message](/docs/integrations/salesforce/flows5.5.png)

### Configure Action

**Label**: Descriptive name (e.g., "Send to Field Nation")  
**API Name**: Auto-populated  
**Description**: Optional description

### Set Input Values

**No configuration needed** - Outbound Message automatically uses the triggering record

### Click Done

The action is added to your Flow

---

### Complete Flow

Your Flow should now look like this:

![Complete Flow](/docs/integrations/salesforce/flows6.png)

1. **Start**: Trigger conditions evaluated
2. **Action**: Outbound Message sent
3. **End**: Flow completes

---

## Step 4: Save & Activate Flow

### Save Flow

Click **"Save"** button in toolbar

**Flow Label**: Descriptive name (e.g., "Create Field Nation Work Order")  
**Flow API Name**: Auto-populated  
**Description**: Purpose of the Flow (e.g., "Sends Cases to Field Nation when Send to FN checkbox is checked")

### Activate Flow

Click **"Activate"** button

**Before Activation:**
- Flow exists but doesn't run
- Good for testing configuration

**After Activation:**
- Flow actively monitors records
- Triggers when conditions met
- Can be deactivated later if needed

### Verify Status

Return to Flows page → Verify status shows **"Active"**

![Active Flow](/docs/integrations/salesforce/flows8.png)

> **Important**: Flow must be **Active** to process records. Saved but inactive Flows won't trigger.

---

## Step 5: Test the Integration

Thoroughly test before production use.

### Create Test Record

### Navigate to Your Object

Go to Cases (or your configured object)

### Create New Record

Click "New" → Fill in required fields

**Test Data:**
- Subject/Title: "Test FN Integration"
- Description: "Testing Salesforce to Field Nation sync"
- Priority: Select appropriate value
- Any other required/mapped fields

### Check Trigger Field

✅ Check **"Send to Field Nation"** (or set status to trigger value)

### Save Record

Click "Save"

Flow triggers immediately on save

---

### Verify in Field Nation

### Log into Field Nation

Access your Field Nation account (Sandbox or Production - match your configuration)

### Navigate to Work Orders

Dashboard → Work Orders → All Work Orders

### Find Test Work Order

Look for recently created work order with title from Salesforce

### Verify Field Mappings

Check that data populated correctly:
- Title matches Case Subject
- Description matches Case Description
- Location/Company from Salesforce Account
- Custom fields populated
- All required fields present

### Check Correlation ID

Work order should have reference to Salesforce record ID (for bidirectional sync)

---

## Troubleshooting

### Work Order Not Created

  
    **Check:**
    - ☐ Flow status = "Active"
    - ☐ Trigger field checked/set correctly
    - ☐ Record meets ALL entry conditions
    - ☐ No validation rules blocking save
    
    **Debug:**
    - Setup → Debug Logs → Enable debug for your user
    - Repeat test record creation
    - Review debug log for Flow execution
  
  
  
    **Check:**
    - ☐ Outbound Message endpoint URL correct
    - ☐ Flow action configured correctly
    - ☐ No network/firewall blocking outbound HTTPS
    
    **View Queue:**
    - Setup → Outbound Messages → "View Queue"
    - Check for pending or failed messages
    - Click message ID for error details
    
    **Test Endpoint:**
    ```bash
    curl -X POST https://api.fieldnation.com/integrations/trigger/{YOUR_TOKEN} \
         -H "Content-Type: text/xml" \
         -d '<?xml version="1.0"?><test/>'
    ```
  
  
  
    **Check:**
    - ☐ Field Nation configuration complete
    - ☐ Credentials valid (test connection)
    - ☐ Trigger URL matches Outbound Message endpoint
    - ☐ Object name matches Salesforce object
    
    **Review Logs:**
    - Field Nation → Integrations → Logs
    - Filter by date/time of test
    - Look for incoming webhook and processing status
  
  
  
    **Check:**
    - ☐ Fields refreshed in Field Nation
    - ☐ Required FN fields all mapped
    - ☐ Data types compatible
    - ☐ Picklist values mapped correctly (Array Map)
    
    **Test:**
    - Create simple record with minimal data
    - Verify basic fields sync first
    - Add complex mappings incrementally
  

---

### Common Errors

**"INVALID_SESSION_ID"**
- Field Nation credentials expired
- Regenerate security token
- Update Field Nation configuration

**"INSUFFICIENT_ACCESS"**
- Salesforce API user lacks permissions
- Grant "API Enabled" permission
- Verify object and field permissions

**"REQUIRED_FIELD_MISSING"**
- Missing required Field Nation work order fields
- Add field mappings or default values
- Check Field Nation logs for specific field name

**Outbound Message Timeout**
- Field Nation processing too slow
- Contact Field Nation Support
- Usually resolves within seconds

---

## Advanced Configurations

### Multiple Outbound Messages

Create separate Flows for different scenarios:

**Example:**
- Flow 1: Urgent Cases → Priority handling
- Flow 2: Standard Cases → Normal processing
- Flow 3: Updates Only → Sync status changes

**Benefits:**
- Different field mappings per scenario
- Conditional routing
- Better monitoring/debugging

---

### Prevent Duplicate Sends

Add logic to prevent re-triggering:

### Add Decision Element

After Start → Add Decision element before Outbound Message

### Check Sync Status

**Decision Criteria:**
- Custom field `FN_Sync_Status__c` = null OR "Not Sent"

### Route Logic

- **Met Criteria**: Send Outbound Message
- **Not Met**: End (don't send)

### Update After Send

Add another action after Outbound Message:
- Update Record: Set `FN_Sync_Status__c` = "Sent"

---

### Schedule-Based Triggering

Use Scheduled Flow instead of Record-Triggered for batch processing:

**When to Use:**
- High volume (avoid API limits)
- Off-peak processing
- Batch creation vs real-time

**Configuration:**
- Flow Type: "Scheduled Flow"
- Frequency: Daily, Weekly, etc.
- Query: Get Records where `Send_to_FN__c = TRUE AND FN_Sync_Status__c = null`
- Loop through records → Send Outbound Message for each

---

## Production Deployment

### Pre-Launch Checklist

- ☐ Sandbox testing complete and successful
- ☐ All field mappings validated
- ☐ Error handling tested
- ☐ User training completed
- ☐ Monitoring/alerting configured
- ☐ Rollback plan documented

### Launch Steps

### Deploy to Production

Use Change Sets or Salesforce DX to deploy:
- Outbound Message
- Custom fields (if created)
- Flow (initially as Inactive)
- Page layout changes

### Update Field Nation Configuration

Switch Field Nation from Sandbox to Production:
- Update credentials (production Salesforce user)
- Update instance type to "production"
- Test connection
- Copy new trigger URL

### Update Outbound Message

Update endpoint URL with production trigger URL

### Activate Flow

After successful testing, activate the Flow in production

### Monitor Closely

Watch first few syncs for any issues

---

## Maintenance

### Regular Tasks

**Weekly:**
- Review Outbound Message queue for failures
- Check Field Nation integration logs
- Monitor API usage in Salesforce

**Monthly:**
- Review and update field mappings
- Test integration with sample records
- Update documentation for any changes

**Quarterly:**
- Rotate security token (update Field Nation)
- Review and optimize Flow conditions
- Audit integration usage and performance

---

---

### undefined
URL: /docs/connectors/platforms/servicenow/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/servicenow/configuration
Source: content/docs/connectors/platforms/servicenow/configuration.mdx

---
title: Configuration
description: Configure the ServiceNow connector in Field Nation's Integration Broker to establish API connection and field mappings.
---

## Configuration Steps Overview

###Access Integration Broker

Navigate to Field Nation's Integration Broker interface

### Select ServiceNow

Choose ServiceNow connector from available integrations

### Configure Connection

Enter ServiceNow instance URL and authentication credentials

### Select Table

Specify which ServiceNow table to integrate (Incident, Case, etc.)

### Refresh Fields

Discover available fields from ServiceNow metadata

### Configure Mappings

Map fields between ServiceNow and Field Nation

### Test & Save

Validate configuration and save settings

---

## Step 1: Access Integration Broker

**Sandbox**: [ui-sandbox.fndev.net/integrations](https://ui-sandbox.fndev.net/integrations)  
**Production**: [app.fieldnation.com/integrations](https://app.fieldnation.com/integrations)

Select "ServiceNow" from the list of available connectors.

---

## Step 2: Basic Settings

### Instance Name

**Optional** - Descriptive name for this integration

**Examples:**
- "Production ServiceNow"
- "ITSM Integration - NA"
- "Dev Instance"

**Use Case**: Helpful when managing multiple ServiceNow integrations.

---

### Instance URL

**Required** - Your ServiceNow instance URL

**Format:**
```
https://instance-name.service-now.com
```

**Examples:**
- `https://dev12345.service-now.com` (developer instance)
- `https://company.service-now.com` (production)
- `https://companytest.service-now.com` (test instance)

**Find Your Instance URL:**
1. Log into ServiceNow
2. Check browser address bar
3. Copy full URL up to `.service-now.com`

> **Do not include** trailing slashes or API paths. Just the base instance URL.

---

### Table Name

**Required** - ServiceNow table API name for integration

**Standard Tables:**
- `incident` - IT Incidents
- `case` - Customer Service Cases
- `problem` - Problem Management
- `sc_task` - Service Catalog Tasks

**Custom Tables:**
- `u_field_service_request` - Custom FSM table
- `u_work_order` - Custom work order table

**Format Rules:**
- Use table name, not label
- Standard tables: lowercase (`incident`)
- Custom tables: Prefix with `u_` (`u_my_table`)

**Field Access:**
- All fields on the base table
- Fields from directly related tables via reference fields

---

## Step 3: Authentication

ServiceNow connector supports OAuth 2.0 or Basic Auth.

### OAuth 2.0 (Recommended)

### Create OAuth Application in ServiceNow

1. Navigate to **System OAuth → Application Registry**
2. Click **New** → **Create an OAuth API endpoint for external clients**
3. Configure:
   - **Name**: Field Nation Integration
   - **Client ID**: Auto-generated (copy this)
   - **Client Secret**: Auto-generated (copy this)
   - **Redirect URL**: Leave blank (using Client Credentials)
   - **Token Lifespan**: 3600 (1 hour)
   - **Refresh Token Lifespan**: 86400 (24 hours)
4. Save OAuth Application

### Configure in Field Nation

In Integration Broker, select **OAuth 2.0** and enter:

**Client ID**: From ServiceNow OAuth app

**Client Secret**: From ServiceNow OAuth app

**Token URL**: `https://instance.service-now.com/oauth_token.do`

**Grant Type**: `client_credentials`

---

### Basic Authentication

### Create Integration User in ServiceNow

1. Navigate to **User Administration → Users**
2. Click **New**
3. Configure:
   - **User ID**: `integration.fieldnation`
   - **First Name**: Field Nation
   - **Last Name**: Integration
   - **Email**: integration@company.com
   - **Password**: Strong, unique password
4. Assign Roles:
   - `web_service_admin` or
   - `rest_api_explorer`
5. Save User

### Configure in Field Nation

In Integration Broker, select **Basic Auth** and enter:

**Username**: ServiceNow user ID (e.g., `integration.fieldnation`)

**Password**: User's password

> [INFO] **Best Practice**: OAuth 2.0 is more secure and recommended for production. Basic Auth is simpler for testing/development environments.

---

## Step 4: Test Connection

### Click "Test Connection"

Button in configuration form

### Integration Broker Validates

- Authenticates with ServiceNow
- Queries table metadata
- Verifies permissions

### Review Result

**Success**: ✅ Green confirmation
- Connection established
- Authentication valid
- Table accessible

**Failure**: ❌ Error message
- Check error details
- Fix configuration
- Retry

### Common Authentication Errors

  
    **Cause**: Invalid OAuth credentials
    
    **Solution:**
    1. Verify Client ID and Secret correct
    2. Ensure OAuth app active in ServiceNow
    3. Check Token URL matches instance
    4. Regenerate credentials if needed
  
  
  
    **Cause**: Invalid username/password
    
    **Solution:**
    1. Verify credentials correct
    2. Check user active in ServiceNow
    3. Ensure user has required roles
    4. Test login to ServiceNow directly
  
  
  
    **Cause**: Insufficient permissions
    
    **Solution:**
    1. Grant `web_service_admin` or `rest_api_explorer` role
    2. Verify ACLs allow table access
    3. Check field-level permissions
    4. Review IP restrictions
  
  
  
    **Cause**: Table doesn't exist or name incorrect
    
    **Solution:**
    1. Verify table name correct (case-sensitive)
    2. Check table exists in ServiceNow
    3. For custom tables, confirm `u_` prefix
    4. Ensure table not in different scope/app
  

---

## Step 5: Get Trigger URL

Once authentication succeeds, Field Nation generates your unique trigger URL.

**Format:**
```
https://api.fieldnation.com/integrations/trigger/{CLIENT_TOKEN}
```

**Copy this URL** - You'll need it when configuring the REST Message in ServiceNow.

> [INFO] **Security**: The client token authenticates incoming webhooks. Keep this URL secure.

---

## Step 6: Refresh Fields

Discover available fields for mapping.

### Click "Refresh Fields"

Button in field mapping section

### Broker Queries ServiceNow

- Calls Table API metadata endpoint
- Retrieves field definitions
- Discovers related table fields

### Fields Populate

Dropdown menus fill with:
- Standard fields (short_description, description, state)
- Custom fields (u_custom_field)
- Reference fields (assignment_group.name, location.city)
- Choice values (for state, priority, etc.)

---

## Step 7: Configure Field Mappings

Map data between ServiceNow and Field Nation.

### Inbound (ServiceNow → Field Nation)

**Example Mappings:**
```
ServiceNow Field              → FN Field                   Action
─────────────────────────────────────────────────────────────────
short_description            → title                      Sync
description                  → description                Sync
location.name                → location.company.name      Sync
priority                     → priority                   Array Map
state                        → status_id                  Array Map
caller_id.email              → contact.email              Sync
work_start                   → schedule.start             Date Convert
```

### Outbound (Field Nation → ServiceNow)

**Example Mappings:**
```
FN Field                     → ServiceNow Field           Action
─────────────────────────────────────────────────────────────────
status.name                  → state                      Array Map
assignee.user.name           → assigned_to.name           Sync
completion_notes             → work_notes                 Sync
completion_date              → resolved_at                Date Convert
```

### State/Status Mapping

**ServiceNow States** (Incident):
```
1 = New
2 = In Progress
3 = On Hold
4 = Resolved
5 = Closed
6 = Cancelled
```

**Field Nation Status IDs:**
```
1 = Draft
2 = Assigned
3 = Work Done
4 = Approved
5 = Paid
```

**Array Map Configuration:**
```jsonnet
{
  "source": "state",
  "target": "status_id",
  "action": "array_map",
  "mappings": [
    { "compare": "1", "value": "1" },  // New → Draft
    { "compare": "2", "value": "2" },  // In Progress → Assigned
    { "compare": "4", "value": "3" },  // Resolved → Work Done
    { "compare": "5", "value": "4" }   // Closed → Approved
  ],
  "default": "1"
}
```

[Complete field mapping guide →](/docs/connectors/concepts/field-mappings)

---

## Step 8: Save Configuration

### Review Settings

Verify all configuration:
- ☐ Instance URL correct
- ☐ Table name correct
- ☐ Authentication successful
- ☐ Fields refreshed
- ☐ Inbound mappings configured
- ☐ Outbound mappings configured

### Save

Click "Save" to persist configuration

### Note Trigger URL

Copy trigger URL for ServiceNow REST Message configuration

---

## Configuration Checklist

### Field Nation Configuration
- ☐ Instance name configured
- ☐ Instance URL entered
- ☐ Table name correct
- ☐ Authentication method selected
- ☐ Credentials entered
- ☐ Connection tested successfully
- ☐ Trigger URL copied
- ☐ Fields refreshed
- ☐ Inbound field mappings configured
- ☐ Outbound field mappings configured
- ☐ Configuration saved

### ServiceNow Configuration (Next Steps)
- ☐ REST Message created
- ☐ Business Rule created
- ☐ Business Rule conditions defined
- ☐ Business Rule activated
- ☐ Integration tested with sample record

[ServiceNow workflow setup →](/docs/connectors/platforms/servicenow/workflow)

---

---

### undefined
URL: /docs/connectors/platforms/servicenow/overview

# Connectors: undefined
URL: /docs/connectors/platforms/servicenow/overview
Source: content/docs/connectors/platforms/servicenow/overview.mdx

---
title: ServiceNow Connector
description: Integrate ServiceNow ITSM with Field Nation for automated work order creation from Incidents, Cases, or custom tables.
---

## Overview

The ServiceNow connector enables seamless integration between ServiceNow ITSM and Field Nation:
- **Trigger-based creation**: Use Business Rules to automatically create work orders
- **REST Message integration**: Secure webhook communication
- **Bidirectional sync**: Status and notes flow both directions
- **Flexible table support**: Works with Incident, Case, or custom tables
- **Related field access**: Map fields from related tables

---

## At a Glance

  
    OAuth 2.0 or Basic Auth (username + password)
  
  
    Incident, Case, Problem, or custom tables
  
  
    Business Rules + REST Messages
  
  
    Bidirectional (create, update, messages)
  

---

## How It Works

### Configure Business Rule

Create Business Rule in ServiceNow that evaluates conditions (state change, assignment, etc.)

### Call REST Message

Business Rule invokes REST Message to send record sys_id to Field Nation trigger URL

### Field Nation Fetches Data

Integration Broker retrieves complete record data from ServiceNow API using configured credentials

### Apply Mappings

Broker applies field mappings and transformations to convert ServiceNow data into Field Nation work order format

### Create Work Order

Transformed data creates or updates Field Nation work order with correlation ID stored for bidirectional sync

---

## Common Use Cases

### Dispatch from Incident

Automatically create Field Nation work order when Incident requires on-site service

```
Incident State = "On-Site Required" 
  → Business Rule triggers 
  → REST Message 
  → Field Nation Work Order Created
```

### Assignment-Based Triggering

Dispatch when incident assigned to field service group

```
Assignment Group = "Field Services"
  → Business Rule triggers
  → Work order created
  → Assignment updated with FN details
```

### Status Synchronization

Reflect Field Nation work order status back to ServiceNow Incident

```
FN Work Order Status = "Completed"
  → Integration Broker
  → ServiceNow Incident State = "Resolved"
  → Work Notes added with completion details
```

---

## Architecture

```mermaid
sequenceDiagram
    participant SN as ServiceNow
    participant BR as Business Rule
    participant RM as REST Message
    participant Broker as Integration Broker
    participant FN as Field Nation
    
    SN->>BR: Record Created/Updated
    BR->>BR: Evaluate Conditions
    BR->>RM: Execute REST Message
    RM->>Broker: POST Trigger URL (sys_id)
    Broker->>SN: GET Record Data (API)
    SN-->>Broker: Full Record + Related Tables
    Broker->>Broker: Apply Field Mappings
    Broker->>FN: Create/Update Work Order
    FN-->>Broker: Success + WO ID
    Broker->>SN: Update Sync Status (optional)
```

---

## Features

### Field Mapping Capabilities

- **Standard Fields**: Short Description, Description, State, Priority
- **Custom Fields**: Access any custom field on base table
- **Related Tables**: Map fields from Assignment Group, Location, Caller, etc.
- **Reference Fields**: Access related record data (e.g., Location.Name)
- **Choice Fields**: Map ServiceNow choices to Field Nation enums

### Supported Operations

---

## Prerequisites

### ServiceNow Requirements

  
    - Create and modify Business Rules
    - Configure REST Messages
    - Manage integration users and roles
    - Access Studio or Update Sets
  
  
  
    - ServiceNow user with web_service_admin or rest_api_explorer role
    - Read permissions on all fields to sync FROM ServiceNow
    - Write permissions on all fields to sync TO ServiceNow
    - Access to base table and related tables
  
  
  
    - Allow REST API access (not blocked by ACLs)
    - Whitelist Field Nation IP addresses if using IP restrictions
    - Enable "web_service_provider" plugin (usually enabled)
  

### Field Nation Requirements

- Active buyer account with admin access
- Integration settings access
- Sandbox environment (recommended for testing)

[Complete prerequisites →](/docs/connectors/getting-started)

---

## Authentication

ServiceNow connector supports **OAuth 2.0** (recommended) or **Basic Auth**:

### OAuth 2.0 (Recommended)

```
Grant Type: Client Credentials
Token Endpoint: https://instance.service-now.com/oauth_token.do
Client ID: {your_client_id}
Client Secret: {your_client_secret}
```

**Benefits:**
- More secure (no password storage)
- Token rotation automatic
- Better audit trails
- Granular scope control

### Basic Authentication

```
Username: integration.user
Password: {secure_password}
Format: Basic base64(username:password)
```

**When to Use:**
- Quick setup for testing
- Legacy ServiceNow instances
- Simpler credential management

> **Security Best Practice**: Use OAuth 2.0 in production. Create dedicated integration user instead of personal account for better security and audit trails.

---

## Data Flow Patterns

### Inbound: ServiceNow → Field Nation

**Trigger**: Business Rule evaluates conditions  
**Action**: REST Message sends sys_id to Field Nation  
**Result**: Field Nation work order created/updated

**Example Business Rule Conditions:**
- State = "On-Site Required"
- Custom Field "Dispatch to FN" = true
- Priority = "1-Critical" AND Category = "Hardware"
- Assignment Group contains "Field"

---

### Outbound: Field Nation → ServiceNow

**Trigger**: Field Nation work order event (assigned, completed, etc.)  
**Action**: Integration Broker calls ServiceNow API  
**Result**: ServiceNow Incident/record updated with status/work notes

**Configurable Events:**
- Work order assigned → Update Incident State
- Work order completed → Add Work Notes with details
- Provider checked in → Update custom field "Tech Arrived"
- Work order approved → Update State to "Resolved"

---

## Best Practices

### Business Rule Design

- ✅ Use specific conditions (avoid "on any field update")
- ✅ Run Business Rule "async" to prevent blocking
- ✅ Add condition to prevent duplicate triggers
- ✅ Test in sub-production instance first
- ✅ Document Business Rule logic

### Field Mappings

- ✅ Map all required Field Nation fields
- ✅ Use default values for optional fields
- ✅ Handle Choice fields with Array Map
- ✅ Test with various record states
- ✅ Document mapping logic

### Security

- ✅ Use OAuth 2.0 in production
- ✅ Use dedicated integration user
- ✅ Grant minimum required roles
- ✅ Monitor API usage and limits
- ✅ Enable IP whitelisting if policy requires

---

## Limitations & Considerations

### API Limits

ServiceNow enforces API call limits based on license:
- **Enterprise**: Varies by contract
- **Professional**: Limited API calls/hour
- **Developer instances**: 10K calls/24 hours

Each work order sync consumes **2-3 API calls** (authentication + data retrieval + optional status update).

[Monitor API usage in ServiceNow → System Diagnostics → Stats]

### Related Table Depth

The connector can access:
- ✅ Fields on base table (Incident, Case, etc.)
- ✅ Fields on directly related tables (Assignment Group, Location, Caller)
- ❌ Grand-parent or distant relationships (requires custom JSONNET)

**Example Access:**
- ✅ `incident.location.name` - Direct reference
- ✅ `incident.caller_id.email` - Direct relationship
- ❌ `incident.location.parent.company.name` - Multiple levels (not automatic)

---

---

### undefined
URL: /docs/connectors/platforms/servicenow/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/servicenow/workflow
Source: content/docs/connectors/platforms/servicenow/workflow.mdx

---
title: Workflow Setup
description: Create ServiceNow Business Rules and REST Messages to automatically send work order data to Field Nation.
---

## Workflow Overview

```mermaid
graph LR
    A[Record Created/Updated] --> B{Business Rule<br/>Evaluates}
    B -->|Conditions Met| C[Execute REST Message]
    C --> D[Field Nation Trigger URL]
    D --> E[Work Order Created]
    B -->|Conditions Not Met| F[No Action]
```

**Business Rule**: Monitors records and evaluates conditions  
**REST Message**: Sends sys_id to Field Nation  
**Field Nation**: Fetches full record data and creates work order

---

## Step 1: Create REST Message

REST Messages define the HTTP request sent to Field Nation.

### Navigate to REST Messages

ServiceNow → System Web Services → Outbound → REST Message

### Create New REST Message

Click **New**

**Name**: `Field Nation Integration`  
**Endpoint**: Paste Field Nation trigger URL
```
https://api.fieldnation.com/integrations/trigger/{CLIENT_TOKEN}
```

**Description**: Sends incident data to Field Nation for work order creation

### Configure Authentication

**Authentication**: None (authentication handled by client token in URL)

### Save REST Message

Click **Submit**

---

### Create HTTP Method

### Open REST Message

Find your "Field Nation Integration" REST Message → Open it

### New HTTP Method

Scroll to **HTTP Methods** related list → Click **New**

**Name**: `SendToFieldNation`  
**HTTP Method**: `POST`  
**Endpoint**: Use parent endpoint (already set)

### HTTP Request Tab

**Content**: `application/json`

**HTTP Request Body**:
```json
{
  "sys_id": "${sys_id}",
  "table": "${table}",
  "timestamp": "${timestamp}"
}
```

### HTTP Headers Tab

Add header if needed:
```
Name: Content-Type
Value: application/json
```

### Save HTTP Method

Click **Submit**

---

### Test REST Message

### Open HTTP Method

Click on "SendToFieldNation" method

### Set Test Variables

In **Variable Substitutions** section:
```
sys_id: test_12345
table: incident
timestamp: 2025-01-15 10:30:00
```

### Click "Test"

Button at bottom of form

### Review Response

**Success**: 200 OK response  
**Failure**: Check error message, verify trigger URL

---

## Step 2: Create Business Rule

Business Rules provide the automation logic to trigger REST Messages.

### Navigate to Business Rules

ServiceNow → System Definition → Business Rules

### Create New Business Rule

Click **New**

### Basic Configuration

**Name**: `Field Nation - Create Work Order`

**Table**: Select your table (e.g., `incident`)

**Active**: ✅ Checked

**Advanced**: ✅ Checked (required for script)

---

### Configure When to Run

**When**:
- ☑ **After** (run after record saved)
- ☐ Before (don't check)
- ☐ Async (optional - prevents UI blocking)
- ☐ Display (don't check)

**When to run**:
- ☑ **Insert** (new records)
- ☑ **Update** (existing records)
- ☐ Delete (usually not needed)
- ☐ Query (don't check)

---

### Set Filter Conditions

**Condition**:

**Option 1: Checkbox Trigger**
```
Custom Field "Send to Field Nation" = true
```

**Option 2: State-Based Trigger**
```
State CHANGES TO On-Site Required
```

**Option 3: Assignment-Based Trigger**
```
Assignment Group CHANGES
AND
Assignment Group.Name CONTAINS Field
```

**Option 4: Combined Conditions**
```
State = On-Site Required
AND
Priority IN (1-Critical, 2-High)
AND
Assignment Group.Name = Field Services
```

---

### Add Script

**Advanced** tab → **Script** field:

```javascript
(function executeRule(current, previous /*null when async*/) {
    
    try {
        // Get REST Message
        var r = new sn_ws.RESTMessageV2('Field Nation Integration', 'SendToFieldNation');
        
        // Set parameters
        r.setStringParameterNoEscape('sys_id', current.sys_id.toString());
        r.setStringParameterNoEscape('table', current.getTableName());
        r.setStringParameterNoEscape('timestamp', new GlideDateTime().toString());
        
        // Execute REST call
        var response = r.execute();
        var httpStatus = response.getStatusCode();
        
        // Log result
        if (httpStatus == 200 || httpStatus == 201) {
            gs.info('Field Nation: Successfully sent ' + current.getTableName() + ' ' + current.sys_id + ' to Field Nation');
            
            // Optional: Update field to indicate sync
            // current.u_fn_sync_status = 'sent';
            // current.update();
        } else {
            gs.error('Field Nation: Failed to send to Field Nation. Status: ' + httpStatus + ', Body: ' + response.getBody());
        }
        
    } catch (ex) {
        gs.error('Field Nation: Exception sending to Field Nation: ' + ex.message);
    }
    
})(current, previous);
```

---

### Advanced Options

**Prevent Duplicate Sends**:

Add condition to check if already sent:

```javascript
(function executeRule(current, previous) {
    
    // Skip if already sent
    if (current.u_fn_sync_status == 'sent') {
        gs.info('Field Nation: Record already sent, skipping');
        return;
    }
    
    try {
        var r = new sn_ws.RESTMessageV2('Field Nation Integration', 'SendToFieldNation');
        // ... rest of script
        
        // Mark as sent
        current.u_fn_sync_status = 'sent';
        current.setWorkflow(false); // Prevent recursive triggers
        current.update();
        
    } catch (ex) {
        gs.error('Field Nation: Exception: ' + ex.message);
    }
    
})(current, previous);
```

### Save Business Rule

Click **Submit**

---

## Step 3: Test Integration

### Create Test Record

1. Navigate to your table (e.g., Incidents)
2. Click **New**
3. Fill in required fields
4. Set fields that meet Business Rule conditions
5. Save record

### Verify Business Rule Triggered

Check **System Logs → System Log → All**:
- Look for "Field Nation: Successfully sent..." message
- Or error messages if failed

### Check Field Nation

1. Log into Field Nation
2. Navigate to Work Orders
3. Find newly created work order
4. Verify field values match ServiceNow record

### Test Status Update (Outbound)

1. Update work order status in Field Nation
2. Check ServiceNow record updates
3. Verify Work Notes added

---

## Troubleshooting

  
    **Check:**
    - ☐ Business Rule active
    - ☐ Record meets filter conditions
    - ☐ "When to run" settings correct (Insert/Update checked)
    - ☐ Table matches Business Rule table
    
    **Debug:**
    1. Add debug logging at start of script:
    ```javascript
    gs.info('Field Nation BR: Triggered for ' + current.sys_id);
    ```
    2. Check System Logs for debug message
    3. Review filter conditions - test individually
  
  
  
    **Check:**
    - ☐ Endpoint URL correct (from Field Nation)
    - ☐ HTTP Method = POST
    - ☐ sys_id being passed correctly
    
    **Debug:**
    ```javascript
    gs.info('Field Nation: Response Status: ' + httpStatus);
    gs.info('Field Nation: Response Body: ' + response.getBody());
    ```
    
    **Common Errors:**
    - 404: Wrong trigger URL
    - 401: Invalid client token
    - 500: Field Nation processing error (check FN logs)
  
  
  
    **Check:**
    - ☐ Field Nation configuration complete
    - ☐ Credentials valid
    - ☐ All required FN fields mapped
    - ☐ Field mappings correct
    
    **Debug:**
    1. Check Integration Broker logs in Field Nation
    2. Look for incoming webhook
    3. Review field mapping errors
    4. Test with minimal field set first
  
  
  
    **Cause:** Business Rule triggering multiple times
    
    **Solutions:**
    1. Add sync status field check (shown in Advanced Options above)
    2. Use "Async" = false if timing issue
    3. Add condition: "Changes" instead of just "="
    4. Check for other Business Rules on same table
  

---

## Advanced Configurations

### Conditional Field Mapping

Send different fields based on priority:

```javascript
(function executeRule(current, previous) {
    var r = new sn_ws.RESTMessageV2('Field Nation Integration', 'SendToFieldNation');
    
    r.setStringParameterNoEscape('sys_id', current.sys_id.toString());
    r.setStringParameterNoEscape('table', current.getTableName());
    r.setStringParameterNoEscape('priority', current.priority.toString());
    
    // Add additional data for high priority
    if (current.priority <= 2) {
        r.setStringParameterNoEscape('urgent', 'true');
        r.setStringParameterNoEscape('escalation_contact', current.caller_id.email.toString());
    }
    
    var response = r.execute();
    // ... handle response
    
})(current, previous);
```

---

### Multiple Triggers for Different Scenarios

**Business Rule 1**: High Priority Incidents
```
Priority = 1-Critical
State = On-Site Required
→ Immediate dispatch
```

**Business Rule 2**: Standard Incidents
```
State = On-Site Required
Priority != 1-Critical
→ Normal dispatch
```

**Business Rule 3**: Emergency After-Hours
```
Priority = 1-Critical
Created During: After hours (use script)
→ Emergency dispatch with special handling
```

---

### Bidirectional Sync Setup

To update ServiceNow when Field Nation changes:

1. Field Nation sends webhook to ServiceNow
2. Create Scripted REST API in ServiceNow
3. Parse Field Nation webhook payload
4. Update ServiceNow record using GlideRecord

**Example Scripted REST API**:

```javascript
(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {
    
    var payload = request.body.data;
    var fn_wo_id = payload.workorder_id;
    var fn_status = payload.status;
    var sys_id = payload.correlation_id; // ServiceNow sys_id
    
    var gr = new GlideRecord('incident');
    if (gr.get(sys_id)) {
        // Map FN status to ServiceNow state
        if (fn_status == 'assigned') {
            gr.state = 2; // In Progress
        } else if (fn_status == 'work_done') {
            gr.state = 4; // Resolved
        }
        
        // Add work note
        gr.work_notes = 'Field Nation work order ' + fn_wo_id + ' status: ' + fn_status;
        gr.update();
        
        response.setStatus(200);
        response.setBody({success: true});
    } else {
        response.setStatus(404);
        response.setBody({error: 'Record not found'});
    }
    
})(request, response);
```

---

## Production Deployment

### Pre-Launch Checklist

- ☐ Tested in sub-production instance
- ☐ All field mappings validated
- ☐ Error handling tested
- ☐ Business Rule conditions finalized
- ☐ Team training completed
- ☐ Documentation updated

### Deployment via Update Set

### Create Update Set

1. Navigate to **System Update Sets → Local Update Sets**
2. Click **New**
3. Name: "Field Nation Integration"
4. Capture changes:
   - REST Message
   - HTTP Method
   - Business Rule
   - Custom fields (if created)

### Export Update Set

1. Mark Update Set complete
2. Export XML
3. Save file securely

### Import to Production

1. Navigate to **Retrieved Update Sets**
2. Click **Import Update Set from XML**
3. Upload file
4. Preview Update Set
5. Resolve conflicts
6. Commit Update Set

### Update Field Nation Configuration

Switch Field Nation from Sandbox to Production:
- Update credentials (production ServiceNow)
- Update instance URL
- Test connection
- Copy new trigger URL
- Update REST Message endpoint in Production ServiceNow

---

## Monitoring & Maintenance

### Regular Tasks

**Daily:**
- Check System Logs for errors
- Monitor Business Rule execution count
- Review failed REST Messages

**Weekly:**
- Test sample sync
- Review field mappings
- Check ServiceNow API usage

**Monthly:**
- Update credentials (if not OAuth)
- Review and optimize Business Rule conditions
- Audit integration usage

---

---

### undefined
URL: /docs/connectors/platforms/smartsheet/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/smartsheet/configuration
Source: content/docs/connectors/platforms/smartsheet/configuration.mdx

---
title: Configuration
description: Configure the Smartsheet connector in Field Nation with access token and column mappings.
---

## Prerequisites

- ☐ Smartsheet Access Token
- ☐ Sheet ID
- ☐ Sheet admin access
- ☐ Admin access to Field Nation

---

## Step 1: Generate Smartsheet Access Token

### Log into Smartsheet

Use admin or dedicated integration user

### Navigate to API Settings

Click profile icon → Apps & Integrations → API Access

### Generate Token

Click "Generate new access token"

**Token Name**: `Field Nation Integration`

**Copy token immediately** (shown once!)

---

## Step 2: Get Sheet ID

### Open Your Sheet

Navigate to the Smartsheet you want to integrate

### Find Sheet ID

**Method 1**: URL
```
https://app.smartsheet.com/sheets/{sheet_id}
```

**Method 2**: Sheet Properties
File → Properties → Sheet ID

Example: `1234567890123456`

---

## Step 3: Configure in Field Nation

Access Integration Broker → Select "Smartsheet"

### Access Token

Paste access token from Step 1

**Authentication:**
```
Bearer {your_access_token}
```

---

### Sheet ID

Enter Sheet ID from Step 2

Example: `1234567890123456`

---

## Step 4: Test Connection

Click "Test Connection"

**Success** ✅: Token valid, sheet accessible

**Failure** ❌: Check:

  
    - Verify token copied correctly
    - Ensure token not revoked
    - Check token user has sheet access
  
  
  
    - Verify Sheet ID correct
    - Ensure sheet shared with token user
    - Check sheet not deleted
  
  
  
    - Share sheet with integration user
    - Grant "Admin" or "Editor" access
    - Verify user can edit sheet
  

---

## Step 5: Refresh Columns & Map

Click "Refresh Columns" → Smartsheet API queries sheet schema

**Inbound Mappings:**
```
Task Name → title
Description → description
Status → status_id (Array Map)
Customer → location.company.name
Due Date → schedule.start (Date Convert)
```

**Column Names**: Smartsheet uses column names (e.g., "Task Name", "Status")

**Outbound Mappings:**
```
status.name → Status (Array Map)
completion_notes → Notes
completion_date → Completed Date (Date Convert)
```

**Status Mapping:**
```
Smartsheet: Not Started, In Progress, Complete
Field Nation: Draft, Assigned, Work Done, Approved
```

[Field mapping guide →](/docs/connectors/concepts/field-mappings)

---

## Step 6: Save Configuration

Review → Save → Copy trigger URL for webhook setup

---

## Troubleshooting

  
    - Verify token has sheet access
    - Check Sheet ID correct
    - Try "Refresh Columns" again
    - Ensure sheet has columns
  
  
  
    - Check column names exact match
    - Verify data type compatibility
    - Use proper transformation actions
    - Test with sample row
  

---

---

### undefined
URL: /docs/connectors/platforms/smartsheet/overview

# Connectors: undefined
URL: /docs/connectors/platforms/smartsheet/overview
Source: content/docs/connectors/platforms/smartsheet/overview.mdx

---
title: Smartsheet Connector
description: Integrate Smartsheet project management with Field Nation for automated work order creation and task synchronization.
---

## Overview

The Smartsheet connector enables seamless integration between Smartsheet and Field Nation:
- **Row-based dispatch**: Create work orders from Smartsheet rows
- **REST API integration**: Modern JSON API with access tokens
- **Webhook triggers**: Real-time notifications via Smartsheet webhooks
- **Bidirectional sync**: Status and completion data flow both directions
- **Column mapping**: Map any Smartsheet column to Field Nation fields

---

## At a Glance

  
    Access Token (OAuth or API Token)
  
  
    Sheet rows
  
  
    Smartsheet Webhooks
  
  
    Bidirectional (create, update)
  

---

## How It Works

### Configure Webhook

Create webhook in Smartsheet that monitors row changes

### Webhook Fires

Smartsheet sends row ID when conditions met (new row, status change)

### Fetch Row Data

Integration Broker retrieves complete row from Smartsheet REST API

### Apply Mappings

Transform Smartsheet row into Field Nation work order

### Create Work Order

Work order created with correlation ID for bidirectional sync

---

## Common Use Cases

### Task-Based Dispatch

```
Sheet: Field Service Tasks
Trigger: Status = "Ready for Field"
  → Work order created
```

### Project Tracking

```
Sheet: Project Milestones
Trigger: New row with Type = "On-Site"
  → Field technician dispatched
```

### Status Synchronization

```
FN Work Order = "Completed"
  → Smartsheet Row Status = "Complete"
  → Completion date updated
```

---

## Features

### Field Mapping Capabilities

- **All Column Types**: Text, date, dropdown, contact, checkbox, symbols
- **Multi-select dropdowns**: Handle comma-separated values
- **Attachments**: Optional file sync
- **Hierarchical rows**: Parent/child relationships
- **Formulas**: Access calculated column values (read-only)

### Supported Operations

---

## Prerequisites

### Smartsheet Requirements

  
    Generate in Smartsheet:
    1. Account (profile icon) → Apps & Integrations
    2. API Access → Generate new access token
    3. Name: "Field Nation Integration"
    4. Copy token (shown once)
  
  
  
    - Admin or owner access to sheet
    - Ability to create webhooks
    - Share sheet with integration user
  
  
  
    - Read access to all columns
    - Write access for status updates
    - Create/manage webhooks
  

---

## Authentication

Smartsheet uses **Access Token** (Bearer token):

```
Authorization: Bearer {access_token}
```

**Generate Token:**
1. Smartsheet → Account → Apps & Integrations
2. API Access → Generate new access token
3. Copy immediately (shown once)

> **Security**: Access tokens inherit user permissions. Use dedicated integration account with minimum required access.

---

## Best Practices

- ✅ Use dedicated integration user
- ✅ Test in copy of production sheet first
- ✅ Use dropdown columns for status (easier mapping)
- ✅ Add "Synced to FN" checkbox column
- ✅ Monitor API usage limits

---

## Limitations

- API rate limit: 300 requests/minute
- Webhooks fire on any change (may need filtering)
- Formula columns are read-only
- Limited to single sheet per connector instance

---

---

### undefined
URL: /docs/connectors/platforms/smartsheet/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/smartsheet/workflow
Source: content/docs/connectors/platforms/smartsheet/workflow.mdx

---
title: Workflow Setup
description: Configure Smartsheet webhooks to trigger Field Nation work order creation when rows are added or updated.
---

## Prerequisites

- ☐ [Field Nation configuration complete](/docs/connectors/platforms/smartsheet/configuration)
- ☐ Trigger URL copied
- ☐ Smartsheet sheet admin access
- ☐ Ability to create webhooks

---

## Configure Webhook in Smartsheet

> [INFO] Smartsheet webhooks are created via **API** (no UI). You can use Postman, curl, or custom scripts.

### Using Smartsheet API

### Create Webhook via API

**Endpoint:**
```
POST https://api.smartsheet.com/2.0/webhooks
```

**Headers:**
```
Authorization: Bearer {your_access_token}
Content-Type: application/json
```

**Body:**
```json
{
  "name": "Field Nation Integration",
  "callbackUrl": "https://api.fieldnation.com/integrations/trigger/{YOUR_CLIENT_TOKEN}",
  "scope": "sheet",
  "scopeObjectId": {sheet_id},
  "events": [
    "row.added",
    "row.updated"
  ],
  "version": 1
}
```

### Example curl Command

```bash
curl -X POST https://api.smartsheet.com/2.0/webhooks \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Field Nation Integration",
    "callbackUrl": "https://api.fieldnation.com/integrations/trigger/YOUR_CLIENT_TOKEN",
    "scope": "sheet",
    "scopeObjectId": 1234567890123456,
    "events": ["row.added", "row.updated"],
    "version": 1
  }'
```

### Enable Webhook

After creation, enable it:

```bash
curl -X PUT https://api.smartsheet.com/2.0/webhooks/{webhook_id} \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"enabled": true}'
```

---

## Alternative: Using Smartsheet API via Postman

### Import Smartsheet Collection

Download Smartsheet Postman collection from [Smartsheet API docs](https://smartsheet.redoc.ly/)

### Set Environment Variables

- `access_token`: Your access token
- `sheet_id`: Your sheet ID
- `callback_url`: Field Nation trigger URL

### Create Webhook

Use "Create Webhook" request from collection

### Enable Webhook

Use "Update Webhook" request with `enabled: true`

---

## Verify Webhook

### List Webhooks

```bash
curl https://api.smartsheet.com/2.0/webhooks \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

Look for your webhook with `enabled: true` and `status: ENABLED`

---

## Test Integration

### Add Test Row

1. Open Smartsheet
2. Add new row
3. Fill required columns
4. Save

### Verify Webhook

Check webhook status via API:
```bash
curl https://api.smartsheet.com/2.0/webhooks/{webhook_id} \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Check Field Nation

Verify work order created with correct data

---

## Advanced Configuration

### Filter Rows

Since Smartsheet webhooks fire on all changes, implement filtering:

**Option 1**: Add "Status" column
```
Only process rows where Status = "Ready for Field"
```

**Option 2**: Add "Send to FN" checkbox
```
Only process rows where checkbox is checked
```

Configure filtering in Field Nation Integration Broker (custom JSONNET).

---

### Prevent Duplicate Sends

Add checkbox column: "Synced to FN"

When work order created, Field Nation updates row:
```
Synced to FN = checked
```

Integration Broker filters out rows where "Synced to FN" = checked.

---

## Troubleshooting

  
    - Verify access token has create webhook permission
    - Check Sheet ID correct
    - Ensure callback URL accessible
    - Review API error response
  
  
  
    - Verify webhook enabled: `enabled: true`
    - Check webhook status: `status: ENABLED`
    - Review Smartsheet API logs
    - Test with simple row add/update
  
  
  
    - Check Field Nation credentials valid
    - Verify all required fields mapped
    - Review Integration Broker logs
    - Test with minimal row data
  
  
  
    - Webhooks fire on ANY change
    - Add filtering logic
    - Use "Synced to FN" checkbox
    - Implement idempotency in Field Nation
  

---

## Webhook Management

### List All Webhooks

```bash
curl https://api.smartsheet.com/2.0/webhooks \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Get Webhook Details

```bash
curl https://api.smartsheet.com/2.0/webhooks/{webhook_id} \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Disable Webhook

```bash
curl -X PUT https://api.smartsheet.com/2.0/webhooks/{webhook_id} \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"enabled": false}'
```

### Delete Webhook

```bash
curl -X DELETE https://api.smartsheet.com/2.0/webhooks/{webhook_id} \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

---

---

### undefined
URL: /docs/connectors/platforms/autotask/configuration

# Connectors: undefined
URL: /docs/connectors/platforms/autotask/configuration
Source: content/docs/connectors/platforms/autotask/configuration.mdx

---
title: Configuration
description: Configure the Autotask connector in Field Nation's Integration Broker with SOAP API credentials and field mappings.
---

## Prerequisites Checklist

Before starting, gather:

- ☐ Autotask username (API user email)
- ☐ Autotask password
- ☐ Integration Code (generated in Autotask)
- ☐ Security Token (generated in Autotask)
- ☐ Autotask instance URL
- ☐ Admin access to Field Nation integrations

---

## Step 1: Generate Autotask API Credentials

### Log into Autotask

Use admin account

### Navigate to API User

Admin → Resources (Users) → Select API user (or create new)

### Generate Integration Code

**API Integration** section → Click "Generate API Integration Code"

**Copy the code** - You'll need this for Field Nation

### Generate Security Token

Same section → "Generate API Security Token" (if not already exists)

**Copy the token** - Required for authentication

### Note User Credentials

- Username (email): API user's email address
- Password: User's password

> [INFO] **Integration Code**: Unique per integration. Generate new code for Field Nation (don't reuse from other integrations).

---

## Step 2: Access Integration Broker

Navigate to Field Nation's Integration Broker:

**Sandbox**: [ui-sandbox.fndev.net/integrations](https://ui-sandbox.fndev.net/integrations)  
**Production**: [app.fieldnation.com/integrations](https://app.fieldnation.com/integrations)

Select "Autotask" from available connectors

---

## Step 3: Basic Settings

### Instance Name

**Optional** - Descriptive name for this integration

**Examples:**
- "Production Autotask"
- "Autotask PSA - Main"
- "Datto PSA Sandbox"

---

### Instance URL

**Required** - Your Autotask instance URL

**Format:**
```
https://webservices{X}.autotask.net/atservices/1.6/atws.asmx
```

Where `{X}` is your zone number (1-20)

**Find Your Zone:**
1. Log into Autotask
2. Check browser URL: `https://ww{X}.autotask.net`
3. Use that zone number in API URL

**Examples:**
- Zone 5: `https://webservices5.autotask.net/atservices/1.6/atws.asmx`
- Zone 12: `https://webservices12.autotask.net/atservices/1.6/atws.asmx`

---

### Entity Type

**Required** - Autotask entity to integrate

**Supported:**
- `Ticket` - Service tickets (most common)
- `ServiceCall` - Service call records
- `Project` - Project tasks requiring field work

**Format**: Use exact entity name (case-sensitive)

---

## Step 4: Authentication

Enter SOAP API credentials:

**Username**  
API user's email address  
Example: `integration@company.com`

**Password**  
User's Autotask password

**Integration Code**  
Generated tracking identifier from Step 1

**Security Token**  
API authentication token from Step 1

---

## Step 5: Test Connection

### Click "Test Connection"

Button in configuration form

### Broker Validates

- Authenticates with Autotask SOAP API
- Queries entity metadata
- Verifies permissions

### Review Result

**Success**: ✅ Green confirmation
- Connection established
- Authentication valid
- Entity accessible

**Failure**: ❌ Error message
- Check credentials
- Verify zone number correct
- Ensure API user has permissions

### Common Authentication Errors

  
    **Error**: Authentication failed
    
    **Causes:**
    - Wrong username or password
    - Integration Code incorrect
    - Security Token expired or wrong
    
    **Solution:**
    1. Verify credentials in Autotask
    2. Regenerate Integration Code if needed
    3. Regenerate Security Token if expired
    4. Test login to Autotask web interface
  
  
  
    **Error**: Cannot reach endpoint
    
    **Cause:** Incorrect zone in API URL
    
    **Solution:**
    1. Log into Autotask
    2. Check URL: `ww{X}.autotask.net`
    3. Update API URL to match zone
  
  
  
    **Error**: User does not have API access
    
    **Solution:**
    1. In Autotask Admin → Resources (Users)
    2. Select API user
    3. Security tab → Enable "API User"
    4. Security Level → Grant "API User (system)"
  
  
  
    **Error**: Entity type not accessible
    
    **Solution:**
    1. Verify entity name spelling (case-sensitive)
    2. Ensure API user has read access to entity
    3. Check entity exists in your Autotask instance
  

---

## Step 6: Get Trigger URL

Once authentication succeeds, Field Nation generates unique trigger URL:

**Format:**
```
https://api.fieldnation.com/integrations/trigger/{CLIENT_TOKEN}
```

**Copy this URL** - You'll configure it in Autotask webhook

> [INFO] **Security**: Client token authenticates incoming webhooks. Keep URL secure.

---

## Step 7: Refresh Fields

Discover available fields for mapping:

### Click "Refresh Fields"

Button in field mapping section

### Broker Queries Autotask

- Calls SOAP API GetFieldInfo
- Retrieves field definitions for entity
- Discovers User-Defined Fields

### Fields Populate

Dropdowns fill with:
- Standard fields (title, description, status)
- User-Defined Fields (UDF)
- Related entity fields (account, contact)
- Picklist values

---

## Step 8: Configure Field Mappings

Map data between Autotask and Field Nation:

### Inbound (Autotask → Field Nation)

**Example Mappings:**
```
Autotask Field                → FN Field                   Action
──────────────────────────────────────────────────────────────────
Title                        → title                      Sync
Description                  → description                Sync
AccountName                  → location.company.name      Sync
Status                       → status_id                  Array Map
Priority                     → priority                   Array Map
DueDateTime                  → schedule.start             Date Convert
AssignedResource.Email       → contact.email              Sync
UDF_TicketNumber            → custom_field_123           Sync
```

### Outbound (Field Nation → Autotask)

**Example Mappings:**
```
FN Field                     → Autotask Field             Action
──────────────────────────────────────────────────────────────────
status.name                  → Status                     Array Map
assignee.user.name           → UDF_Technician            Sync
completion_notes             → Resolution                 Sync
completion_date              → CompletedDate              Date Convert
```

### Status Mapping

**Autotask Status Values:**
- Varies by configuration
- Common: New, In Progress, Complete, Closed

**Field Nation Status IDs:**
```
1 = Draft
2 = Assigned
3 = Work Done
4 = Approved
5 = Paid
```

**Array Map Configuration:**
```jsonnet
{
  "source": "Status",
  "target": "status_id",
  "action": "array_map",
  "mappings": [
    { "compare": "New", "value": "1" },
    { "compare": "In Progress", "value": "2" },
    { "compare": "Complete", "value": "3" },
    { "compare": "Closed", "value": "4" }
  ],
  "default": "1"
}
```

[Complete field mapping guide →](/docs/connectors/concepts/field-mappings)

---

## Step 9: Save Configuration

### Review Settings

Verify:
- ☐ Instance URL correct (zone number)
- ☐ Entity type correct
- ☐ Authentication successful
- ☐ Fields refreshed
- ☐ Inbound mappings configured
- ☐ Outbound mappings configured

### Save

Click "Save" to persist configuration

### Note Trigger URL

Copy trigger URL for Autotask webhook setup

---

## Configuration Checklist

### Field Nation Configuration
- ☐ Instance name configured
- ☐ Instance URL with correct zone
- ☐ Entity type specified
- ☐ Credentials entered (username, password, integration code, token)
- ☐ Connection tested successfully
- ☐ Trigger URL copied
- ☐ Fields refreshed
- ☐ Inbound field mappings configured
- ☐ Outbound field mappings configured
- ☐ Configuration saved

### Autotask Configuration (Next Steps)
- ☐ Webhook configured
- ☐ Trigger conditions defined
- ☐ Webhook tested with sample ticket

[Autotask workflow setup →](/docs/connectors/platforms/autotask/workflow)

---

## Troubleshooting

  
    **Issue**: Expected fields not in dropdown
    
    **Solution:**
    1. Click "Refresh Fields" again
    2. Verify API user has field-level read permissions
    3. For UDFs, ensure they're defined on entity
    4. Check field API names in Autotask Admin
  
  
  
    **Issue**: Integration stops working
    
    **Solution:**
    1. Check if Security Token regenerated
    2. Verify API user still active
    3. Test credentials in Autotask
    4. Reconnect in Field Nation
  
  
  
    **Issue**: Cannot save mappings
    
    **Solution:**
    1. Ensure all required FN fields mapped
    2. Check data type compatibility
    3. Add default values for optional fields
    4. Review error messages for specific issues
  

---

---

### undefined
URL: /docs/connectors/platforms/autotask/overview

# Connectors: undefined
URL: /docs/connectors/platforms/autotask/overview
Source: content/docs/connectors/platforms/autotask/overview.mdx

---
title: Autotask Connector
description: Integrate Datto Autotask PSA with Field Nation for automated field service dispatch from service tickets and work orders.
---

## Overview

The Autotask connector enables seamless integration between Datto Autotask PSA and Field Nation:
- **Ticket-based dispatch**: Automatically create work orders from Autotask Tickets
- **SOAP API integration**: Secure authentication via token-based SOAP calls
- **Bidirectional sync**: Status updates flow both directions
- **Flexible triggers**: Configure based on ticket status, type, or custom fields
- **UDF support**: Map User-Defined Fields between systems

---

## At a Glance

  
    API Integration Token + SOAP Credentials
  
  
    Tickets, Service Calls, Projects
  
  
    Webhooks + API Polling (configurable)
  
  
    Bidirectional (create, update, notes)
  

---

## How It Works

### Configure Webhook

Set up webhook in Autotask that triggers on ticket status changes or custom field updates

### Webhook Notification

Autotask sends ticket ID to Field Nation when trigger conditions met

### Field Nation Fetches Data

Integration Broker retrieves complete ticket data from Autotask SOAP API

### Apply Mappings

Broker transforms Autotask ticket data into Field Nation work order format

### Create Work Order

Work order created in Field Nation with correlation ID stored for bidirectional sync

---

## Common Use Cases

### Dispatch from Service Ticket

Automatically create Field Nation work order when Autotask Ticket requires on-site service

```
Ticket Status = "Dispatch to Field" 
  → Webhook triggers 
  → Field Nation Work Order Created
```

### Project-Based Dispatch

Create work orders from Autotask Project tasks requiring field technicians

```
Project Task Type = "On-Site"
AND Task Status = "Ready"
  → Work order created
  → Task updated with FN details
```

### Status Synchronization

Reflect Field Nation work order completion back to Autotask Ticket

```
FN Work Order = "Completed"
  → Integration Broker
  → Autotask Ticket Status = "Complete - Customer Notified"
  → Internal Notes updated
```

---

## Architecture

```mermaid
sequenceDiagram
    participant AT as Autotask
    participant WH as Webhook
    participant Broker as Integration Broker
    participant FN as Field Nation
    
    AT->>WH: Ticket Status Changed
    WH->>Broker: POST Trigger URL (Ticket ID)
    Broker->>AT: SOAP API Call (Get Ticket)
    AT-->>Broker: Ticket Data + UDFs
    Broker->>Broker: Apply Field Mappings
    Broker->>FN: Create/Update Work Order
    FN-->>Broker: Success + WO ID
    Broker->>AT: Update Ticket (optional)
```

---

## Features

### Field Mapping Capabilities

- **Standard Fields**: Title, Description, Status, Priority, Due Date
- **User-Defined Fields**: Access any UDF on Ticket entity
- **Related Entities**: Account, Contact, Resource (assigned technician)
- **Picklist Fields**: Map Autotask picklists to Field Nation enums
- **Date/Time Fields**: Automatic timezone conversion

### Supported Operations

---

## Prerequisites

### Autotask Requirements

  
    - Autotask PSA license with API access enabled
    - Admin or API-enabled user account
    - SOAP API credentials generated
    - Integration tracking identifier configured
  
  
  
    Generate in Autotask:
    1. Navigate to Admin → Resources (Users)
    2. Select API user
    3. Generate API Integration Code
    4. Generate API Security Token
    5. Copy both for Field Nation configuration
  
  
  
    - Ability to configure Autotask webhooks
    - Webhook endpoint URL from Field Nation
    - Network access to send webhooks
    - Optional: IP whitelisting for Field Nation
  
  
  
    API user must have:
    - Read access to Ticket entity and all fields to sync
    - Write access to fields for status/note updates
    - Access to related entities (Account, Contact, Resource)
    - Permission to view User-Defined Fields
  

### Field Nation Requirements

- Active buyer account with admin access
- Integration settings access
- Sandbox environment (recommended for testing)

[Complete prerequisites →](/docs/connectors/getting-started)

---

## Authentication

Autotask connector uses **SOAP API with Token Authentication**:

```
Username: API user email
Password: API user password
Integration Code: {integration_code}
Security Token: {security_token}
```

**Components:**
- **Username**: Autotask user email with API access
- **Password**: User's password
- **Integration Code**: Generated tracking identifier
- **Security Token**: API authentication token

**Generate Credentials:**
1. Log into Autotask as admin
2. Admin → Resources (Users) → Select API user
3. API Integration section → Generate Integration Code
4. Generate Security Token (if not already generated)
5. Copy all credentials for Field Nation configuration

> **Security Best Practice**: Use dedicated API user (not personal account). Integration Code is unique per integration - generate new code for Field Nation.

---

## Data Flow Patterns

### Inbound: Autotask → Field Nation

**Trigger**: Webhook fired on ticket status change  
**Action**: Webhook sends Ticket ID to Field Nation  
**Result**: Field Nation work order created/updated

**Example Webhook Triggers:**
- Ticket Status = "Dispatch to Field"
- Custom UDF "Send to FN" = Yes
- Issue Type = "On-Site Required"
- Queue = "Field Services"

---

### Outbound: Field Nation → Autotask

**Trigger**: Field Nation work order event (completed, etc.)  
**Action**: Integration Broker calls Autotask SOAP API  
**Result**: Autotask Ticket updated with status/notes

**Configurable Events:**
- Work order assigned → Update Ticket Status
- Work order completed → Add Internal Note with details
- Provider checked in → Update custom UDF
- Work order approved → Update Status to "Complete"

---

## Best Practices

### Webhook Design

- ✅ Use specific status values (not "any change")
- ✅ Configure webhook for relevant ticket types only
- ✅ Add safeguards to prevent duplicate triggers
- ✅ Test in sandbox Autotask instance first
- ✅ Monitor webhook delivery logs

### Field Mappings

- ✅ Map all required Field Nation fields
- ✅ Use User-Defined Fields for custom data
- ✅ Handle Autotask picklists with Array Map
- ✅ Test timezone conversions for date fields
- ✅ Document UDF IDs and purposes

### Security

- ✅ Use dedicated API user
- ✅ Rotate Security Token periodically
- ✅ Grant minimum required permissions
- ✅ Monitor API usage limits
- ✅ Enable IP whitelisting if policy requires

---

## Limitations & Considerations

### API Limits

Autotask enforces API call limits:
- Varies by license type and contract
- Monitor usage in Autotask Admin → API Usage

Each work order sync consumes **2-3 API calls** (authentication + data retrieval + optional update).

### SOAP API Complexity

- SOAP-based (not REST) - more complex than modern APIs
- XML payload parsing required
- Field discovery may require manual configuration
- Some fields may not be accessible via API

### Related Entity Depth

Can access:
- ✅ Fields on Ticket entity
- ✅ Fields from related Account, Contact, Resource
- ❌ Grand-parent relationships (requires custom JSONNET)

---

---

### undefined
URL: /docs/connectors/platforms/autotask/workflow

# Connectors: undefined
URL: /docs/connectors/platforms/autotask/workflow
Source: content/docs/connectors/platforms/autotask/workflow.mdx

---
title: Workflow Setup
description: Configure Autotask webhooks to automatically send ticket data to Field Nation when trigger conditions are met.
---

## Prerequisites

- ☐ Completed [Field Nation configuration](/docs/connectors/platforms/autotask/configuration)
- ☐ Field Nation trigger URL copied
- ☐ Autotask admin access
- ☐ Webhook configuration permissions

---

## Workflow Overview

```mermaid
graph LR
    A[Ticket Created/Updated] --> B{Webhook<br/>Conditions Met?}
    B -->|Yes| C[Send to Field Nation]
    C --> D[Work Order Created]
    B -->|No| E[No Action]
```

**Webhook**: Monitors tickets and evaluates conditions  
**Trigger URL**: Destination for webhook notifications  
**Field Nation**: Fetches ticket data and creates work order

---

## Step 1: Configure Webhook in Autotask

### Navigate to Webhooks

Autotask → Admin → Webhooks

### Create New Webhook

Click **"New Webhook"** or **"Add Webhook"**

### Configure Webhook Settings

**Name**: `Field Nation Integration`

**Entity**: Select entity type (e.g., `Ticket`)

**Webhook URL**: Paste Field Nation trigger URL
```
https://api.fieldnation.com/integrations/trigger/{YOUR_CLIENT_TOKEN}
```

**HTTP Method**: `POST`

**Content Type**: `application/json`

---

## Step 2: Define Trigger Conditions

Configure when webhook fires:

### Event Types

Select events that should trigger:
- ☑ **Create** - New tickets
- ☑ **Update** - Ticket changes
- ☐ **Delete** - Usually not needed

---

### Filter Conditions

**Option 1: Status-Based**
```
Status = "Dispatch to Field"
```

**Option 2: Custom Field**
```
UDF "Send to Field Nation" = Yes
```

**Option 3: Queue-Based**
```
Queue Name = "Field Services"
AND Priority IN (Critical, High)
```

**Option 4: Issue Type**
```
Issue Type = "On-Site Required"
AND Status != "Cancelled"
```

---

### Webhook Payload

Configure what data to send:

**Minimal Payload (Recommended):**
```json
{
  "ticketId": "{TicketID}",
  "entityType": "Ticket",
  "action": "{Action}"
}
```

Field Nation will fetch complete ticket data via SOAP API.

**Why minimal?**
- Reduces payload size
- Ensures latest data (fetched at processing time)
- Prevents stale data issues

---

## Step 3: Test Webhook

### Create Test Ticket

1. Navigate to Autotask Tickets
2. Create new ticket
3. Fill required fields
4. Set conditions to trigger webhook
5. Save ticket

### Verify Webhook Fired

Check Autotask Admin → Webhooks → Delivery Log:
- Look for webhook execution
- Verify 200 OK response
- Check payload sent

### Verify in Field Nation

1. Log into Field Nation
2. Navigate to Work Orders
3. Find newly created work order
4. Verify field values correct

---

## Troubleshooting

  
    **Check:**
    - ☐ Webhook active/enabled
    - ☐ Ticket meets filter conditions
    - ☐ Event types selected correctly
    - ☐ Webhook URL correct
    
    **Debug:**
    - Check Autotask webhook delivery log
    - Test with simple ticket (minimal fields)
    - Review filter conditions (test individually)
  
  
  
    **Check:**
    - ☐ Field Nation configuration complete
    - ☐ Credentials valid
    - ☐ All required FN fields mapped
    - ☐ SOAP API accessible from Field Nation
    
    **Debug:**
    1. Check Integration Broker logs in Field Nation
    2. Look for incoming webhook
    3. Review SOAP API call results
    4. Check field mapping errors
  
  
  
    **Cause:** Webhook triggering multiple times
    
    **Solutions:**
    1. Add sync status UDF to Autotask Ticket
    2. Update UDF after first send (prevent re-trigger)
    3. Use "Create" event only (not "Update")
    4. Add filter: UDF "Synced to FN" != Yes
  
  
  
    **Check:**
    - ☐ Field mappings configured correctly
    - ☐ Data types compatible
    - ☐ Picklist values mapped (Array Map)
    - ☐ Date formats compatible
    
    **Solution:**
    - Review Field Nation field mappings
    - Test with minimal data first
    - Add transformations as needed
  

---

## Advanced Configurations

### Prevent Duplicate Sends

Add tracking UDF to Autotask Tickets:

### Create UDF

Autotask → Admin → User Defined Fields → Ticket

**Field Name**: "FN Sync Status"  
**Type**: Text or Picklist  
**Values**: Not Sent, Sent, Synced

### Update Webhook Filter

Add condition:
```
FN Sync Status != "Sent"
AND FN Sync Status != "Synced"
```

### Update After Sync

Configure outbound mapping to set:
```
FN Sync Status = "Sent" (after successful creation)
```

---

### Multiple Webhooks for Different Scenarios

**Webhook 1**: Urgent Tickets
```
Priority = Critical
Status = New
→ Immediate dispatch
```

**Webhook 2**: Standard Tickets
```
Status = "Dispatch to Field"
Priority != Critical
→ Normal dispatch
```

**Webhook 3**: Project Tasks
```
Entity = Project
Task Type = "On-Site"
→ Project-based dispatch
```

---

### Bidirectional Sync

Update Autotask when Field Nation changes:

**Field Nation Event** → **Autotask Action**

- Work order assigned → Update Ticket Status
- Work order completed → Add Internal Note
- Completion approved → Update Status to "Complete"

Configured in Field Nation's event trigger settings.

---

## Production Deployment

### Pre-Launch Checklist

- ☐ Tested in Autotask sandbox
- ☐ All field mappings validated
- ☐ Error handling tested
- ☐ Webhook conditions finalized
- ☐ Team training completed
- ☐ Documentation updated

### Launch Steps

### Export Webhook Config

Save webhook configuration details

### Configure Production

1. Access production Autotask
2. Create webhook (same settings)
3. Update Field Nation to production
4. Test with sample ticket

### Monitor Closely

Watch first few synchronizations:
- Check webhook delivery log
- Review work order data
- Verify bidirectional sync

---

## Monitoring & Maintenance

### Regular Tasks

**Daily:**
- Check webhook delivery log for errors
- Monitor work order creation rate
- Review failed webhooks

**Weekly:**
- Test sample synchronization
- Review field mappings
- Check Autotask API usage

**Monthly:**
- Rotate Security Token (Field Nation config)
- Review and optimize webhook conditions
- Audit integration usage

---

---

## Resources (5)

### undefined
URL: /docs/resources/environments

# Resources: undefined
URL: /docs/resources/environments
Source: content/docs/resources/environments.mdx

---
title: Environments
description: Understand Sandbox and Production environments, access URLs, testing strategies, and migration best practices.
icon: Server
---

## Environment Overview

## Sandbox Environment

A complete test environment that mirrors production functionality without affecting live data or operations.

### Access URLs

### Purpose

- **Development** - Build and iterate on your integration
- **Testing** - Test all functionality without risk
- **Training** - Learn the platform and API
- **Staging** - Final validation before production

### Key Characteristics

- ✅ Identical features to production
- ✅ Separate database (no live data)
- ✅ Test work orders and providers
- ✅ No real payments processed
- ✅ Safe for experimentation
- ✅ API credentials separate from production

> [INFO] **Access Required**: Request sandbox access through a [support case](https://app.fieldnation.com/support-cases) with your Company ID and integration requirements.

### Webhook IP Addresses (Sandbox)

Whitelist these IPs if your webhook endpoint uses IP filtering:

```
18.215.51.196
3.223.100.250
44.199.193.222
```

[Security Guide →](/docs/webhooks/guides/security)

## Production Environment

The live Field Nation platform where real work orders, payments, and operations occur.

### Access URLs

### Purpose

- **Live Operations** - Real work orders and payments
- **Customer Facing** - Actual business operations
- **Performance Critical** - Must be reliable and tested

### Key Characteristics

- ⚠️ Real data and operations
- ⚠️ Actual payments processed
- ⚠️ Affects live work orders
- ⚠️ Requires thorough testing first
- ⚠️ Separate API credentials required
- ⚠️ Change control recommended

> **Production Access**: Requires approval and thorough testing in sandbox first. Contact Field Nation support to request production API credentials.

### Webhook IP Addresses (Production)

Contact Field Nation support for production webhook IP addresses to whitelist.

---

## Environment Comparison

| Feature | Sandbox | Production |
|---------|---------|------------|
| **Purpose** | Development & Testing | Live Operations |
| **Data** | Test data only | Real customer data |
| **Payments** | No real payments | Real payments processed |
| **Work Orders** | Test work orders | Live work orders |
| **API Credentials** | Sandbox-specific | Production-specific |
| **Availability** | On request | Requires approval |
| **Error Impact** | No real impact | Affects operations |
| **Testing** | Encouraged | After sandbox validation |

---

## Getting Access

### Sandbox Access

### Submit Support Case

Submit a [support case](https://app.fieldnation.com/support-cases) with:

```
Subject: Sandbox Access Request

Company ID: [Your Company ID]
Company Name: [Your Company Name]
Integration Type: [REST API / Webhooks / Connector]
Purpose: [Development and testing of integration]

Technical Contact:
Name: [Name]
Email: [Email]
Phone: [Phone]
```

### Receive Credentials

Field Nation team will:
- Provision sandbox account
- Provide access credentials
- Share sandbox Company ID

### Begin Development

Log in to sandbox and start building:
- Create test work orders
- Configure webhooks
- Test API integrations

---

### Production Access

### Complete Sandbox Testing

Ensure your integration:
- ✅ Passes all test scenarios
- ✅ Handles errors gracefully
- ✅ Implements proper security
- ✅ Meets performance requirements

### Submit Production Request

Submit a [support case](https://app.fieldnation.com/support-cases):

```
Subject: Production API Access Request

Company ID: [Your Production Company ID]
Company Name: [Your Company Name]
Integration Type: [REST API / Webhooks / Connector]

Sandbox Testing Complete:
- Testing Duration: [X weeks/months]
- Test Scenarios: [List key scenarios tested]
- Issues Resolved: [Any issues found and fixed]

Production Use Case:
[Describe your production integration]

Expected Volume:
- Work Orders per day: [Estimate]
- API Requests per day: [Estimate]
- Webhooks per day: [Estimate]
```

### Receive Approval

Field Nation will:
- Review your request
- Verify sandbox testing
- Provide production credentials
- Assign support contact

### Deploy to Production

Follow deployment best practices:
- Use environment variables for credentials
- Monitor closely after deployment
- Have rollback plan ready

---

## Testing Strategy

### Development Phase (Sandbox)

**Goals:** Build core functionality

```mermaid
graph LR
    A[Local Dev] --> B[ngrok Tunnel]
    B --> C[Sandbox Webhooks]
    C --> D[Test Events]
    D --> E[Verify Handling]
```

**Best Practices:**
- Use ngrok or localtunnel for local testing
- Log all requests and responses
- Test individual endpoints first
- Verify signature validation

[Testing Guide →](/docs/webhooks/guides/testing)

---

### Integration Testing (Sandbox)

**Goals:** Validate end-to-end flows

### Create Test Scenarios

Define realistic workflows:
- Work order creation and publishing
- Provider assignment and acceptance
- Work completion and approval
- Payment processing

### Execute Test Cases

Run comprehensive tests:
- Happy path scenarios
- Error handling
- Edge cases
- Data validation

### Monitor Results

Track integration health:
- Webhook delivery success rate
- API response times
- Error rates and types
- Data accuracy

### Iterate and Improve

Based on results:
- Fix identified issues
- Optimize performance
- Enhance error handling
- Document learnings

---

### Staging Phase (Sandbox)

**Goals:** Production-like validation

**Staging Checklist:**

- ☐ All features implemented and tested
- ☐ Error handling comprehensive
- ☐ Security measures in place
- ☐ Performance meets requirements
- ☐ Monitoring and alerts configured
- ☐ Documentation complete
- ☐ Team trained on operations
- ☐ Rollback procedure defined

---

### Production Deployment

**Goals:** Safe, monitored launch

1. **Pre-Deployment**
   ```bash
   # Verify environment variables
   echo $FN_CLIENT_ID
   echo $FN_CLIENT_SECRET
   echo $FN_BASE_URL
   
   # Test connectivity
   curl https://api.fieldnation.com/health
   ```

2. **Deployment**
   - Deploy webhook endpoint
   - Create production webhooks
   - Enable API integration
   - Monitor initial traffic

3. **Post-Deployment**
   - Run smoke tests
   - Verify webhook deliveries
   - Check error logs
   - Monitor metrics

**Critical Metrics:**

```javascript
// Track these in production
const metrics = {
  // Webhook health
  webhookSuccessRate: '>99%',
  webhookLatency: '<2s p95',
  deliveryFailures: '<1%',
  
  // API health
  apiErrorRate: '<1%',
  apiLatency: '<500ms p95',
  
  // Business metrics
  workOrdersCreated: 'track daily',
  syncFailures: 'alert immediately'
};
```

**Set Up Alerts:**
- Webhook delivery failures
- High error rates
- Slow response times
- Authentication failures

[Monitoring Guide →](/docs/webhooks/guides/monitoring)

**If Issues Arise:**

1. **Immediate Actions**
   ```bash
   # Deactivate webhook
   curl -X PUT https://api.fieldnation.com/api/v1/webhooks/wh_prod \
     -H "Authorization: Bearer $TOKEN" \
     -d '{"status": "inactive"}'
   
   # Stop API calls
   # Revert to previous version
   ```

2. **Assess Impact**
   - How many work orders affected?
   - Any data loss or corruption?
   - Customer impact level?

3. **Fix and Redeploy**
   - Identify root cause
   - Fix in sandbox
   - Test thoroughly
   - Redeploy with monitoring

---

## Migration: Sandbox → Production

### Code Changes

```javascript
// ❌ Don't hardcode environments
const baseUrl = 'https://api-sandbox.fndev.net';

// ✅ Use environment variables
const baseUrl = process.env.FN_BASE_URL;

// ❌ Don't commit credentials
const clientId = 'sandbox_client_id';

// ✅ Use environment variables
const clientId = process.env.FN_CLIENT_ID;
```

### Configuration Files

```properties title=".env.sandbox"
FN_BASE_URL=https://api-sandbox.fndev.net
FN_CLIENT_ID=sandbox_client_id
FN_CLIENT_SECRET=sandbox_secret
FN_WEBHOOK_SECRET=sandbox_webhook_secret
```

```properties title=".env.production"
FN_BASE_URL=https://api.fieldnation.com
FN_CLIENT_ID=prod_client_id
FN_CLIENT_SECRET=prod_secret
FN_WEBHOOK_SECRET=prod_webhook_secret
```

### Deployment Checklist

- ☐ Environment variables configured
- ☐ Production credentials obtained
- ☐ Webhook endpoints updated
- ☐ IP whitelisting configured (if applicable)
- ☐ Monitoring and alerts active
- ☐ Error handling tested
- ☐ Team notified of deployment
- ☐ Rollback procedure ready

---

## Best Practices

### Do's ✅

- **Always test in sandbox first**
- Use separate credentials for each environment
- Implement environment-aware configuration
- Monitor production closely after deployment
- Keep sandbox and production code in sync
- Document environment-specific settings
- Test error scenarios in sandbox
- Have a rollback plan ready

### Don'ts ❌

- **Never test in production**
- Don't use sandbox credentials in production
- Don't skip sandbox testing phase
- Don't deploy without monitoring
- Don't mix sandbox and production data
- Don't hardcode environment URLs
- Don't deploy during peak hours
- Don't skip error handling

---

## Troubleshooting

### Wrong Environment

**Symptom**: API calls work in sandbox but fail in production

**Check:**
```javascript
console.log('Base URL:', process.env.FN_BASE_URL);
console.log('Client ID:', process.env.FN_CLIENT_ID.substring(0, 10) + '...');

// Verify you're calling correct environment
if (process.env.FN_BASE_URL.includes('sandbox')) {
  console.log('✅ Using SANDBOX');
} else {
  console.log('✅ Using PRODUCTION');
}
```

### Mixed Credentials

**Symptom**: Authentication fails unexpectedly

**Solution**: Verify credentials match environment
```bash
# Check which environment credentials are for
curl -X POST https://api-sandbox.fndev.net/authentication/api/oauth/token \
  -d "grant_type=client_credentials" \
  -d "client_id=$FN_CLIENT_ID" \
  -d "client_secret=$FN_CLIENT_SECRET"
```

---

---

### undefined
URL: /docs/resources/error-codes

# Resources: undefined
URL: /docs/resources/error-codes
Source: content/docs/resources/error-codes.mdx

---
title: Error Codes
description: Complete reference for HTTP status codes, error messages, and troubleshooting guidance for Field Nation API and webhook errors.
icon: CircleAlert
---

## HTTP Status Codes

### Success Codes (2xx)

**When you see these:** Your request was processed successfully. No action needed.

---

### Client Error Codes (4xx)

These indicate problems with your request that need to be fixed before retrying.

#### 400 Bad Request

**Meaning:** The request is malformed or contains invalid parameters.

**Common Causes:**
- Invalid JSON syntax
- Missing required fields
- Invalid data types (string instead of number)
- Malformed URLs or query parameters

**Example Error Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z",
    "path": "/api/v1/webhooks"
  },
  "errors": [
    {
      "code": 400,
      "message": "Invalid request: 'url' must be a valid HTTPS URL"
    }
  ],
  "result": {}
}
```

**Solution:**
- Validate JSON structure before sending
- Check all required fields are present
- Verify data types match API specification
- Review OpenAPI documentation for correct format

---

#### 401 Unauthorized

**Meaning:** Authentication failed or access token is invalid/expired.

**Common Causes:**
- Missing `Authorization` header
- Expired access token (tokens expire after 1 hour)
- Invalid client credentials
- Incorrect token format

**Example Error Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z"
  },
  "errors": [
    {
      "code": 401,
      "message": "Invalid or expired access token"
    }
  ],
  "result": {}
}
```

**Solution:**
- Generate a new access token using OAuth 2.0
- Ensure `Authorization: Bearer {token}` header is included
- Implement token refresh logic before expiry
- Verify client credentials are correct

---

#### 403 Forbidden

**Meaning:** Authentication succeeded but you don't have permission for this resource.

**Common Causes:**
- Insufficient permissions for the requested operation
- API user lacks required role or access level
- Attempting to access another company's resources

**Solution:**
- Verify your API user has appropriate permissions
- Contact Field Nation support to review access levels
- Ensure you're accessing resources within your company

---

#### 404 Not Found

**Meaning:** The requested resource doesn't exist.

**Common Causes:**
- Incorrect webhook ID, work order ID, or other identifier
- Resource was deleted
- Typo in endpoint URL
- Using wrong environment (Sandbox vs Production)

**Example:**

```bash
# Wrong webhook ID
GET /api/v1/webhooks/wh_invalid
# Returns 404

# Correct
GET /api/v1/webhooks/wh_abc123def456
```

**Solution:**
- Verify resource IDs are correct
- Check resource still exists
- Review endpoint URL for typos
- Confirm you're using the correct environment

---

#### 422 Unprocessable Entity

**Meaning:** Request is well-formed but contains semantic errors or fails validation.

**Common Causes:**
- Invalid field values (e.g., invalid email format)
- Business rule violations
- Conflicting data
- Unsupported event names

**Example Error Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z"
  },
  "errors": [
    {
      "code": 422,
      "message": "Validation failed: 'events' must contain at least one valid event name"
    }
  ],
  "result": {}
}
```

**Solution:**
- Review validation error messages
- Check field formats match requirements
- Verify all referenced resources exist
- Consult API documentation for field constraints

---

#### 429 Too Many Requests

**Meaning:** You've exceeded the API rate limit.

**Common Causes:**
- Making too many requests too quickly
- Not respecting rate limit headers
- Burst traffic exceeding limits

**Example Error Response:**

```json
{
  "metadata": {
    "timestamp": "2025-01-15T12:00:00Z"
  },
  "errors": [
    {
      "code": 429,
      "message": "Rate limit exceeded. Retry after 60 seconds."
    }
  ],
  "result": {}
}
```

**Response Headers:**

```http
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1642252800
```

**Solution:**
- Implement exponential backoff for retries
- Check `X-RateLimit-*` headers to track usage
- Wait until `X-RateLimit-Reset` timestamp before retrying
- Reduce request frequency or implement request queuing

---

### Server Error Codes (5xx)

These indicate problems on Field Nation's side. Implement retry logic for these errors.

#### 500 Internal Server Error

**Meaning:** An unexpected error occurred on Field Nation's servers.

**Common Causes:**
- Temporary server issues
- Unhandled edge cases
- Database connectivity problems

**Solution:**
- Retry the request after a short delay
- Implement exponential backoff (wait 1s, 2s, 4s, 8s...)
- If error persists, contact Field Nation support
- Include request details in support case

---

#### 502 Bad Gateway

**Meaning:** Field Nation's gateway received an invalid response from upstream server.

**Common Causes:**
- Temporary network issues
- Service deployment in progress
- Load balancer problems

**Solution:**
- Retry after a few seconds
- Check [status.fieldnation.com](https://status.fieldnation.com) for incidents
- If persistent, contact support

---

#### 503 Service Unavailable

**Meaning:** Service is temporarily unavailable, usually due to maintenance or overload.

**Common Causes:**
- Scheduled maintenance
- System overload
- Service restart

**Solution:**
- Check `Retry-After` header if present
- Wait and retry after a delay
- Monitor [status.fieldnation.com](https://status.fieldnation.com)
- If extended, contact support

---

#### 504 Gateway Timeout

**Meaning:** Field Nation's gateway didn't receive a response in time.

**Common Causes:**
- Large payload processing
- Slow database queries
- Network latency

**Solution:**
- Retry the request
- If creating/updating large resources, break into smaller operations
- Contact support if consistently occurring

---

## Webhook-Specific Errors

### Delivery Failures

| Error | Cause | Retry? | Solution |
|-------|-------|--------|----------|
| **Connection Refused** | Endpoint server not running | Yes | Start your server, verify port, check firewall |
| **DNS Resolution Failed** | Domain doesn't resolve | No | Fix DNS configuration, wait for propagation |
| **SSL Certificate Error** | Invalid/expired certificate | No | Renew certificate, use valid CA-signed cert |
| **Connection Timeout** | Endpoint too slow to respond | Yes | Optimize response time, use async processing |
| **Signature Verification Failed** | Wrong secret or body modified | No | Use correct secret, verify with raw body |

[Complete webhook troubleshooting →](/docs/webhooks/troubleshooting/delivery-failures)

---

## Integration-Specific Errors

### Connector Errors

**Authentication Failure:**
```
Error: OAuth token expired or invalid
```

**Solution:** Refresh connector authentication in Integration Broker settings.

**Field Mapping Error:**
```
Error: Required field 'external_id' is missing
```

**Solution:** Update field mappings to include all required fields.

**Data Type Mismatch:**
```
Error: Cannot convert 'text' to number for field 'priority'
```

**Solution:** Add data type conversion in field mapping or JSONNET transform.

---

## Error Handling Best Practices

### Implement Retry Logic

```javascript
async function apiRequestWithRetry(url, options, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      // Success
      if (response.ok) {
        return await response.json();
      }
      
      // Client errors - don't retry
      if (response.status >= 400 && response.status < 500) {
        const error = await response.json();
        throw new Error(`Client error: ${JSON.stringify(error.errors)}`);
      }
      
      // Server errors - retry with backoff
      if (response.status >= 500) {
        if (attempt === maxRetries) {
          throw new Error(`Max retries exceeded: ${response.status}`);
        }
        
        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
        console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
        await sleep(delay);
        continue;
      }
      
    } catch (error) {
      if (attempt === maxRetries) throw error;
      
      const delay = Math.pow(2, attempt) * 1000;
      await sleep(delay);
    }
  }
}
```

### Log Errors with Context

```javascript
function logError(error, context) {
  console.error('API Error:', {
    timestamp: new Date().toISOString(),
    error: error.message,
    stack: error.stack,
    statusCode: error.statusCode,
    requestUrl: context.url,
    requestMethod: context.method,
    requestBody: context.body,
    responseBody: context.response
  });
}
```

### Handle Different Error Types

```javascript
try {
  const response = await createWebhook(config);
} catch (error) {
  if (error.statusCode === 400) {
    // Validation error - fix request
    console.error('Invalid request:', error.message);
  } else if (error.statusCode === 401) {
    // Auth error - refresh token
    await refreshAccessToken();
    return await createWebhook(config);
  } else if (error.statusCode === 429) {
    // Rate limit - wait and retry
    await sleep(error.retryAfter * 1000);
    return await createWebhook(config);
  } else if (error.statusCode >= 500) {
    // Server error - retry with backoff
    return await retryWithBackoff(() => createWebhook(config));
  }
}
```

---

## Debugging Tools

### Check API Response

```bash
# Verbose curl output
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -v

# Save response headers
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -D headers.txt

# Follow redirects
curl -X GET https://api-sandbox.fndev.net/api/v1/webhooks \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -L
```

### Validate JSON Payload

```bash
# Validate JSON syntax
cat payload.json | jq .

# Pretty print
cat payload.json | jq '.'

# Extract specific field
cat payload.json | jq '.errors[0].message'
```

---

## Getting Help

If you encounter errors not covered here:

1. **Check System Status**: [status.fieldnation.com](https://status.fieldnation.com)
2. **Review Documentation**: Search for specific error messages
3. **Contact Support**: Submit a case with error details

[Support resources →](/docs/resources/support)

---

---

### undefined
URL: /docs/resources/faq

# Resources: undefined
URL: /docs/resources/faq
Source: content/docs/resources/faq.mdx

---
title: Frequently Asked Questions
description: Quick answers to common questions about Field Nation Integration including getting started, features, webhooks, and support.
icon: CircleQuestionMark
---

## Getting Started & Account Setup

### What do I need to get started with Field Nation integrations?

To begin integrating with Field Nation, you need:

1. **Active Buyer Account** - You must have an active buyer account in the Field Nation platform. Service companies and providers do not have access to API/integration features.
2. **Integration Contract** - Contact your Sales representative to discuss integration needs and establish an integration contract.
3. **Sandbox Access** - Request sandbox environment access for development and testing.
4. **API Credentials** - Obtain `client_id` and `client_secret` for authentication.

[Quickstart Guide →](/docs/getting-started/introduction)

---

### How do I get access to the Sandbox environment?

The Field Nation Sandbox environment is available at:

- **UI**: [https://app-sandbox.fndev.net/](https://app-sandbox.fndev.net/)
- **API**: [https://api-sandbox.fndev.net/](https://api-sandbox.fndev.net/)

To request sandbox access:

1. Submit a [support case](https://app.fieldnation.com/support-cases) with:
   - Environment: Sandbox
   - Company ID
   - Company Name
   - Integration requirements
2. Our integration program management team will review and provision your account
3. You'll receive access credentials to begin development

[Learn more about environments →](/docs/resources/environments)

---

### How do I find my Company ID?

Your Company ID is a numerical identifier required for API authentication and support requests. To locate it:

1. Log in to the [Field Nation Platform](https://app.fieldnation.com/)
2. Click your user icon in the top right corner
3. Select **Company Settings** from the dropdown menu
4. Click **Company Profile**
5. Your Company ID appears in the URL (e.g., `/company/profile/999` where `999` is your Company ID)

[Prerequisites guide →](/docs/getting-started/prerequisites)

---

### How do I obtain API credentials (client_id and client_secret)?

To request API credentials for Sandbox or Production environments:

1. Submit a [support case](https://app.fieldnation.com/support-cases) with:
   - **Environment URL**: Specify Sandbox or Production
   - **Company ID**: Your Field Nation Company ID
   - **Company Name**: Your organization's name
   - **Integration Type**: REST API, Webhooks, or Connectors
2. Our integration team will review and provide credentials
3. Store credentials securely and never commit to version control

**Security Best Practice**: Use environment variables or secure credential management systems to store API credentials.

[Support resources →](/docs/resources/support)

---

### Can service companies or providers access the API?

No. Currently, Field Nation only provides API and integration access to **buyers** (companies that post work orders). Service companies and providers do not have access to API credentials or integration features.

If you're a service company interested in integration capabilities, please contact your Field Nation representative to discuss available options.

## Integration Architecture & Options

### What integration options does Field Nation offer?

Field Nation provides three primary integration approaches:

1. **Pre-built Connectors** - Out-of-the-box integrations with popular field service management platforms (Salesforce, ServiceNow, Autotask, ConnectWise, etc.). Minimal code required, configured through UI.

2. **REST API** - Direct API integration for pushing work order data to Field Nation. Use for custom integrations or when a pre-built connector isn't available.

3. **Webhooks** - Subscribe to work order events and status changes to receive real-time updates from Field Nation. Use webhooks to pull data and maintain synchronization.

Most successful integrations use a combination: REST API for pushing data and Webhooks for receiving updates.

[Choosing Your Approach →](/docs/getting-started/choosing-your-approach)

---

### What's the difference between code-based and connector integrations?

**Code-Based Integration (REST API + Webhooks):**
- Maximum flexibility and customization
- Requires coding, API knowledge, error handling logic
- Best for custom workflows, unique data transformations
- Your team maintains code, monitors APIs

**Connector Integration (Pre-built):**
- Configuration-driven, less code (or no code for out-of-the-box)
- Standardized sync with popular platforms (CRM, ERP, PSA)
- Field Nation manages connector updates, API changes, retry logic
- Best for standard workflows, quick deployment

[Platform Overview →](/docs/getting-started/platform-overview)

---

### Which platforms are supported by out-of-the-box connectors?

Field Nation provides pre-built connectors for:

- **Autotask** - Datto Autotask PSA integration
- **ConnectWise** - ConnectWise Manage integration
- **Freshdesk** - Freshdesk ticketing system
- **NetSuite** - NetSuite ERP integration
- **Quickbase** - Quickbase application integration
- **Salesforce** - Salesforce Service Cloud integration
- **ServiceNow** - ServiceNow ITSM integration
- **Smartsheet** - Smartsheet project management integration
- **Zendesk** - Zendesk Support integration

Each connector includes configuration guides, workflow documentation, and troubleshooting resources.

---

### Can I sync custom fields between systems?

Yes. Most out-of-the-box integrations support custom field synchronization. To sync custom fields:

1. **Create Corresponding Fields** - Ensure custom fields exist in both Field Nation and your external system with compatible data types
2. **Configure Field Mappings** - Map the custom fields in the Integration Broker configuration
3. **Verify Permissions** - Ensure the integration API user has access to read/write custom fields
4. **Handle Data Types** - Use appropriate data type conversions if needed

Some platforms require additional configuration. Refer to your specific connector documentation for platform-specific requirements.

---

### Should I use templates and projects in Field Nation?

Yes. Using templates and projects is strongly recommended:

**Benefits:**
- **Reduced API Payload Size** - Reference templates instead of sending all work order details
- **Consistency** - Standardized information across work orders
- **Efficiency** - Faster work order creation with pre-configured data

**What Templates Include:**
- Tasks for providers (Check In, Check Out, Photo requirements)
- Custom fields for buyers and providers
- Attachments included with work orders
- Consistent Scope of Work (SOW) formatting
- Contact information

**Best Practice**: Set up templates in Field Nation before building your integration. This minimizes the data you need to send through the API for each work order.

## REST API & Webhooks

### What data can I push and pull through the APIs?

**Push to Field Nation (REST API):**
- Create and update work orders
- Manage work order assignments
- Update work order statuses
- Submit deliverables and close-out information

**Pull from Field Nation (Webhooks):**
- Work order status changes (33 events)
- Assignment updates
- Provider responses and requests
- Task completions
- Deliverable uploads
- Payment and approval events

**Recommended Approach:**
- Use **REST API** for pushing data to Field Nation
- Use **Webhooks** for pulling data and receiving real-time updates

[Webhooks documentation →](/docs/webhooks/introduction)

---

### What data do I receive in webhook payloads?

Webhook payloads include the **complete work order model**, not just snippets. When you subscribe to work order events, you receive:

- Full work order details (ID, title, description, location, schedule)
- Assignment information (provider details, status, pay rates)
- Task information (completed tasks, pending tasks)
- Custom field values
- Deliverables and attachments
- Status history and timestamps

The payload structure matches the REST API v2 work order model.

[Payload Structure →](/docs/webhooks/concepts/payload-structure)

---

### How do I test webhooks during development?

To test webhooks in a local development environment:

1. **Use a Tunnel Service:**
   - [ngrok](https://ngrok.com/) - Expose local servers to the internet
   - [localtunnel](https://localtunnel.github.io/www/) - Alternative tunnel service
   - Configure your webhook endpoint URL to point to the tunnel

2. **Set Up Your Endpoint:**
   - Ensure endpoint receives HTTP POST requests
   - Log all incoming requests for debugging
   - Return appropriate HTTP status codes (200-299 for success)

3. **Test in Sandbox:**
   - Configure webhooks in [Sandbox environment](https://ui-sandbox.fndev.net/integrations/webhooks)
   - Trigger test events in Field Nation
   - Verify payloads are received correctly

4. **Monitor Delivery Logs:**
   - Check webhook delivery logs in the Field Nation dashboard
   - Review any error responses from your endpoint
   - Verify retry behavior for failed deliveries

[Testing Guide →](/docs/webhooks/guides/testing)

---

### How are timestamps handled in the API?

Timestamps are sent as **UTC with timezone offsets**. The format follows ISO 8601 standards with offset information.

**Example:**
- `2012-12-05T17:00+05:00` (UTC+5)
- `2012-12-05T18:00+06:00` (UTC+6)

Both represent the same absolute time when converted to UTC (`2012-12-06T00:00+00:00`).

**Key Points:**
- Timestamps are universal and timezone-aware
- The offset indicates the timezone of the event
- Conversion to UTC is straightforward using the offset
- The timezone may vary based on the event location and type

---

### Can I assign work orders directly from my system?

Yes, but with important considerations:

**Technical Capability:**
- The API supports direct work order assignment
- You can assign providers to work orders programmatically

**Best Practice Recommendations:**
- Field Nation's platform includes sophisticated provider vetting tools (selection rules, recommended providers, performance metrics) that aren't available via API
- Most successful integrations focus on work order creation and status synchronization rather than automated assignment
- If assigning directly, build trusted preferred provider groups based on historical performance

**Important Note**: Unless you're a W2 provider, direct assignment bypasses Field Nation's marketplace matching algorithms.

## Field Service Connectors

### What is the Integration Broker and how does it work?

The Integration Broker is Field Nation's middleware system that manages bidirectional data synchronization between Field Nation and third-party platforms. It handles:

- **Authentication** - Manages API credentials and OAuth tokens for external systems
- **Field Discovery** - Automatically reads field metadata from connected platforms
- **Data Transformation** - Translates data schemas between systems using configurable mappings
- **Message Queuing** - Ensures reliable message delivery with retry mechanisms
- **Error Handling** - Logs errors, retries failed operations, and maintains error states

The broker operates as a message-driven architecture, processing inbound (external system → Field Nation) and outbound (Field Nation → external system) data flows.

---

### How do I customize field mappings in out-of-the-box integrations?

Field mappings can be customized using several approaches:

1. **Standard Mapping Actions:**
   - **Sync** - Direct field-to-field mapping
   - **Set Static** - Assign constant values
   - **Array Map** - Transform array data
   - **Range Map** - Map value ranges
   - **Date Convert** - Transform date formats
   - **Concat** - Combine multiple fields

2. **Custom Actions with JSONNET:**
   - Write JSONNET scripts for complex transformation logic
   - Implement conditional logic (if-then-else)
   - Access utility functions for common operations
   - Handle nested data structures

3. **Conditional Logic:**
   - Use custom actions to implement business rules
   - Populate fields based on data conditions
   - Apply different mappings based on work order properties

---

### What happens if my integration encounters an error?

The Integration Broker includes comprehensive error handling:

1. **Automatic Retry** - Failed operations automatically retry with exponential backoff to handle temporary network issues or rate limits
2. **Error Logging** - Detailed error information is logged with context for troubleshooting
3. **Alerts** - Configure email notifications for integration errors
4. **Dead Letter Queue** - Operations that exceed maximum retry attempts are held for manual review

The system prevents duplicate processing while ensuring data isn't lost during temporary failures.

---

### My out-of-the-box integration stopped syncing. What should I check first?

When an integration stops syncing, check these common issues in order:

1. **Authentication** - Verify API credentials are still valid. Expired tokens, changed passwords, or revoked API keys are the most common causes.
2. **Webhooks** - Confirm webhooks are still configured correctly in the external system and haven't been disabled or modified.
3. **Permissions** - Ensure the integration user still has appropriate permissions in both systems. Role changes or permission updates can break integrations.
4. **Rate Limits** - Check if you've exceeded API rate limits in either platform.
5. **Network Connectivity** - Verify network connectivity between systems and check firewall rules.

[Troubleshooting Guide →](/docs/webhooks/troubleshooting/common-issues)

## Support & Resources

### Who should I contact for integration help?

**For Integration-Specific Questions:**
- **Support Cases**: Submit a [support case](https://app.fieldnation.com/support-cases) for technical issues or credential requests
- **Phone Support**: Call +1 877-573-4353 for urgent issues

**For Platform Usage:**
- **General Support**: [Field Nation Support Portal](https://app.fieldnation.com/support-cases) for platform features and usage questions

**System Status:**
- **Status Page**: [status.fieldnation.com](https://status.fieldnation.com) for current system health

[Support Resources →](/docs/resources/support)

---

### What information should I include when requesting support?

When submitting a support case, include:

1. **Environment** - Specify Sandbox or Production
2. **Company ID** - Your Field Nation Company ID
3. **Integration Type** - REST API, Webhooks, or specific connector name
4. **Error Details** - Error messages, timestamps, and relevant logs
5. **Steps to Reproduce** - Clear description of what you were doing when the issue occurred
6. **Expected vs. Actual Behavior** - What you expected to happen vs. what actually happened

Providing complete information helps our support team resolve issues faster.

[Support Templates →](/docs/resources/support)

---

### Where can I find detailed technical documentation?

Comprehensive technical documentation is available:

**Getting Started:**
- [Introduction](/docs/getting-started/introduction) - Overview and quickstart
- [Prerequisites](/docs/getting-started/prerequisites) - What you need to begin
- [Choosing Your Approach](/docs/getting-started/choosing-your-approach) - Select integration method

**Webhooks:**
- [Introduction](/docs/webhooks/introduction) - Overview and features
- [Quickstart](/docs/webhooks/quickstart) - 15-minute setup guide
- [API Reference](/docs/webhooks/api-reference/overview) - Complete API documentation

**Resources:**
- [Glossary](/docs/resources/glossary) - Platform terminology
- [Error Codes](/docs/resources/error-codes) - Common errors and solutions
- [Environments](/docs/resources/environments) - Sandbox vs Production

---

### What should I build first when starting an integration?

Follow this recommended order:

1. **Check for Out-of-the-Box Solutions** - Review available connectors to see if a pre-built solution exists for your platform
2. **Evaluate Integration Approach** - If a connector exists, use it. If not, plan a custom solution using REST API and Webhooks
3. **Set Up Sandbox** - Request and configure sandbox access for development and testing
4. **Start with Core Functionality** - Begin with work order creation and status synchronization before adding advanced features
5. **Test Thoroughly** - Test in sandbox before moving to production

[Getting Started →](/docs/getting-started/introduction)

---

## Still Have Questions?

### Additional Resources

  
    Submit a support case or call us
  
  
    Understand platform terminology
  
  
    Common errors and solutions
  
  
    Check system status
  

---

### Quick Links

- **Submit Support Case**: [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases)
- **Phone Support**: +1 877-573-4353
- **Status Page**: [status.fieldnation.com](https://status.fieldnation.com)
- **Sandbox UI**: [app-sandbox.fndev.net](https://app-sandbox.fndev.net)
- **Sandbox API**: [api-sandbox.fndev.net](https://api-sandbox.fndev.net)

---

### undefined
URL: /docs/resources/glossary

# Resources: undefined
URL: /docs/resources/glossary
Source: content/docs/resources/glossary.mdx

---
title: Glossary
description: Comprehensive A-Z glossary of Field Nation Integration terminology, platform concepts, and technical terms.
icon: BookOpen
---

  
    - **API (Application Programming Interface)** — Protocols enabling software to talk to each other. Field Nation exposes REST API v2.  
    - **Access Token** — OAuth2 client-credentials token; expires in 1 hour.  
    - **Assignment** — Connecting a provider to a work order (marketplace, routing, or direct).  
    - **Autotask** — PSA platform with a pre-built Field Nation connector.
  

  
    - **Base URL** — Sandbox: `https://api-sandbox.fndev.net`; production available from Field Nation.  
    - **Buyer** — Posts work orders; has API access.  
    - **Broker (Integration Broker)** — Middleware handling auth, transformation, queuing, retries.
  

  
    - **Client ID / Client Secret** — OAuth2 credentials; keep secrets out of source control.  
    - **Company ID** — Org identifier (e.g., `/company/profile/123`).  
    - **Connector / Out-of-the-Box Connector** — Pre-built integration (Salesforce, ServiceNow, Autotask, etc.).  
    - **Custom Field** — Buyer-defined fields; can sync across systems.  
    - **ConnectWise** — Business management platform with a connector.
  

  
    - **Dead Letter Queue (DLQ)** — Holds webhook deliveries after retries exhausted.  
    - **Delivery Log** — Record of webhook attempts (request/response, status, timestamps).  
    - **Deliverable** — Proof of completion (photos, docs, checklists).
  

  
    - **Event / Event ID** — Webhook-triggering occurrence; use IDs for idempotency.  
    - **Exponential Backoff** — Retry delays double each attempt (10s, 20s, 40s, ...).
  

  
    - **Field Mapping** — Defines how fields correspond across systems.  
    - **Field Nation Platform** — Buyer UI (`app.fieldnation.com`, sandbox `app-sandbox.fndev.net`).  
    - **Freshdesk** — Support platform with a connector.
  

  
    - **GMT** — Timezone reference for UTC; timestamps use UTC with offsets.
  

  
    - **HMAC-SHA256** — Webhook signature algorithm.  
    - **HTTP Status Code** — e.g., 200 success, 401 unauthorized, 404 not found, 500 server error.
  

  
    - **Idempotency** — Multiple deliveries, same result; rely on event IDs.  
    - **Integration Broker** — See Broker.  
    - **IP Whitelisting** — Restrict webhook ingress to Field Nation IP ranges.  
    - **ISO 8601** — Timestamp format with timezone offsets.
  

  
    - **JSONNET** — Templating language used in connectors for transformations.
  

  
    - **Legacy Field** — Deprecated webhook mapping approach; prefer custom headers.
  

  
    - **Marketplace** — Where work orders are posted and providers engage.  
    - **Message Queue** — Redis-backed queuing and retries for webhooks.  
    - **Middleware** — Integration layer for routing, transformation, error handling.
  

  
    - **NetSuite** — ERP with a Field Nation connector.  
    - **ngrok** — Tunneling tool for local webhook testing.
  

  
    - **OAuth 2.0** — Auth framework; client credentials flow for access tokens.  
    - **OpenAPI Specification** — API description; Field Nation ships REST v2 & Webhooks v3 specs.
  

  
    - **Payload** — Body of API or webhook message.  
    - **Production** — Live environment; special credentials required.  
    - **Provider** — Contractor; no API access.
  

  
    - **Quickbase** — Low-code platform with a connector.
  

  
    - **Rate Limit** — Request quotas for fairness/stability.  
    - **Redis** — Used for webhook queuing/caching.  
    - **REST** — Architectural style; REST API v2 follows REST principles.  
    - **Retry Logic** — Automatic retries with backoff.  
    - **Routing** — Auto-matching providers to work orders.
  

  
    - **Salesforce** — CRM with Service Cloud connector.  
    - **Sandbox** — Test environment (`https://app-sandbox.fndev.net`).  
    - **Schedule (Service Window)** — When work should be performed.  
    - **Scope of Work (SOW)** — Detailed work description.  
    - **Secret (Webhook Secret)** — Key used for HMAC signatures.  
    - **Service Company** — See Provider.  
    - **ServiceNow** — ITSM connector.  
    - **Signature (Webhook Signature)** — HMAC-SHA256 hash in `x-fn-signature`.  
    - **Smartsheet** — Work management connector.  
    - **Status (Work Order Status)** — Lifecycle states (draft, published, assigned, done, approved, paid).  
    - **Status Page** — [status.fieldnation.com](https://status.fieldnation.com).
  

  
    - **Template** — Pre-configured work order blueprint.  
    - **Timestamp** — ISO 8601 with timezone offset.  
    - **Token** — See Access Token.
  

  
    - **UTC** — Global time standard; used with offsets.
  

  
    - **Vetting** — Provider evaluation (background, insurance, performance).
  

  
    - **Webhook** — Event callback; Webhooks v3 used.  
    - **Work Order / Work Order ID** — Job record and its identifier.
  

  
    - **Zendesk** — Customer service platform with connector.
  

## Additional Resources

  
    Begin your integration journey
  
  
    Core platform concepts explained
  
  
    Frequently asked questions
  
  
    Get help with your integration

---

### undefined
URL: /docs/resources/support

# Resources: undefined
URL: /docs/resources/support
Source: content/docs/resources/support.mdx

---
title: Support & Help
description: Get help with Field Nation Integration through support cases, phone support, and comprehensive resources.
icon: LifeBuoy
---

## Support Channels

### Submit a Support Case

The primary way to get integration support is through the Field Nation Support Portal.

**Support Portal**: [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases)

**When to submit a case:**
- Request API credentials or sandbox access
- Report technical issues or errors
- Get help with integration configuration
- Request feature enhancements
- Report security concerns

> [INFO] **Response Time**: Support cases are typically responded to within 1 business day for standard issues. Critical issues receive faster attention.

---

### Phone Support

For urgent issues or immediate assistance:

**Field Nation Support**: +1 877-573-4353

**Available**: 24/7, including weekends and holidays

- **Monday - Friday**: Full support capacity
- **Weekends & Holidays**: Limited support capacity

**Best for:**
- Critical production issues
- Time-sensitive problems
- Complex technical discussions
- Escalation of existing cases

> [INFO] **24/7 Availability**: Field Nation support is available around the clock. For the fastest resolution, submitting a support case with detailed error logs and screenshots is recommended, especially for non-urgent integration-specific technical issues.

---

## What to Include in Support Requests

### Essential Information

Always include these details when submitting a support case:

### Environment Details

Specify which environment you're working with:
- **Sandbox**: `https://app-sandbox.fndev.net` or `https://api-sandbox.fndev.net`
- **Production**: `https://app.fieldnation.com` or `https://api.fieldnation.com`

### Company Information

- **Company ID**: Found in Company Settings > Company Profile
- **Company Name**: Your organization name in Field Nation

### Integration Type

Specify your integration approach:
- REST API v2
- Webhooks v3
- Pre-built Connector (specify which: Salesforce, ServiceNow, etc.)
- Custom integration

### Error Details

Include comprehensive error information:
- Full error messages
- HTTP status codes
- Timestamps (in UTC or with timezone)
- Request/response payloads (remove sensitive data)
- Relevant log excerpts

### Steps to Reproduce

Provide clear steps to recreate the issue:
1. What you were trying to do
2. Actions you took
3. What you expected to happen
4. What actually happened

### Impact Assessment

Help us prioritize:
- How many users/work orders affected?
- Is this blocking production operations?
- Is there a workaround available?

---

## Support Request Templates

### API Credential Request

```
Subject: API Credential Request - [Sandbox/Production]

Environment: [Sandbox/Production]
Company ID: [Your Company ID]
Company Name: [Your Company Name]
Integration Type: [REST API / Webhooks / Connector Name]

Purpose:
[Brief description of your integration goals]

Requested Access:
- [ ] REST API v2 access
- [ ] Webhooks v3 access
- [ ] Specific connector access

Technical Contact:
Name: [Name]
Email: [Email]
Phone: [Phone]
```

---

### Technical Issue Report

```
Subject: [Integration Issue] - Brief Description

Environment: [Sandbox/Production]
Company ID: [Your Company ID]
Integration Type: [REST API / Webhooks / Connector]

Issue Description:
[Clear description of the problem]

Error Details:
- Error Message: [Full error message]
- Status Code: [HTTP status code if applicable]
- Timestamp: [When the error occurred]
- Request ID: [If available]

Steps to Reproduce:
1. [Step 1]
2. [Step 2]
3. [Step 3]

Expected Behavior:
[What should happen]

Actual Behavior:
[What actually happens]

Impact:
[How this affects your operations]

Logs/Screenshots:
[Attach relevant logs or screenshots]
```

---

### Webhook Delivery Failure

```
Subject: Webhook Delivery Failures - [Webhook ID]

Environment: [Sandbox/Production]
Company ID: [Your Company ID]
Webhook ID: [wh_xxxxx]
Endpoint URL: [Your webhook URL]

Issue:
Webhooks are failing to deliver with [error description]

Delivery Log Details:
- Delivery ID: [del_xxxxx]
- Event Name: [event name]
- Delivery Status: [HTTP status]
- Error Message: [error from delivery log]
- Timestamp: [when failures started]

Endpoint Status:
- [ ] Endpoint is publicly accessible
- [ ] SSL certificate is valid
- [ ] Firewall allows Field Nation IPs
- [ ] Endpoint responds within 30 seconds

Recent Changes:
[Any recent changes to your endpoint or infrastructure]
```

---

## Self-Service Resources

### Documentation

Comprehensive documentation for all integration approaches:

- **Getting Started**: [Introduction](/docs/getting-started/introduction)
- **REST API**: Available in REST API section (to be built)
- **Webhooks**: [Introduction](/docs/webhooks/introduction)
- **Connectors**: Available in Connectors section (to be built)

### Status Page

Check current system status and incident history:

**Status Page**: [status.fieldnation.com](https://status.fieldnation.com)

**What's available:**
- Real-time system status (Web App, Mobile App, API, Connectors)
- Active incidents and resolution progress
- Scheduled maintenance notifications
- Past incident history
- Subscribe to email/SMS notifications

> [INFO] Before submitting a support case, check the status page to see if there's a known issue affecting your integration.

---

### FAQ

Quick answers to common questions:

[View FAQ →](/docs/resources/faq)

**Popular topics:**
- Getting started and account setup
- API credentials and authentication
- Webhook configuration
- Integration troubleshooting
- Data synchronization

---

### Glossary

Understand Field Nation terminology:

[View Glossary →](/docs/resources/glossary)

Comprehensive A-Z reference for platform concepts, technical terms, and integration terminology.

---

## Emergency Escalation

### Production-Critical Issues

If you're experiencing a production-critical issue:

1. **Call Support Immediately**: +1 877-573-4353
2. **Mark Case as Critical**: When submitting a case, indicate severity level
3. **Provide Impact Details**: Number of affected work orders, users, or transactions
4. **Include Workaround Status**: Whether operations are completely blocked

### Security Issues

For security vulnerabilities or concerns:

1. **Do not post in public forums**
2. **Submit a confidential support case** marked "Security Issue"
3. **Include detailed vulnerability description**
4. **Follow responsible disclosure practices**

---

## Support Response Times

| Severity | Response Time | Example |
|----------|---------------|---------|
| **Critical** | 2-4 hours | Production system down, data loss, security breach |
| **High** | 4-8 hours | Major feature not working, significant user impact |
| **Medium** | 1 business day | Non-critical bugs, minor feature issues |
| **Low** | 2-3 business days | Enhancement requests, documentation questions |

> [INFO] **Note**: Response times are for initial response. Resolution time varies based on issue complexity.

---

## Additional Resources

### Community & Feedback

**Feature Requests**: Submit through support portal with detailed use case

**Feedback**: Share your integration experience through support cases

### Training & Onboarding

Contact your Field Nation representative for:
- Integration onboarding sessions
- Technical training
- Best practices consultation
- Architecture review

---

## Tips for Effective Support Requests

### Do's ✅

- Provide complete error messages and logs
- Include timestamps in UTC or with timezone
- Attach screenshots when helpful
- Specify exact steps to reproduce
- Remove sensitive data before sharing logs
- Follow up with additional information if requested

### Don'ts ❌

- Don't say "it doesn't work" without details
- Don't share API credentials in support cases
- Don't submit duplicate cases for the same issue
- Don't expect instant resolution for complex issues
- Don't wait until production to test and report issues

---

## Contact Information Quick Reference

| Need | Channel | Link |
|------|---------|------|
| **Submit Case** | Support Portal | [app.fieldnation.com/support-cases](https://app.fieldnation.com/support-cases) |
| **Phone Support** | Phone | +1 877-573-4353 |
| **System Status** | Status Page | [status.fieldnation.com](https://status.fieldnation.com) |
| **Documentation** | Docs Site | [developers.fieldnation.com](https://developers.fieldnation.com) |

---

---

## API References

## REST API (145)

### undefined
URL: /api-references/rest-api/v2

# API References: undefined
URL: /api-references/rest-api/v2
Source: content/api-references/rest-api/v2/index.mdx

---
title: Overview
description: Complete REST API v2 reference with interactive playground
icon: BookOpen
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

---

### undefined
URL: /api-references/rest-api/v2/authentication/token-post

# API References: undefined
URL: /api-references/rest-api/v2/authentication/token-post
Source: content/api-references/rest-api/v2/authentication/token-post.mdx

---
title: Generate Access Token
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Exchange your client and user credentials for an access token.

          Use the returned `access_token` as a Bearer token in the
          `Authorization`

          header when calling the Client API.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Exchange your client and user credentials for an access token.
Use the returned `access_token` as a Bearer token in the `Authorization`
header when calling the Client API.

---

### undefined
URL: /api-references/rest-api/v2/attachments/attachmentid-delete

# API References: undefined
URL: /api-references/rest-api/v2/attachments/attachmentid-delete
Source: content/api-references/rest-api/v2/attachments/attachmentid-delete.mdx

---
title: Delete Attachment Folder
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete an attachment file from the specified folder.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete an attachment file from the specified folder.

---

### undefined
URL: /api-references/rest-api/v2/attachments/attachmentid-put

# API References: undefined
URL: /api-references/rest-api/v2/attachments/attachmentid-put
Source: content/api-references/rest-api/v2/attachments/attachmentid-put.mdx

---
title: Update Work Order Attachment
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Update attachment metadata (for example, visibility or notes) within
          the

          specified folder.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update attachment metadata (for example, visibility or notes) within the
specified folder.

---

### undefined
URL: /api-references/rest-api/v2/attachments/attachments-get

# API References: undefined
URL: /api-references/rest-api/v2/attachments/attachments-get
Source: content/api-references/rest-api/v2/attachments/attachments-get.mdx

---
title: List Work Order Attachments
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: List attachment folders and files associated with the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List attachment folders and files associated with the work order.

---

### undefined
URL: /api-references/rest-api/v2/attachments/attachments-post

# API References: undefined
URL: /api-references/rest-api/v2/attachments/attachments-post
Source: content/api-references/rest-api/v2/attachments/attachments-post.mdx

---
title: Create Attachment Folder
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create a new attachment folder to organize files for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a new attachment folder to organize files for the work order.

---

### undefined
URL: /api-references/rest-api/v2/attachments/folderid-post

# API References: undefined
URL: /api-references/rest-api/v2/attachments/folderid-post
Source: content/api-references/rest-api/v2/attachments/folderid-post.mdx

---
title: Create Work Order Attachment
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Upload a file to the specified attachment folder using
          `multipart/form-data`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Upload a file to the specified attachment folder using
`multipart/form-data`.

---

### undefined
URL: /api-references/rest-api/v2/assignments/assignee-delete

# API References: undefined
URL: /api-references/rest-api/v2/assignments/assignee-delete
Source: content/api-references/rest-api/v2/assignments/assignee-delete.mdx

---
title: Unassign user from a work order
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Remove the assigned provider (user) from a work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove the assigned provider (user) from a work order.

---

### undefined
URL: /api-references/rest-api/v2/assignments/cancel-post

# API References: undefined
URL: /api-references/rest-api/v2/assignments/cancel-post
Source: content/api-references/rest-api/v2/assignments/cancel-post.mdx

---
title: Unassign Work Order Provider
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Unassign and remove the currently assigned provider from the work
          order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Unassign and remove the currently assigned provider from the work order.

---

### undefined
URL: /api-references/rest-api/v2/assignments/delay-post

# API References: undefined
URL: /api-references/rest-api/v2/assignments/delay-post
Source: content/api-references/rest-api/v2/assignments/delay-post.mdx

---
title: Acknowledge Provider Delay
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Acknowledge a provider-reported delay on the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Acknowledge a provider-reported delay on the work order.

---

### undefined
URL: /api-references/rest-api/v2/assignments/providers-get

# API References: undefined
URL: /api-references/rest-api/v2/assignments/providers-get
Source: content/api-references/rest-api/v2/assignments/providers-get.mdx

---
title: List Work Order Pending Requests
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          List pending provider requests (e.g., route requests) for the work
          order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List pending provider requests (e.g., route requests) for the work order.

---

### undefined
URL: /api-references/rest-api/v2/bundles/bundle-delete

# API References: undefined
URL: /api-references/rest-api/v2/bundles/bundle-delete
Source: content/api-references/rest-api/v2/bundles/bundle-delete.mdx

---
title: Delete Work Order Bundle
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete the bundle associated with the specified work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete the bundle associated with the specified work order.

---

### undefined
URL: /api-references/rest-api/v2/bundles/bundle-post

# API References: undefined
URL: /api-references/rest-api/v2/bundles/bundle-post
Source: content/api-references/rest-api/v2/bundles/bundle-post.mdx

---
title: Bundle Work Order
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Create a bundle that groups multiple work orders together for unified
          management and routing.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a bundle that groups multiple work orders together for unified
management and routing.

---

### undefined
URL: /api-references/rest-api/v2/bundles/unbundle-post

# API References: undefined
URL: /api-references/rest-api/v2/bundles/unbundle-post
Source: content/api-references/rest-api/v2/bundles/unbundle-post.mdx

---
title: Unbundle Work Order
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Remove work orders from a previously created bundle.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove work orders from a previously created bundle.

---

### undefined
URL: /api-references/rest-api/v2/bundles/validate-post

# API References: undefined
URL: /api-references/rest-api/v2/bundles/validate-post
Source: content/api-references/rest-api/v2/bundles/validate-post.mdx

---
title: Validate Work Order Bundle
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Validate that a list of work orders can be bundled together. Returns
          validation diagnostics without making changes.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Validate that a list of work orders can be bundled together. Returns
validation diagnostics without making changes.

---

### undefined
URL: /api-references/rest-api/v2/clients/clientid-get

# API References: undefined
URL: /api-references/rest-api/v2/clients/clientid-get
Source: content/api-references/rest-api/v2/clients/clientid-get.mdx

---
title: Get Client
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve details for a single client company identified by
          `client_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve details for a single client company identified by `client_id`.

---

### undefined
URL: /api-references/rest-api/v2/clients/clients-get

# API References: undefined
URL: /api-references/rest-api/v2/clients/clients-get
Source: content/api-references/rest-api/v2/clients/clients-get.mdx

---
title: List Clients
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated list of client companies with optional filters,
          lists, and column selection.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated list of client companies with optional filters, lists, and column selection.

---

### undefined
URL: /api-references/rest-api/v2/clients/clients-post

# API References: undefined
URL: /api-references/rest-api/v2/clients/clients-post
Source: content/api-references/rest-api/v2/clients/clients-post.mdx

---
title: Create Client
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Creates a new client for your company
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Creates a new client for your company

---

### undefined
URL: /api-references/rest-api/v2/contacts/contactid-delete

# API References: undefined
URL: /api-references/rest-api/v2/contacts/contactid-delete
Source: content/api-references/rest-api/v2/contacts/contactid-delete.mdx

---
title: Delete Work Order Contact
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Remove a contact from the work order by `contact_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove a contact from the work order by `contact_id`.

---

### undefined
URL: /api-references/rest-api/v2/contacts/contactid-put

# API References: undefined
URL: /api-references/rest-api/v2/contacts/contactid-put
Source: content/api-references/rest-api/v2/contacts/contactid-put.mdx

---
title: Update Work Order Contact
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update a contact for the work order by `contact_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update a contact for the work order by `contact_id`.

---

### undefined
URL: /api-references/rest-api/v2/contacts/contacts-get

# API References: undefined
URL: /api-references/rest-api/v2/contacts/contacts-get
Source: content/api-references/rest-api/v2/contacts/contacts-get.mdx

---
title: List Work Order Contacts
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: List contacts associated with the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List contacts associated with the work order.

---

### undefined
URL: /api-references/rest-api/v2/contacts/contacts-post

# API References: undefined
URL: /api-references/rest-api/v2/contacts/contacts-post
Source: content/api-references/rest-api/v2/contacts/contacts-post.mdx

---
title: Create Work Order Contact
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Add a new contact to the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Add a new contact to the work order.

---

### undefined
URL: /api-references/rest-api/v2/bonuses/bonuses-get

# API References: undefined
URL: /api-references/rest-api/v2/bonuses/bonuses-get
Source: content/api-references/rest-api/v2/bonuses/bonuses-get.mdx

---
title: List Bonuses
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all bonus options available for work orders.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all bonus options available for work orders.

---

### undefined
URL: /api-references/rest-api/v2/core-operations/lists-get

# API References: undefined
URL: /api-references/rest-api/v2/core-operations/lists-get
Source: content/api-references/rest-api/v2/core-operations/lists-get.mdx

---
title: List Work Order Lists
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Return saved work order lists (e.g., tabs or saved searches) and their
          current counts, honoring the `list` and sticky parameters.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Return saved work order lists (e.g., tabs or saved searches) and their
current counts, honoring the `list` and sticky parameters.

---

### undefined
URL: /api-references/rest-api/v2/core-operations/workorderid-delete

# API References: undefined
URL: /api-references/rest-api/v2/core-operations/workorderid-delete
Source: content/api-references/rest-api/v2/core-operations/workorderid-delete.mdx

---
title: Delete Work Order
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Cancel and delete a work order. A `cancel_reason` is required to
          document the reason for deletion.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Cancel and delete a work order. A `cancel_reason` is required to
document the reason for deletion.

---

### undefined
URL: /api-references/rest-api/v2/core-operations/workorderid-get

# API References: undefined
URL: /api-references/rest-api/v2/core-operations/workorderid-get
Source: content/api-references/rest-api/v2/core-operations/workorderid-get.mdx

---
title: Get Work Order Details
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Get full details for a specific work order. Use `columns` to control
          which sections are included in the response.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Get full details for a specific work order. Use `columns` to control
which sections are included in the response.

---

### undefined
URL: /api-references/rest-api/v2/core-operations/workorderid-put

# API References: undefined
URL: /api-references/rest-api/v2/core-operations/workorderid-put
Source: content/api-references/rest-api/v2/core-operations/workorderid-put.mdx

---
title: Update Work Order
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Update an existing work order. Only the provided fields will be
          updated.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update an existing work order. Only the provided fields will be updated.

---

### undefined
URL: /api-references/rest-api/v2/core-operations/workorders-get

# API References: undefined
URL: /api-references/rest-api/v2/core-operations/workorders-get
Source: content/api-references/rest-api/v2/core-operations/workorders-get.mdx

---
title: List Work Orders
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated list of work orders for your company.

          Use the extensive query filters (status, dates, location, pay,
          template, etc.)

          and `page`/`per_page` to control pagination. Use `columns`/`view` to
          adjust

          which fields are returned.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated list of work orders for your company.
Use the extensive query filters (status, dates, location, pay, template, etc.)
and `page`/`per_page` to control pagination. Use `columns`/`view` to adjust
which fields are returned.

---

### undefined
URL: /api-references/rest-api/v2/core-operations/workorders-post

# API References: undefined
URL: /api-references/rest-api/v2/core-operations/workorders-post
Source: content/api-references/rest-api/v2/core-operations/workorders-post.mdx

---
title: Create Work Order
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Create a new work order. Provide the essential details for the job;
          the response returns the newly created work order with identifiers.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a new work order. Provide the essential details for the job;
the response returns the newly created work order with identifiers.

---

### undefined
URL: /api-references/rest-api/v2/custom-fields/custom-fields-get

# API References: undefined
URL: /api-references/rest-api/v2/custom-fields/custom-fields-get
Source: content/api-references/rest-api/v2/custom-fields/custom-fields-get.mdx

---
title: List Custom Fields
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all custom fields available for work orders.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all custom fields available for work orders.

---

### undefined
URL: /api-references/rest-api/v2/custom-fields/customfieldid-get

# API References: undefined
URL: /api-references/rest-api/v2/custom-fields/customfieldid-get
Source: content/api-references/rest-api/v2/custom-fields/customfieldid-get.mdx

---
title: Get Work Order Custom Field
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a single custom field configuration/value by
          `custom_field_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a single custom field configuration/value by `custom_field_id`.

---

### undefined
URL: /api-references/rest-api/v2/custom-fields/customfieldid-put

# API References: undefined
URL: /api-references/rest-api/v2/custom-fields/customfieldid-put
Source: content/api-references/rest-api/v2/custom-fields/customfieldid-put.mdx

---
title: Update Work Order Custom Field
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update a custom field value/configuration for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update a custom field value/configuration for the work order.

---

### undefined
URL: /api-references/rest-api/v2/custom-fields/customfields-get

# API References: undefined
URL: /api-references/rest-api/v2/custom-fields/customfields-get
Source: content/api-references/rest-api/v2/custom-fields/customfields-get.mdx

---
title: List Work Order Custom Fields
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          List custom fields configured for this work order, including values
          and

          visibility.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List custom fields configured for this work order, including values and
visibility.

---

### undefined
URL: /api-references/rest-api/v2/location/location-get

# API References: undefined
URL: /api-references/rest-api/v2/location/location-get
Source: content/api-references/rest-api/v2/location/location-get.mdx

---
title: Get Work Order Location
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve the current location for a work order, including saved
          location

          details when applicable.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve the current location for a work order, including saved location
details when applicable.

---

### undefined
URL: /api-references/rest-api/v2/location/location-put

# API References: undefined
URL: /api-references/rest-api/v2/location/location-put
Source: content/api-references/rest-api/v2/location/location-put.mdx

---
title: Update Work Order Location
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Update the location associated with the work order (address, saved
          location,

          or coordinates).
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update the location associated with the work order (address, saved location,
or coordinates).

---

### undefined
URL: /api-references/rest-api/v2/company/expenses-get

# API References: undefined
URL: /api-references/rest-api/v2/company/expenses-get
Source: content/api-references/rest-api/v2/company/expenses-get.mdx

---
title: List Company Expenses
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all expense categories configured for your company.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all expense categories configured for your company.

---

### undefined
URL: /api-references/rest-api/v2/company/incomplete-reasons-get

# API References: undefined
URL: /api-references/rest-api/v2/company/incomplete-reasons-get
Source: content/api-references/rest-api/v2/company/incomplete-reasons-get.mdx

---
title: List Incomplete Reasons
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all incomplete reason options configured for your company.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all incomplete reason options configured for your company.

---

### undefined
URL: /api-references/rest-api/v2/company/managers-get

# API References: undefined
URL: /api-references/rest-api/v2/company/managers-get
Source: content/api-references/rest-api/v2/company/managers-get.mdx

---
title: List Company Managers
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all managers associated with your company.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all managers associated with your company.

---

### undefined
URL: /api-references/rest-api/v2/company/networks-get

# API References: undefined
URL: /api-references/rest-api/v2/company/networks-get
Source: content/api-references/rest-api/v2/company/networks-get.mdx

---
title: List Company Networks
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all networks accessible by the specified company.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all networks accessible by the specified company.

---

### undefined
URL: /api-references/rest-api/v2/company/site-revisit-reasons-get

# API References: undefined
URL: /api-references/rest-api/v2/company/site-revisit-reasons-get
Source: content/api-references/rest-api/v2/company/site-revisit-reasons-get.mdx

---
title: List Site Revisit Reasons
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve available reasons that providers and your company can select
          when entering revisit and job incomplete details.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve available reasons that providers and your company can select when entering revisit and job incomplete details.

---

### undefined
URL: /api-references/rest-api/v2/company/tags-get

# API References: undefined
URL: /api-references/rest-api/v2/company/tags-get
Source: content/api-references/rest-api/v2/company/tags-get.mdx

---
title: List Company Tags
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all tags associated with your company.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all tags associated with your company.

                       

---

### undefined
URL: /api-references/rest-api/v2/company/tags-post

# API References: undefined
URL: /api-references/rest-api/v2/company/tags-post
Source: content/api-references/rest-api/v2/company/tags-post.mdx

---
title: Create Company Tag
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create a new tag for your company.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a new tag for your company.

---

### undefined
URL: /api-references/rest-api/v2/finances/bonuses-get

# API References: undefined
URL: /api-references/rest-api/v2/finances/bonuses-get
Source: content/api-references/rest-api/v2/finances/bonuses-get.mdx

---
title: List Work Order Bonuses
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          List bonus entries that have been applied or are available for the
          work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List bonus entries that have been applied or are available for the
work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/bonusid-post

# API References: undefined
URL: /api-references/rest-api/v2/finances/bonusid-post
Source: content/api-references/rest-api/v2/finances/bonusid-post.mdx

---
title: Create Work Order Bonus
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create or apply a bonus by `bonus_id` to the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create or apply a bonus by `bonus_id` to the work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/discounts-get

# API References: undefined
URL: /api-references/rest-api/v2/finances/discounts-get
Source: content/api-references/rest-api/v2/finances/discounts-get.mdx

---
title: List Work Order Discounts
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: List any discounts applied to the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List any discounts applied to the work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/expenseid-put

# API References: undefined
URL: /api-references/rest-api/v2/finances/expenseid-put
Source: content/api-references/rest-api/v2/finances/expenseid-put.mdx

---
title: Update Work Order Expense
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update an existing expense entry for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update an existing expense entry for the work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/expenses-get

# API References: undefined
URL: /api-references/rest-api/v2/finances/expenses-get
Source: content/api-references/rest-api/v2/finances/expenses-get.mdx

---
title: List Work Order Expenses
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          List recorded expenses for the work order along with metadata and
          statuses.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List recorded expenses for the work order along with metadata and
statuses.

---

### undefined
URL: /api-references/rest-api/v2/finances/expenses-post

# API References: undefined
URL: /api-references/rest-api/v2/finances/expenses-post
Source: content/api-references/rest-api/v2/finances/expenses-post.mdx

---
title: Create Work Order Expense
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create a new expense entry for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a new expense entry for the work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/increaseid-get

# API References: undefined
URL: /api-references/rest-api/v2/finances/increaseid-get
Source: content/api-references/rest-api/v2/finances/increaseid-get.mdx

---
title: Get Work Order Increase
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve details for a specific pay increase on this work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve details for a specific pay increase on this work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/increaseid-put

# API References: undefined
URL: /api-references/rest-api/v2/finances/increaseid-put
Source: content/api-references/rest-api/v2/finances/increaseid-put.mdx

---
title: Update Work Order Pay Increase
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update a specific pay increase entry for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update a specific pay increase entry for the work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/increases-get

# API References: undefined
URL: /api-references/rest-api/v2/finances/increases-get
Source: content/api-references/rest-api/v2/finances/increases-get.mdx

---
title: List Work Order Increases
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: List pay increases applied to the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List pay increases applied to the work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/pay-get

# API References: undefined
URL: /api-references/rest-api/v2/finances/pay-get
Source: content/api-references/rest-api/v2/finances/pay-get.mdx

---
title: Get work order pay
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Get the full pay breakdown for a work order, including base,
          additional,

          fees, bonuses, expenses, penalties and totals.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Get the full pay breakdown for a work order, including base, additional,
fees, bonuses, expenses, penalties and totals.

---

### undefined
URL: /api-references/rest-api/v2/finances/pay-put

# API References: undefined
URL: /api-references/rest-api/v2/finances/pay-put
Source: content/api-references/rest-api/v2/finances/pay-put.mdx

---
title: Update Work Order Pay
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Update the pay configuration for a work order. Only provided fields
          are changed.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update the pay configuration for a work order. Only provided fields are changed.

---

### undefined
URL: /api-references/rest-api/v2/finances/penalties-get

# API References: undefined
URL: /api-references/rest-api/v2/finances/penalties-get
Source: content/api-references/rest-api/v2/finances/penalties-get.mdx

---
title: List Work Order Penalties
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: List penalty entries associated with the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List penalty entries associated with the work order.

---

### undefined
URL: /api-references/rest-api/v2/finances/penaltyid-post

# API References: undefined
URL: /api-references/rest-api/v2/finances/penaltyid-post
Source: content/api-references/rest-api/v2/finances/penaltyid-post.mdx

---
title: Create Work Order Penalty
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create or apply a penalty by `penalty_id` to the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create or apply a penalty by `penalty_id` to the work order.

---

### undefined
URL: /api-references/rest-api/v2/locations/locationid-get

# API References: undefined
URL: /api-references/rest-api/v2/locations/locationid-get
Source: content/api-references/rest-api/v2/locations/locationid-get.mdx

---
title: Get Location
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve details for a single saved location identified by
          `location_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve details for a single saved location identified by `location_id`.

---

### undefined
URL: /api-references/rest-api/v2/locations/locations-get

# API References: undefined
URL: /api-references/rest-api/v2/locations/locations-get
Source: content/api-references/rest-api/v2/locations/locations-get.mdx

---
title: List Locations
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Gets stored locations
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Gets stored locations

---

### undefined
URL: /api-references/rest-api/v2/locations/locations-post

# API References: undefined
URL: /api-references/rest-api/v2/locations/locations-post
Source: content/api-references/rest-api/v2/locations/locations-post.mdx

---
title: Create Location
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Add a location to company
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Add a location to company

---

### undefined
URL: /api-references/rest-api/v2/messages/messageid-post

# API References: undefined
URL: /api-references/rest-api/v2/messages/messageid-post
Source: content/api-references/rest-api/v2/messages/messageid-post.mdx

---
title: Reply to Work Order Message
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Reply to an existing work order message by its `message_id`.
          Supports asynchronous processing via `async=true`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Reply to an existing work order message by its `message_id`.
Supports asynchronous processing via `async=true`.

---

### undefined
URL: /api-references/rest-api/v2/messages/messages-get

# API References: undefined
URL: /api-references/rest-api/v2/messages/messages-get
Source: content/api-references/rest-api/v2/messages/messages-get.mdx

---
title: List Work Order Messages
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Retrieve all messages for a work order. Use the `archived` filter to
          include or exclude archived messages.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all messages for a work order. Use the `archived` filter to
include or exclude archived messages.

---

### undefined
URL: /api-references/rest-api/v2/messages/messages-post

# API References: undefined
URL: /api-references/rest-api/v2/messages/messages-post
Source: content/api-references/rest-api/v2/messages/messages-post.mdx

---
title: Create Work Order Message
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Post a new message to a work order. Optionally set `async=true` to
          process the delivery asynchronously.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Post a new message to a work order. Optionally set `async=true` to
process the delivery asynchronously.

---

### undefined
URL: /api-references/rest-api/v2/penalties/penalties-get

# API References: undefined
URL: /api-references/rest-api/v2/penalties/penalties-get
Source: content/api-references/rest-api/v2/penalties/penalties-get.mdx

---
title: List Penalties
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all penalty options available for work orders.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all penalty options available for work orders.

---

### undefined
URL: /api-references/rest-api/v2/milestones/milestones-get

# API References: undefined
URL: /api-references/rest-api/v2/milestones/milestones-get
Source: content/api-references/rest-api/v2/milestones/milestones-get.mdx

---
title: List Work Order Milestones
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          List key lifecycle timestamps for the work order (created, published,
          routed, assigned, work done, approved, paid).
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List key lifecycle timestamps for the work order (created, published,
routed, assigned, work done, approved, paid).

---

### undefined
URL: /api-references/rest-api/v2/preferred-providers/preferred-provider-groups-get

# API References: undefined
URL: /api-references/rest-api/v2/preferred-providers/preferred-provider-groups-get
Source: content/api-references/rest-api/v2/preferred-providers/preferred-provider-groups-get.mdx

---
title: List Talent Pool Groups
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve all talent pool groups (preferred provider groups) available
          to your company.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all talent pool groups (preferred provider groups) available to your company.

---

### undefined
URL: /api-references/rest-api/v2/preferred-providers/preferredprovidergroupid-get

# API References: undefined
URL: /api-references/rest-api/v2/preferred-providers/preferredprovidergroupid-get
Source: content/api-references/rest-api/v2/preferred-providers/preferredprovidergroupid-get.mdx

---
title: Get Talent Pool Group Details
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve detailed information about a specific talent pool group by
          its ID.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve detailed information about a specific talent pool group by its ID.

---

### undefined
URL: /api-references/rest-api/v2/preferred-providers/select-all-get

# API References: undefined
URL: /api-references/rest-api/v2/preferred-providers/select-all-get
Source: content/api-references/rest-api/v2/preferred-providers/select-all-get.mdx

---
title: List Provider IDs by Group
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve all provider IDs associated with a specific preferred
          provider group.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all provider IDs associated with a specific preferred provider group.

---

### undefined
URL: /api-references/rest-api/v2/preferred-providers/userid-post

# API References: undefined
URL: /api-references/rest-api/v2/preferred-providers/userid-post
Source: content/api-references/rest-api/v2/preferred-providers/userid-post.mdx

---
title: Add Provider to Talent Pool Group
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Add a provider to a specific talent pool group.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Add a provider to a specific talent pool group.

                       

---

### undefined
URL: /api-references/rest-api/v2/preferred-providers/users-delete

# API References: undefined
URL: /api-references/rest-api/v2/preferred-providers/users-delete
Source: content/api-references/rest-api/v2/preferred-providers/users-delete.mdx

---
title: Remove Providers from Talent Pool Group
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Remove one or more providers from a talent pool group.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove one or more providers from a talent pool group.

---

### undefined
URL: /api-references/rest-api/v2/preferred-providers/users-get

# API References: undefined
URL: /api-references/rest-api/v2/preferred-providers/users-get
Source: content/api-references/rest-api/v2/preferred-providers/users-get.mdx

---
title: List Talent Pool Group Users
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all providers (users) in a specific talent pool group.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all providers (users) in a specific talent pool group.

---

### undefined
URL: /api-references/rest-api/v2/problems/problemid-delete

# API References: undefined
URL: /api-references/rest-api/v2/problems/problemid-delete
Source: content/api-references/rest-api/v2/problems/problemid-delete.mdx

---
title: Delete Work Order Problem
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete a problem record by `problem_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete a problem record by `problem_id`.

---

### undefined
URL: /api-references/rest-api/v2/problems/problemid-put

# API References: undefined
URL: /api-references/rest-api/v2/problems/problemid-put
Source: content/api-references/rest-api/v2/problems/problemid-put.mdx

---
title: Update Work Order Problem
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update an existing problem record by `problem_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update an existing problem record by `problem_id`.

---

### undefined
URL: /api-references/rest-api/v2/problems/problems-get

# API References: undefined
URL: /api-references/rest-api/v2/problems/problems-get
Source: content/api-references/rest-api/v2/problems/problems-get.mdx

---
title: List Work Order Problems
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          List reported problems for the work order, including types and
          statuses.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List reported problems for the work order, including types and statuses.

---

### undefined
URL: /api-references/rest-api/v2/problems/problems-post

# API References: undefined
URL: /api-references/rest-api/v2/problems/problems-post
Source: content/api-references/rest-api/v2/problems/problems-post.mdx

---
title: Create Work Order Problem
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Report a new problem for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Report a new problem for the work order.

---

### undefined
URL: /api-references/rest-api/v2/projects/projectid-get

# API References: undefined
URL: /api-references/rest-api/v2/projects/projectid-get
Source: content/api-references/rest-api/v2/projects/projectid-get.mdx

---
title: Get project by ID
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve the full details for a single project identified by
          `project_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve the full details for a single project identified by `project_id`.

---

### undefined
URL: /api-references/rest-api/v2/projects/projects-get

# API References: undefined
URL: /api-references/rest-api/v2/projects/projects-get
Source: content/api-references/rest-api/v2/projects/projects-get.mdx

---
title: Get projects
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated list of projects for your company with optional
          filters and column selection.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated list of projects for your company with optional filters and column selection.

---

### undefined
URL: /api-references/rest-api/v2/projects/projects-post

# API References: undefined
URL: /api-references/rest-api/v2/projects/projects-post
Source: content/api-references/rest-api/v2/projects/projects-post.mdx

---
title: Create project
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Create a new project for your company, including core details and
          configuration for organizing work orders.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a new project for your company, including core details and configuration for organizing work orders.

---

### undefined
URL: /api-references/rest-api/v2/projects/providerid-get

# API References: undefined
URL: /api-references/rest-api/v2/projects/providerid-get
Source: content/api-references/rest-api/v2/projects/providerid-get.mdx

---
title: Get Provider Talent Pool Group Assignments in Project
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          This endpoint retrieves all talent pool groups and their tiers that a
          provider is assigned to within a specific project
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

This endpoint retrieves all talent pool groups and their tiers that a provider is assigned to within a specific project

---

### undefined
URL: /api-references/rest-api/v2/projects/providerid-put

# API References: undefined
URL: /api-references/rest-api/v2/projects/providerid-put
Source: content/api-references/rest-api/v2/projects/providerid-put.mdx

---
title: Update Provider Talent Pool Group Assignments in Project
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          This endpoint updates a provider's talent pool group and tier
          assignments for a specific project. It removes old tier assignments
          and adds new ones based on the provided data. The provider ID itself
          cannot be changed.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

This endpoint updates a provider's talent pool group and tier assignments for a specific project. It removes old tier assignments and adds new ones based on the provided data. The provider ID itself cannot be changed.

---

### undefined
URL: /api-references/rest-api/v2/projects/providers-post

# API References: undefined
URL: /api-references/rest-api/v2/projects/providers-post
Source: content/api-references/rest-api/v2/projects/providers-post.mdx

---
title: Add multiple providers to project talent pool groups
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          This endpoint allows you to add one or more providers to multiple
          talent pool groups with specific tier (talent pool) assignments. Each
          talent pool group can have multiple tier assignments, and the
          providers will be added to the specified tier within each talent pool
          group.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

This endpoint allows you to add one or more providers to multiple talent pool groups with specific tier (talent pool) assignments. Each talent pool group can have multiple tier assignments, and the providers will be added to the specified tier within each talent pool group.

---

### undefined
URL: /api-references/rest-api/v2/revisits/incident-delete

# API References: undefined
URL: /api-references/rest-api/v2/revisits/incident-delete
Source: content/api-references/rest-api/v2/revisits/incident-delete.mdx

---
title: Delete Work Order Incident ID
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Remove the incident ID from the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove the incident ID from the work order.

---

### undefined
URL: /api-references/rest-api/v2/revisits/incident-put

# API References: undefined
URL: /api-references/rest-api/v2/revisits/incident-put
Source: content/api-references/rest-api/v2/revisits/incident-put.mdx

---
title: Update Work Order Incident
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update incident ID associated with the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update incident ID associated with the work order.

---

### undefined
URL: /api-references/rest-api/v2/revisits/job-status-put

# API References: undefined
URL: /api-references/rest-api/v2/revisits/job-status-put
Source: content/api-references/rest-api/v2/revisits/job-status-put.mdx

---
title: Update Work Order Job Status
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Update the job status of a work order (e.g., scope of work complete or
          incomplete).
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update the job status of a work order (e.g., scope of work complete or incomplete).

---

### undefined
URL: /api-references/rest-api/v2/revisits/revisitid-delete

# API References: undefined
URL: /api-references/rest-api/v2/revisits/revisitid-delete
Source: content/api-references/rest-api/v2/revisits/revisitid-delete.mdx

---
title: Delete Work Order Site Revisit
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete a site revisit entry by `revisit_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete a site revisit entry by `revisit_id`.

---

### undefined
URL: /api-references/rest-api/v2/revisits/revisitid-put

# API References: undefined
URL: /api-references/rest-api/v2/revisits/revisitid-put
Source: content/api-references/rest-api/v2/revisits/revisitid-put.mdx

---
title: Update Work Order Site Revisit
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update a site revisit entry by `revisit_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update a site revisit entry by `revisit_id`.

---

### undefined
URL: /api-references/rest-api/v2/revisits/site-revisits-get

# API References: undefined
URL: /api-references/rest-api/v2/revisits/site-revisits-get
Source: content/api-references/rest-api/v2/revisits/site-revisits-get.mdx

---
title: List Work Order Site Revisits
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          List site revisit entries for a work order, including counts and
          latest

          revisit details.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List site revisit entries for a work order, including counts and latest
revisit details.

---

### undefined
URL: /api-references/rest-api/v2/revisits/site-revisits-post

# API References: undefined
URL: /api-references/rest-api/v2/revisits/site-revisits-post
Source: content/api-references/rest-api/v2/revisits/site-revisits-post.mdx

---
title: Create Work Order Site Revisit
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create a site revisit record for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a site revisit record for the work order.

---

### undefined
URL: /api-references/rest-api/v2/qualifications/qualificationid-delete

# API References: undefined
URL: /api-references/rest-api/v2/qualifications/qualificationid-delete
Source: content/api-references/rest-api/v2/qualifications/qualificationid-delete.mdx

---
title: Delete Work Order Qualification
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents: []
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

---

### undefined
URL: /api-references/rest-api/v2/qualifications/qualifications-get

# API References: undefined
URL: /api-references/rest-api/v2/qualifications/qualifications-get
Source: content/api-references/rest-api/v2/qualifications/qualifications-get.mdx

---
title: List Work Order Qualifications
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: List the qualification rules and outcomes for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List the qualification rules and outcomes for the work order.

---

### undefined
URL: /api-references/rest-api/v2/qualifications/qualifications-post

# API References: undefined
URL: /api-references/rest-api/v2/qualifications/qualifications-post
Source: content/api-references/rest-api/v2/qualifications/qualifications-post.mdx

---
title: Create Work Order Qualification
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Add or update qualification requirements for a work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Add or update qualification requirements for a work order.

---

### undefined
URL: /api-references/rest-api/v2/qualifications/qualifications-put

# API References: undefined
URL: /api-references/rest-api/v2/qualifications/qualifications-put
Source: content/api-references/rest-api/v2/qualifications/qualifications-put.mdx

---
title: Update Work Order Qualification
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents: []
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

---

### undefined
URL: /api-references/rest-api/v2/shipments/shipmentid-delete

# API References: undefined
URL: /api-references/rest-api/v2/shipments/shipmentid-delete
Source: content/api-references/rest-api/v2/shipments/shipmentid-delete.mdx

---
title: Delete Work Order Shipment
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Remove a shipment entry from the work order by `shipment_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove a shipment entry from the work order by `shipment_id`.

---

### undefined
URL: /api-references/rest-api/v2/shipments/shipmentid-put

# API References: undefined
URL: /api-references/rest-api/v2/shipments/shipmentid-put
Source: content/api-references/rest-api/v2/shipments/shipmentid-put.mdx

---
title: Update Work Order Shipment
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update a shipment entry for the work order by `shipment_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update a shipment entry for the work order by `shipment_id`.

---

### undefined
URL: /api-references/rest-api/v2/shipments/shipments-get

# API References: undefined
URL: /api-references/rest-api/v2/shipments/shipments-get
Source: content/api-references/rest-api/v2/shipments/shipments-get.mdx

---
title: List Work Order Shipments
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          List shipments related to the work order, including direction, carrier
          and status.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List shipments related to the work order, including direction, carrier
and status.

---

### undefined
URL: /api-references/rest-api/v2/shipments/shipments-post

# API References: undefined
URL: /api-references/rest-api/v2/shipments/shipments-post
Source: content/api-references/rest-api/v2/shipments/shipments-post.mdx

---
title: Create Work Order Shipment
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create a shipment record for the work order (incoming or outgoing).
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a shipment record for the work order (incoming or outgoing).

---

### undefined
URL: /api-references/rest-api/v2/schedule/eta-get

# API References: undefined
URL: /api-references/rest-api/v2/schedule/eta-get
Source: content/api-references/rest-api/v2/schedule/eta-get.mdx

---
title: Get Work Order ETA
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Get the estimated time of arrival (ETA) and related timing information
          for this work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Get the estimated time of arrival (ETA) and related timing information
for this work order.

---

### undefined
URL: /api-references/rest-api/v2/schedule/schedule-get

# API References: undefined
URL: /api-references/rest-api/v2/schedule/schedule-get
Source: content/api-references/rest-api/v2/schedule/schedule-get.mdx

---
title: Get Work Order Schedule
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve the service window and scheduling information for a work
          order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve the service window and scheduling information for a work order.

---

### undefined
URL: /api-references/rest-api/v2/schedule/schedule-put

# API References: undefined
URL: /api-references/rest-api/v2/schedule/schedule-put
Source: content/api-references/rest-api/v2/schedule/schedule-put.mdx

---
title: Update Work Order Schedule
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update the service window and scheduling information for a work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update the service window and scheduling information for a work order.

---

### undefined
URL: /api-references/rest-api/v2/signatures/signatureid-delete

# API References: undefined
URL: /api-references/rest-api/v2/signatures/signatureid-delete
Source: content/api-references/rest-api/v2/signatures/signatureid-delete.mdx

---
title: Delete Work Order Signature
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete a signature from the work order by its ID.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete a signature from the work order by its ID.

---

### undefined
URL: /api-references/rest-api/v2/signatures/signatureid-get

# API References: undefined
URL: /api-references/rest-api/v2/signatures/signatureid-get
Source: content/api-references/rest-api/v2/signatures/signatureid-get.mdx

---
title: Get Work Order Signature
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve a single signature by its ID for the given work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a single signature by its ID for the given work order.

---

### undefined
URL: /api-references/rest-api/v2/signatures/signatures-get

# API References: undefined
URL: /api-references/rest-api/v2/signatures/signatures-get
Source: content/api-references/rest-api/v2/signatures/signatures-get.mdx

---
title: List Work Order Signatures
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          List signatures captured for the work order with metadata and
          authorship.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List signatures captured for the work order with metadata and authorship.

---

### undefined
URL: /api-references/rest-api/v2/signatures/signatures-post

# API References: undefined
URL: /api-references/rest-api/v2/signatures/signatures-post
Source: content/api-references/rest-api/v2/signatures/signatures-post.mdx

---
title: Create Work Order Signature
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Add a signature to the work order. Include the image data and metadata
          in the JSON payload.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Add a signature to the work order. Include the image data and metadata
in the JSON payload.

---

### undefined
URL: /api-references/rest-api/v2/tags/tagid-delete

# API References: undefined
URL: /api-references/rest-api/v2/tags/tagid-delete
Source: content/api-references/rest-api/v2/tags/tagid-delete.mdx

---
title: Delete Work Order Tag
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Remove a tag from the work order by `tag_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove a tag from the work order by `tag_id`.

---

### undefined
URL: /api-references/rest-api/v2/tags/tags-get

# API References: undefined
URL: /api-references/rest-api/v2/tags/tags-get
Source: content/api-references/rest-api/v2/tags/tags-get.mdx

---
title: List Work Order Tags
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: List tags assigned to the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List tags assigned to the work order.

---

### undefined
URL: /api-references/rest-api/v2/tags/tags-post

# API References: undefined
URL: /api-references/rest-api/v2/tags/tags-post
Source: content/api-references/rest-api/v2/tags/tags-post.mdx

---
title: Create Work Order Tag
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Add a tag to the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Add a tag to the work order.

---

### undefined
URL: /api-references/rest-api/v2/talent-pool-groups/groupuuid-delete

# API References: undefined
URL: /api-references/rest-api/v2/talent-pool-groups/groupuuid-delete
Source: content/api-references/rest-api/v2/talent-pool-groups/groupuuid-delete.mdx

---
title: Delete Talent Pool Group
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete a specific talent pool group and all its associated data.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete a specific talent pool group and all its associated data.

---

### undefined
URL: /api-references/rest-api/v2/talent-pool-groups/groupuuid-get

# API References: undefined
URL: /api-references/rest-api/v2/talent-pool-groups/groupuuid-get
Source: content/api-references/rest-api/v2/talent-pool-groups/groupuuid-get.mdx

---
title: Get Talent Pool Group Details
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve detailed information about a specific talent pool group by
          its UUID.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve detailed information about a specific talent pool group by its UUID.

---

### undefined
URL: /api-references/rest-api/v2/talent-pool-groups/groupuuid-put

# API References: undefined
URL: /api-references/rest-api/v2/talent-pool-groups/groupuuid-put
Source: content/api-references/rest-api/v2/talent-pool-groups/groupuuid-put.mdx

---
title: Update Talent Pool Group
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update a specific talent pool group and its associated talent pools.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update a specific talent pool group and its associated talent pools.

---

### undefined
URL: /api-references/rest-api/v2/talent-pool-groups/providerid-delete

# API References: undefined
URL: /api-references/rest-api/v2/talent-pool-groups/providerid-delete
Source: content/api-references/rest-api/v2/talent-pool-groups/providerid-delete.mdx

---
title: Remove Provider from Talent Pool Group
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Remove a provider from a talent pool group. Either `tierId` or
          `removeFromProject` query parameter is required. If `tierId` is
          provided, removes the provider from the specified talent pool (tier)
          within the group. If `removeFromProject` is true, removes the provider
          from all talent pool groups in the project.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove a provider from a talent pool group. Either `tierId` or `removeFromProject` query parameter is required. If `tierId` is provided, removes the provider from the specified talent pool (tier) within the group. If `removeFromProject` is true, removes the provider from all talent pool groups in the project.

---

### undefined
URL: /api-references/rest-api/v2/talent-pool-groups/providers-get

# API References: undefined
URL: /api-references/rest-api/v2/talent-pool-groups/providers-get
Source: content/api-references/rest-api/v2/talent-pool-groups/providers-get.mdx

---
title: List Providers in Talent Pool Group
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated list of providers in a specific talent pool group
          with optional sorting.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated list of providers in a specific talent pool group with optional sorting.

---

### undefined
URL: /api-references/rest-api/v2/talent-pool-groups/talent-pool-groups-get

# API References: undefined
URL: /api-references/rest-api/v2/talent-pool-groups/talent-pool-groups-get
Source: content/api-references/rest-api/v2/talent-pool-groups/talent-pool-groups-get.mdx

---
title: List Talent Pool Groups
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated list of talent pool groups with optional
          filtering and sorting.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated list of talent pool groups with optional filtering and sorting.

---

### undefined
URL: /api-references/rest-api/v2/talent-pool-groups/talent-pool-groups-post

# API References: undefined
URL: /api-references/rest-api/v2/talent-pool-groups/talent-pool-groups-post
Source: content/api-references/rest-api/v2/talent-pool-groups/talent-pool-groups-post.mdx

---
title: Create Talent Pool Group
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create a new talent pool group with associated talent pools.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a new talent pool group with associated talent pools.

---

### undefined
URL: /api-references/rest-api/v2/tasks/alertid-delete

# API References: undefined
URL: /api-references/rest-api/v2/tasks/alertid-delete
Source: content/api-references/rest-api/v2/tasks/alertid-delete.mdx

---
title: Delete Work Order Task Alert
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete a single alert for the specified task by `alert_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete a single alert for the specified task by `alert_id`.

---

### undefined
URL: /api-references/rest-api/v2/tasks/alerts-delete

# API References: undefined
URL: /api-references/rest-api/v2/tasks/alerts-delete
Source: content/api-references/rest-api/v2/tasks/alerts-delete.mdx

---
title: Delete Work Order Task Alerts
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Clear all alerts for the specified task.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Clear all alerts for the specified task.

---

### undefined
URL: /api-references/rest-api/v2/tasks/taskid-delete

# API References: undefined
URL: /api-references/rest-api/v2/tasks/taskid-delete
Source: content/api-references/rest-api/v2/tasks/taskid-delete.mdx

---
title: Delete Work Order Task
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Remove a task from the work order by `task_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove a task from the work order by `task_id`.

---

### undefined
URL: /api-references/rest-api/v2/tasks/taskid-get

# API References: undefined
URL: /api-references/rest-api/v2/tasks/taskid-get
Source: content/api-references/rest-api/v2/tasks/taskid-get.mdx

---
title: Get Work Order Task
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve the details for a single task by `task_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve the details for a single task by `task_id`.

---

### undefined
URL: /api-references/rest-api/v2/tasks/taskid-put

# API References: undefined
URL: /api-references/rest-api/v2/tasks/taskid-put
Source: content/api-references/rest-api/v2/tasks/taskid-put.mdx

---
title: Update Work Order Task
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update the details for a single task by `task_id`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update the details for a single task by `task_id`.

---

### undefined
URL: /api-references/rest-api/v2/tasks/tasks-get

# API References: undefined
URL: /api-references/rest-api/v2/tasks/tasks-get
Source: content/api-references/rest-api/v2/tasks/tasks-get.mdx

---
title: List Work Order Tasks
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          List tasks defined for the work order with current status and
          metadata.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List tasks defined for the work order with current status and metadata.

---

### undefined
URL: /api-references/rest-api/v2/tasks/tasks-post

# API References: undefined
URL: /api-references/rest-api/v2/tasks/tasks-post
Source: content/api-references/rest-api/v2/tasks/tasks-post.mdx

---
title: Create Work Order Task
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Create a new task within the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a new task within the work order.

---

### undefined
URL: /api-references/rest-api/v2/tasks/tasks-put

# API References: undefined
URL: /api-references/rest-api/v2/tasks/tasks-put
Source: content/api-references/rest-api/v2/tasks/tasks-put.mdx

---
title: Update Work Order Tasks
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Bulk update multiple tasks for a work order in a single request.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Bulk update multiple tasks for a work order in a single request.

---

### undefined
URL: /api-references/rest-api/v2/templates/templateid-get

# API References: undefined
URL: /api-references/rest-api/v2/templates/templateid-get
Source: content/api-references/rest-api/v2/templates/templateid-get.mdx

---
title: Get workorder template by id
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Retrieve a single work order template by `template_id`, including its
          tasks and configuration.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a single work order template by `template_id`, including its
tasks and configuration.

---

### undefined
URL: /api-references/rest-api/v2/templates/templates-get

# API References: undefined
URL: /api-references/rest-api/v2/templates/templates-get
Source: content/api-references/rest-api/v2/templates/templates-get.mdx

---
title: Get workorder templates
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Retrieve available work order templates that can be used to quickly
          create work orders with predefined fields and tasks.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve available work order templates that can be used to quickly
create work orders with predefined fields and tasks.

---

### undefined
URL: /api-references/rest-api/v2/types-of-work/service-types-get

# API References: undefined
URL: /api-references/rest-api/v2/types-of-work/service-types-get
Source: content/api-references/rest-api/v2/types-of-work/service-types-get.mdx

---
title: List Service Types
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve all service types associated with a specific type of work.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all service types associated with a specific type of work.

---

### undefined
URL: /api-references/rest-api/v2/types-of-work/types-of-work-get

# API References: undefined
URL: /api-references/rest-api/v2/types-of-work/types-of-work-get
Source: content/api-references/rest-api/v2/types-of-work/types-of-work-get.mdx

---
title: Get types of work
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve all available types of work and their associated service
          categories.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve all available types of work and their associated service categories.

---

### undefined
URL: /api-references/rest-api/v2/time-logs/timelogs-get

# API References: undefined
URL: /api-references/rest-api/v2/time-logs/timelogs-get
Source: content/api-references/rest-api/v2/time-logs/timelogs-get.mdx

---
title: List Work Order Time Logs
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          List all time logs recorded against the work order, including
          check-in/out

          and verification details.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List all time logs recorded against the work order, including check-in/out
and verification details.

---

### undefined
URL: /api-references/rest-api/v2/time-logs/timelogs-post

# API References: undefined
URL: /api-references/rest-api/v2/time-logs/timelogs-post
Source: content/api-references/rest-api/v2/time-logs/timelogs-post.mdx

---
title: Create Work Order Time Log
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Add a new time log (check-in or check-out) for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Add a new time log (check-in or check-out) for the work order.

---

### undefined
URL: /api-references/rest-api/v2/time-logs/timelogs-put

# API References: undefined
URL: /api-references/rest-api/v2/time-logs/timelogs-put
Source: content/api-references/rest-api/v2/time-logs/timelogs-put.mdx

---
title: Update All Work Order Time Logs
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Bulk update time logs for a work order in a single request.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Bulk update time logs for a work order in a single request.

---

### undefined
URL: /api-references/rest-api/v2/time-logs/workorderhoursid-delete

# API References: undefined
URL: /api-references/rest-api/v2/time-logs/workorderhoursid-delete
Source: content/api-references/rest-api/v2/time-logs/workorderhoursid-delete.mdx

---
title: Delete Work Order Time Log
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete a single time log entry from the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete a single time log entry from the work order.

---

### undefined
URL: /api-references/rest-api/v2/time-logs/workorderhoursid-put

# API References: undefined
URL: /api-references/rest-api/v2/time-logs/workorderhoursid-put
Source: content/api-references/rest-api/v2/time-logs/workorderhoursid-put.mdx

---
title: Update Work Order Time Log
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Update a single time log entry for the work order.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update a single time log entry for the work order.

---

### undefined
URL: /api-references/rest-api/v2/users/userid-get

# API References: undefined
URL: /api-references/rest-api/v2/users/userid-get
Source: content/api-references/rest-api/v2/users/userid-get.mdx

---
title: Get User Details
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Retrieve detailed information about a specific user by their ID.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve detailed information about a specific user by their ID.

---

### undefined
URL: /api-references/rest-api/v2/talent-pools/attributes-get

# API References: undefined
URL: /api-references/rest-api/v2/talent-pools/attributes-get
Source: content/api-references/rest-api/v2/talent-pools/attributes-get.mdx

---
title: List Provider Attributes
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated list of attributes for a specific provider in a
          talent pool with optional sorting.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated list of attributes for a specific provider in a talent pool with optional sorting.

---

### undefined
URL: /api-references/rest-api/v2/talent-pools/attributes-post

# API References: undefined
URL: /api-references/rest-api/v2/talent-pools/attributes-post
Source: content/api-references/rest-api/v2/talent-pools/attributes-post.mdx

---
title: Create Provider Attributes
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Add new attributes for a specific provider in a talent pool.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Add new attributes for a specific provider in a talent pool.

---

### undefined
URL: /api-references/rest-api/v2/talent-pools/attributes-put

# API References: undefined
URL: /api-references/rest-api/v2/talent-pools/attributes-put
Source: content/api-references/rest-api/v2/talent-pools/attributes-put.mdx

---
title: Update Provider Attributes
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Bulk update multiple attributes for a specific provider in a talent
          pool.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Bulk update multiple attributes for a specific provider in a talent pool.

---

### undefined
URL: /api-references/rest-api/v2/talent-pools/attributeuuid-delete

# API References: undefined
URL: /api-references/rest-api/v2/talent-pools/attributeuuid-delete
Source: content/api-references/rest-api/v2/talent-pools/attributeuuid-delete.mdx

---
title: Delete Provider Attribute
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Delete a specific attribute for a provider in a talent pool.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Delete a specific attribute for a provider in a talent pool.

---

### undefined
URL: /api-references/rest-api/v2/talent-pools/attributeuuid-put

# API References: undefined
URL: /api-references/rest-api/v2/talent-pools/attributeuuid-put
Source: content/api-references/rest-api/v2/talent-pools/attributeuuid-put.mdx

---
title: Update Provider Attribute
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Update the value of a specific attribute for a provider in a talent
          pool.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update the value of a specific attribute for a provider in a talent pool.

---

### undefined
URL: /api-references/rest-api/v2/workflow/approve-post

# API References: undefined
URL: /api-references/rest-api/v2/workflow/approve-post
Source: content/api-references/rest-api/v2/workflow/approve-post.mdx

---
title: Approve a Work Order
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: Approve a work order after the work is completed and verified.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Approve a work order after the work is completed and verified.

---

### undefined
URL: /api-references/rest-api/v2/workflow/assignee-post

# API References: undefined
URL: /api-references/rest-api/v2/workflow/assignee-post
Source: content/api-references/rest-api/v2/workflow/assignee-post.mdx

---
title: Assign user by work order
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Assign a provider (user) directly to a work order. Optionally include
          `clientPayTermsAccepted` to record acceptance of pay terms.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Assign a provider (user) directly to a work order. Optionally include
`clientPayTermsAccepted` to record acceptance of pay terms.

---

### undefined
URL: /api-references/rest-api/v2/workflow/autodispatch-post

# API References: undefined
URL: /api-references/rest-api/v2/workflow/autodispatch-post
Source: content/api-references/rest-api/v2/workflow/autodispatch-post.mdx

---
title: Auto-Dispatch Work Order
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Automatically dispatch a work order to a qualified provider based on
          configured dispatch rules.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Automatically dispatch a work order to a qualified provider based on
configured dispatch rules.

---

### undefined
URL: /api-references/rest-api/v2/workflow/complete-delete

# API References: undefined
URL: /api-references/rest-api/v2/workflow/complete-delete
Source: content/api-references/rest-api/v2/workflow/complete-delete.mdx

---
title: Incomplete a Work Order
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Mark a completed work order as incomplete. A `reason` and `reason_id`
          are required to document the change.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Mark a completed work order as incomplete. A `reason` and `reason_id`
are required to document the change.

---

### undefined
URL: /api-references/rest-api/v2/workflow/draft-delete

# API References: undefined
URL: /api-references/rest-api/v2/workflow/draft-delete
Source: content/api-references/rest-api/v2/workflow/draft-delete.mdx

---
title: Revert work order to draft status
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Revert a work order back to draft. Use `async=true` for asynchronous
          processing.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Revert a work order back to draft. Use `async=true` for asynchronous
processing.

---

### undefined
URL: /api-references/rest-api/v2/workflow/mass-route-post

# API References: undefined
URL: /api-references/rest-api/v2/workflow/mass-route-post
Source: content/api-references/rest-api/v2/workflow/mass-route-post.mdx

---
title: Mass route a work order to providers
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Route a work order to multiple providers in a single request.
          Submit the list of provider IDs in the request body.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Route a work order to multiple providers in a single request.
Submit the list of provider IDs in the request body.

---

### undefined
URL: /api-references/rest-api/v2/workflow/publish-delete

# API References: undefined
URL: /api-references/rest-api/v2/workflow/publish-delete
Source: content/api-references/rest-api/v2/workflow/publish-delete.mdx

---
title: Unpublish a Work Order
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Unpublish a previously published work order, returning it to draft.
          Use `async=true` to process asynchronously.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Unpublish a previously published work order, returning it to draft.
Use `async=true` to process asynchronously.

---

### undefined
URL: /api-references/rest-api/v2/workflow/publish-post

# API References: undefined
URL: /api-references/rest-api/v2/workflow/publish-post
Source: content/api-references/rest-api/v2/workflow/publish-post.mdx

---
title: Publish a Work Order
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Move a draft work order to a published state so it becomes available

          for routing and assignment. Use `async=true` to process
          asynchronously.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Move a draft work order to a published state so it becomes available
for routing and assignment. Use `async=true` to process asynchronously.

---

### undefined
URL: /api-references/rest-api/v2/workflow/route-delete

# API References: undefined
URL: /api-references/rest-api/v2/workflow/route-delete
Source: content/api-references/rest-api/v2/workflow/route-delete.mdx

---
title: Un-route a work order from an user
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: |-
          Remove a previously routed provider (user) from a work order.
          Supports asynchronous processing via `async=true`.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove a previously routed provider (user) from a work order.
Supports asynchronous processing via `async=true`.

---

### undefined
URL: /api-references/rest-api/v2/workflow/route-post

# API References: undefined
URL: /api-references/rest-api/v2/workflow/route-post
Source: content/api-references/rest-api/v2/workflow/route-post.mdx

---
title: Route a work order to a user
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Route a work order to a single provider (user). Use `acting_user_id`

          when routing on behalf of another user, and `async=true` for async
          mode.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Route a work order to a single provider (user). Use `acting_user_id`
when routing on behalf of another user, and `async=true` for async mode.

---

### undefined
URL: /api-references/rest-api/v2/workflow/status-get

# API References: undefined
URL: /api-references/rest-api/v2/workflow/status-get
Source: content/api-references/rest-api/v2/workflow/status-get.mdx

---
title: Get Work Order Status
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Return the current status of a work order (including sub-status and
          flags).
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Return the current status of a work order (including sub-status and flags).

---

## Webhooks (12)

### undefined
URL: /api-references/webhooks/v3

# API References: undefined
URL: /api-references/webhooks/v3
Source: content/api-references/webhooks/v3/index.mdx

---
title: Overview
description: Complete Webhooks v3 reference with interactive playground
icon: BookOpen
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

---

### undefined
URL: /api-references/webhooks/v3/core-operations/webhookid-delete

# API References: undefined
URL: /api-references/webhooks/v3/core-operations/webhookid-delete
Source: content/api-references/webhooks/v3/core-operations/webhookid-delete.mdx

---
title: Delete Webhook
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Permanently delete a webhook configuration so it no longer receives
          notifications.

          Delivery logs and history remain available for auditing, but the
          webhook itself cannot be recovered.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Permanently delete a webhook configuration so it no longer receives notifications.
Delivery logs and history remain available for auditing, but the webhook itself cannot be recovered.

---

### undefined
URL: /api-references/webhooks/v3/core-operations/webhookid-get

# API References: undefined
URL: /api-references/webhooks/v3/core-operations/webhookid-get
Source: content/api-references/webhooks/v3/core-operations/webhookid-get.mdx

---
title: Get Webhook Details
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve detailed information about a single webhook configuration,
          including subscribed events, status, and key settings.

          Use `fields` and `webhookAttribute` query parameters to control which
          core fields and additional attributes are returned.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve detailed information about a single webhook configuration, including subscribed events, status, and key settings.
Use `fields` and `webhookAttribute` query parameters to control which core fields and additional attributes are returned.

---

### undefined
URL: /api-references/webhooks/v3/core-operations/webhookid-put

# API References: undefined
URL: /api-references/webhooks/v3/core-operations/webhookid-put
Source: content/api-references/webhooks/v3/core-operations/webhookid-put.mdx

---
title: Update Webhook
full: true
_openapi:
  method: PUT
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Update an existing webhook configuration, such as the endpoint URL,
          HTTP method, subscribed events, status, or notification email.

          Only the fields you include in the request body are changed; omitted
          fields keep their current values.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Update an existing webhook configuration, such as the endpoint URL, HTTP method, subscribed events, status, or notification email.
Only the fields you include in the request body are changed; omitted fields keep their current values.

---

### undefined
URL: /api-references/webhooks/v3/core-operations/webhooks-get

# API References: undefined
URL: /api-references/webhooks/v3/core-operations/webhooks-get
Source: content/api-references/webhooks/v3/core-operations/webhooks-get.mdx

---
title: List Webhooks
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated list of webhooks configured for your company,
          with filters for status, search, sorting, and selected fields.

          Use this endpoint to quickly review and manage existing webhook
          configurations.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated list of webhooks configured for your company, with filters for status, search, sorting, and selected fields.
Use this endpoint to quickly review and manage existing webhook configurations.

---

### undefined
URL: /api-references/webhooks/v3/core-operations/webhooks-post

# API References: undefined
URL: /api-references/webhooks/v3/core-operations/webhooks-post
Source: content/api-references/webhooks/v3/core-operations/webhooks-post.mdx

---
title: Create Webhook
full: true
_openapi:
  method: POST
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Create a new webhook configuration for your company by providing the
          target URL, HTTP method, subscribed events, and status.

          After creation, the webhook receives notifications for the selected
          events and is assigned a unique `webhookId` for future operations.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Create a new webhook configuration for your company by providing the target URL, HTTP method, subscribed events, and status.
After creation, the webhook receives notifications for the selected events and is assigned a unique `webhookId` for future operations.

---

### undefined
URL: /api-references/webhooks/v3/delivery-logs/delivery-logs-get

# API References: undefined
URL: /api-references/webhooks/v3/delivery-logs/delivery-logs-get
Source: content/api-references/webhooks/v3/delivery-logs/delivery-logs-get.mdx

---
title: List Delivery Logs
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated list of webhook delivery attempts, including
          successful deliveries, failures, and retries.

          Filter results by webhook ID, work order ID, event name, or delivery
          status to monitor reliability and troubleshoot issues.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated list of webhook delivery attempts, including successful deliveries, failures, and retries.
Filter results by webhook ID, work order ID, event name, or delivery status to monitor reliability and troubleshoot issues.

---

### undefined
URL: /api-references/webhooks/v3/delivery-logs/deliveryid-get

# API References: undefined
URL: /api-references/webhooks/v3/delivery-logs/deliveryid-get
Source: content/api-references/webhooks/v3/delivery-logs/deliveryid-get.mdx

---
title: Get Delivery Log Details
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve detailed information about a single webhook delivery attempt,
          including status, timestamps, and a pre-signed URL to the full log
          file.

          Use this endpoint to investigate why a specific delivery succeeded or
          failed.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve detailed information about a single webhook delivery attempt, including status, timestamps, and a pre-signed URL to the full log file.
Use this endpoint to investigate why a specific delivery succeeded or failed.

---

### undefined
URL: /api-references/webhooks/v3/delivery-logs/retry-patch

# API References: undefined
URL: /api-references/webhooks/v3/delivery-logs/retry-patch
Source: content/api-references/webhooks/v3/delivery-logs/retry-patch.mdx

---
title: Retry Delivery Log
full: true
_openapi:
  method: PATCH
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retry a previously failed webhook delivery by its `deliveryId`,
          creating a new delivery job for the same payload.

          Use this endpoint after fixing issues on your endpoint to reprocess
          specific events and track the retry by job ID.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retry a previously failed webhook delivery by its `deliveryId`, creating a new delivery job for the same payload.
Use this endpoint after fixing issues on your endpoint to reprocess specific events and track the retry by job ID.

---

### undefined
URL: /api-references/webhooks/v3/events/events-get

# API References: undefined
URL: /api-references/webhooks/v3/events/events-get
Source: content/api-references/webhooks/v3/events/events-get.mdx

---
title: List Webhook Events
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          List all available webhook events that you can subscribe to, with
          basic details about each event.

          Use the optional `model` query parameter to filter events for a
          specific model type (for example, `WorkOrder` or `Provider`).
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

List all available webhook events that you can subscribe to, with basic details about each event.
Use the optional `model` query parameter to filter events for a specific model type (for example, `WorkOrder` or `Provider`).

---

### undefined
URL: /api-references/webhooks/v3/history/history-get

# API References: undefined
URL: /api-references/webhooks/v3/history/history-get
Source: content/api-references/webhooks/v3/history/history-get.mdx

---
title: List Webhook History
full: true
_openapi:
  method: GET
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Retrieve a paginated change history for a single webhook, including
          who made each change, what changed, and when it occurred.

          Use this audit trail to track configuration updates and troubleshoot
          issues.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Retrieve a paginated change history for a single webhook, including who made each change, what changed, and when it occurred.
Use this audit trail to track configuration updates and troubleshoot issues.

---

### undefined
URL: /api-references/webhooks/v3/attributes/attributename-delete

# API References: undefined
URL: /api-references/webhooks/v3/attributes/attributename-delete
Source: content/api-references/webhooks/v3/attributes/attributename-delete.mdx

---
title: Delete Webhook Attribute
full: true
_openapi:
  method: DELETE
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          Remove a specific webhook attribute (for example, a custom header or
          legacy field mapping) by its type and name.

          Use this endpoint to clean up attributes that are no longer needed on
          a webhook.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

Remove a specific webhook attribute (for example, a custom header or legacy field mapping) by its type and name.
Use this endpoint to clean up attributes that are no longer needed on a webhook.

---